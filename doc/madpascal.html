<html>
<head>

<title>MAD-PASCAL INSTRUKCJA</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">

<BODY BACKGROUND="6502proc.gif">

<style type="text/css">

.duzy {
	font-family: Tahoma, Verdana, Arial;
	font-size: 24px;
	color: #000000;
	background-position: left;
	font-weight: bold;
}

.tekst {
	font-family: Tahoma, Verdana, Arial;
	font-size: 11px;
	color: #000000;
	background-position: left;
}

.tekst-wiekszy {
	font-family: Tahoma, Verdana, Arial;
	font-size: 14px;
	color: #000000;
	background-position: left;
	font-weight: bold;
	border-bottom-width: 1px;
	border-bottom-style: solid;
	border-bottom-color: #666666;
}

.tekst-wiekszy2 {
	font-family: Tahoma, Verdana, Arial;
	font-size: 16px;
	color: #0000a0;
	background-position: left;
	font-weight: bold;
}

.stopka {
	font-family: Tahoma, Verdana, Arial;
	font-size: 9px;
	color: #666666;
	text-decoration: none;
	background-position: center;}
 
</style>


</head>

<CENTER>
<p class="duzy"><u>MAD-PASCAL 1.6.3</u></p>
<p class="stopka">Tebe/Madteam (2020-01-04)

<HR>

<TABLE>
<TR><TD VALIGN=top>
<UL>

<tt>
<b><LI><A HREF="#wprow">WPROWADZENIE</A></b>
<UL>

<LI><A HREF="#mads">Wstêp</A>
<LI><A HREF="#komp">Kompilacja</A>

</UL>

<br />

<b><LI><A HREF="#sposob">SPOSÓB U¯YCIA</A></b>
<UL>
<LI><A HREF="#switches">Prze³±czniki kompilatora</A>
<LI><A HREF="#err">Kody wyj¶cia</A>
</UL>

<br />

<b><LI><A HREF="#ulib">BIBLIOTEKI</A></b>
<ul>

<LI><A HREF="..\library\doc\index.html">LIB</A>
<LI><A HREF="..\blibs\doc\index.html">BLIBS</A>

</ul>

<br  />

<b><LI><A HREF="#syntax">SK£ADNIA</A></b>
<UL>
<LI><A HREF="#kom">Komentarze</A>
<LI><A HREF="#resword">Zarezerwowane s³owa</A>

<LI><A HREF="#expres">Wyra¿enia</A>
<UL>
<LI><A HREF="#numbers">Liczby</A>
<LI><A HREF="#opers">Operatory</A>
</UL>

<LI><A HREF="#direc">Dyrektywy kompilatora</A>

<ul>
<LI><A HREF="#conditional">$DEFINE label</A>
<LI><A HREF="#resource">RESOURCE {$R filename}</A>
</ul>

</ul>

<br />

<b><LI><A HREF="#change">HISTORIA</A></b>
</UL>
</tt>

</TD>


<TD VALIGN=top>
<UL>
<tt>

<b><LI><A HREF="#const">CONSTANTS</A></b>
<UL>
<LI><A HREF="#c_ord">Ordinary constants</A>
</ul>
<br />

<b><LI><A HREF="#types">TYPES</A></b>
<UL>

<LI><A HREF="#t_ord">Ordinal types</A>
<LI><A HREF="#bool">Boolean types</A>
<LI><A HREF="#enum">Enumeration types</A>
<LI><A HREF="#real">Real types</A>
<LI><A HREF="#char">Character types</A>
<LI><A HREF="#pointers">Pointers</A>
<LI><A HREF="#arrays">Arrays</A>
<LI><A HREF="#records">Record types</A>
<LI><A HREF="#objects">Object types</A>
<LI><A HREF="#files">File types</A>

</ul>
<br />

<LI><A HREF="#war">Instrukcje warunkowe</A>
<LI><A HREF="#ite">Instrukcje iteracyjne</A>

<br />
<br />

<LI><A HREF="#proc">Procedury i funkcje</A>
<LI><A HREF="#mody">Modyfikatory procedur i funkcji</A>


<br />
<li><a href="#units">Units</a>

</UL>
</UL>
</TD></TR>
</TABLE>

</CENTER>

</tt>
<HR>


<tt>

<div align="justify">


<A NAME="wprow">
<p class="duzy">
WPROWADZENIE
</p>


<A NAME="mads">
<u><tt><h2>Wstêp</h2></tt></u>
<p>
<tt>Mad-Pascal (MP)</tt> jest 32-bitowym kompilatorem Turbo Pascala dla Atari XE/XL. W za³o¿eniu jest kompatybilny z Free Pascal Compilatorem (FPC) (prze³±cznik -MDelphi powinien byæ aktywny), co oznacza mo¿liwo¶æ otrzymanie kodu uruchomieniowego dla XE/XL, PC i ka¿dej innej platformy dla której istnieje FPC. MP nie jest portem FPC, zosta³ napisany na podstawie kompilatorów SUB-Pascal (2009), XD-Pascal (2010), których autorem jest Vasiliy Tereshkov (vtereshkov@mail.ru).
</p>

<p>
Program który zadzia³a na Atari mo¿e mieæ problem na PC je¶li np. nie zaincjowali¶my wska¼ników adresem zmiennej, bêdziemy próbowali zapisywaæ co¶ pod adresem $0000 (b³±d ochrony pamiêci). Mocn± stron± MP jest szybka i wygodna mo¿liwo¶æ do³±czania wstawek assemblerowych. Program z wstawkami ASM nie bêdzie dzia³a³ na innej platformie ni¿ XE/XL. MP wykorzystuje 64KB pamiêci podstawowej, korzystanie z pamiêci rozszerzonej udostêpnia TMemoryStream.
</p>
Alokacja zmiennych jest statyczna, nie ma dynamicznego zarz±dzania pamiêci±. Parametry przekazywane do funkcji i procedur s± przez warto¶æ, zmienn± lub sta³±.
<p>
Dostêpne s±:
</p>
<li>If, Case, For, While, Repeat statements.
<li>Compound statements.
<li>Label, Goto statements.
<li>Arithmetic and boolean operators.
<li>Procedures and functions with up to 8 parameters. Returned value of a function is assigned to a predefined RESULT variable.
<li>Static local variables.
<li>Primitive data types (all types except the ShortReal/Real type are compatible. Pointers are dereferenced as pointers to Word):
<ul>
<li>Cardinal, Word, Byte, Boolean
<li>Char, String, PChar
<li>Integer, SmallInt, ShortInt
<li>Pointer, File
<li>ShortReal, Real (fixed-point)
<li>Single (IEEE-754) [Float]
</ul>

<li>One-dimensional and Two-dimensional arrays (with zero lower bound) of any primitive type. Arrays are treated as pointers to their origins (like in C) and can be passed to subroutines as parameters.
<li>Predefined type string [N] which is equivalent to array [0..N] of Char.
<li>Type aliases.
<li>Records.
<li>Objects.
<li>Separate program modules.
<li>Recursion.

<p></p>


<li><a href="http://www.freepascal.org/docs-html/ref/ref.html#refch14.html">Free Pascal Reference Guide</a>
<li><a href="http://www.atari.org.pl/forum/viewtopic.php?id=13373">MadPascal AtariArea forum (PL)</a></li>
<li><a href="http://atariage.com/forums/topic/240919-mad-pascal/">MadPascal AtariAge forum (ENG)</a>
<li><a href="http://atariage.com/forums/topic/243658-mad-pascal-examples/">MadPascal examples</a>

<li><a href="https://atariwiki.org/wiki/Wiki.jsp?page=Pascal">Atari XE/XL Pascal Compilers</a>

<p></p>
<br />



<A NAME="komp">
<u><tt><h2>Kompilacja</h2></tt></u>
<p>
Aby skompilowaæ ¼ród³o <tt>Mad-Pascala</tt>, mo¿na u¿yæ kompilatora z <tt>Delphi</tt>, je¶li kto¶ ma akurat zainstalowane ¶rodowisko <tt>Delphi 7.0</tt> lub nowsze.
</p>

<p>
Innym sposobem, bardziej multi platformowym jest u¿ycie kompilatora z pakietu <tt><b>Free Pascal Compiler (FPC)</b></tt>, który mo¿na pobraæ ze strony <a href="http://www.freepascal.org/">http://www.freepascal.org/</a> 
</p>

Uruchamiamy instalator, wybieramy katalog w którym zostanie zainstalowany <tt>FP</tt>. Wa¿ne jest aby nie u¿ywaæ w nazwie katalogu znaku wykrzyknika <tt>'!'</tt> czy innych nie standardowych znaków. Je¶li nie uda nam siê skompilowaæ ¿adnego pliku, najpewniej winna jest nie standardowa nazwa ¶cie¿ki. Linia komend uruchamiaj±ca kompilacjê mo¿e wygl±daæ nastêpuj±co (wielko¶æ liter w nazwach parametrów ma znaczenie):

<pre>
fpc -Mdelphi -v -O3 mp.dpr

<li>-Mdelphi     pozwala kompilowaæ plik w formacie <tt>Delphi</tt>
<li>-v           wy¶wietla wszystkie komunikaty b³êdów i ostrze¿eñ
<li>-O3          dokonuje optymalizacji kodu
</pre>

<p></p>
<br />



<A NAME="sposob">
<p class="duzy">
SPOSÓB U¯YCIA
</p>

<A NAME="switches">
<u><tt><h2>Prze³±czniki kompilatora</h2></tt></u>

<span style="color: #0000FF">
<pre>
Syntax: mp source [switches]

-d:address      tryb diagnostyczny
-define:symbol  definiowanie symbolu
-ipath:&ltx&gt      dodatkowa ¶cie¿ka poszukiwañ
-code:$address  adres uruchomienia programu
-data:$address  adres pamiêci dla zmiennych, tablic
-stack:$address adres pamiêci dla stosu programowego (64 bajty)
-zpage:$address adres na stronie zerowej dla zmiennych (24 bajty)
</pre>
</span>


<p>
<div style="font-weight: bold"  style="font-size: 18px">-d</div>
<div align="justify">
U¿ycie prze³±cznika <b><tt>-d</tt></b> powoduje wygenerowanie dodatkowego pliku z informacj± o wszystkich u¿ytych zmiennych, procedurach, funkcjach.</p>


<p>
Domy¶lnym rozszerzeniem pliku wynikowego jest *.A65, plik taki assemblujemy z u¿yciem Mad-Assemblera (dodatkowo ustawiamy ¶cie¿kê poszukiwañ na -i:base), np.:
</p>
<span style="color: #0000FF">
<pre>
 mads source.a65 -x -i:base
</pre>
</span>

Prze³±cznik -x (Exclude unreferenced procedures) pozwoli wygenerowaæ najkrótszy kod wynikowy dla 6502.
<p></p>
<br />


<A NAME="err">
<u><tt><h2>Kody wyj¶cia</h2></tt></u>

<span style="color: #0000FF">
<pre>
3 = bad parameters, compiling not started
2 = error occured
0 = no errors
</pre>
</span>

Komunikaty ostrze¿enia nie powoduj± zmiany warto¶ci kodu wyj¶cia.
<p></p>
<br />



<A NAME="syntax">
<p class="duzy">
SK£ADNIA
</p>


<A NAME="kom">
<u><tt><h2>Komentarze</h2></tt></u>

<a href="http://www.freepascal.org/docs-html/ref/refse2.html">Comments</a>

<p>
W MP do oznaczenia komentarza jednoliniowego s³u¿± znaki <tt>'//'</tt>, dla wieloliniowego klamry <tt>{ }</tt>, lub <tt>(* *)</tt>.
</p>

<span style="color: #0000FF">
<pre>
 // to jest komentarz
 inc(a); // to jest komentarz
 
 (* komentarz *)
 
 (*

  komentarz
 
 *)

 { to 
   jest
   komentarz
 }
</pre>
</span>

<p></p>
<br />


<A NAME="resword">
<u><tt><h2>Zarezerwowane s³owa</h2></tt></u>

Zarezerwowane rozkazy:
<span style="color: #0000FF">
<pre>
absolute
and
array
asm
begin
case
const
div
do
downto
else
end
file
for
function
if
implementation
interface
main
mod
not
of
or
procedure
program
record
repeat
shl
shr
stack
string
then
to
type
unit
until
uses
var
while
xor
</pre>
</span>


Zarezerwowane sta³e:
<span style="color: #0000FF">
<pre>
pi
true
false
</pre>
</span>


<p></p>
<br />


<A NAME="expres">
<p class="duzy">
WYRA¯ENIA
</p>

<a href="http://www.freepascal.org/docs-html/ref/refch12.html">Expression</a>

<A NAME="numbers">

<u><tt><h2>Liczby</h2></tt></u>

<a href="http://www.freepascal.org/docs-html/ref/refse6.html">Numbers</a>

<p></p>

<li>zapis decymalny:
<pre>
 -100
 -2437325
 1743
</pre>

<li>zapis hexadecymalny:
<pre>
 $100
 $e430
 $000001
</pre>

<li>zapis binarny:
<pre>
 %0001001010
 %000000001
 %001000
</pre>

<li>zapis kodami ATASCII:
<pre>
 'a'
 'fds'
 'W'
 #65#32#65
 #$9b
</pre>

<p></p>
<br />




<A NAME="opers">
<u><tt><h2>Operatory</h2></tt></u>

<a href="http://www.freepascal.org/docs-html/ref/refsu41.html">Arithmetic operators</a>
<pre>
+   Addition
-   Subtraction
*   Multiplication
/   Division
DIV Integer division
MOD Remainder
</pre>

<a href="http://www.freepascal.org/docs-html/ref/refsu42.html">Logical operators</a>
<pre>
NOT Bitwise negation (unary)
AND Bitwise and
OR  Bitwise or
XOR Bitwise xor
SHL Bitwise shift to the left
SHR Bitwise shift to the right
</pre>

<a href="http://www.freepascal.org/docs-html/ref/refsu43.html">Boolean operators</a>
<pre>
NOT logical negation (unary)
AND logical and
OR  logical or
XOR logical xor
</pre>

<a href="http://www.freepascal.org/docs-html/ref/refsu46.html">Relational operators</a>
<pre>
=   Equal
&lt&gt  Not equal
&lt   Less than
&gt   Greater than
&lt=  Less than or equal
&gt=  Greater than or equal
</pre>

<p></p>
<br />


<A NAME="direc">

<p class="duzy">
DYREKTYWY KOMPILATORA
</p>

<a href="http://www.freepascal.org/docs-html/prog/progch1.html#x5-40001">Compiler directives</a>

<p>
Zapis dyrektyw kompilatora ma postaæ:
<ul>
<li>{$dyrektywa parametry}</li>
<li>{$lista_dyrektyw_prze³±cznikowych}</li>
</ul>

Dyrektywa stanowi komentarz, w którym pierwszy znak $ odró¿nia zwyk³y komentarz, od dyrektywy kompilatora.

<A NAME="conditional">

<tt><h2>CONDITIONAL {$IFDEF label}, {$IFNDEF label}, {$ELSE}, {$ENDIF}, {$DEFINE label}, {$UNDEF label}</h2></tt>

<a href="http://wiki.freepascal.org/Conditional_compilation">Conditional compilation</a>

<pre>
{$define test}

const
	{$ifdef test}
	a=1;
	{$else}
	a=2;
	{$endif}
</pre>
</span>

Z poziomu assemblera dostêp do zdefiniowanych etykiet $DEFINE mo¿liwy jest przez MAIN.@DEFINES.label

<tt><h2>FASTMUL {$F page}</h2></tt>

<a href="http://codebase64.org/doku.php?id=base:seriously_fast_multiplication">Seriously fast multiplication (8-bit and 16-bit)</a>

<span style="color: #0000FF">
<pre>
{$f $70}  // fastmul at $7000
</pre>
</span>
<p>

<p>
Alternatywne procedury szybkiego mno¿enia dla typu BYTE, SHORTINT, WORD, SMALLINT, SHORTREAL. Procedury zajmuj± 2KB i s± umieszczane od adresu PAGE*256.
</p>
<br />


<tt><h2>IOCHECK {$I+} {$I-}</h2></tt>
<a href="http://www.freepascal.org/docs-html/prog/progsu38.html#x45-440001.2.38">Input/Output checking</a>
<span style="color: #0000FF">
<pre>
{i+}  IOCHECK ON  default
{i-}  IOCHECK OFF
</pre>
</span>
<p>
Dla {$i+} w przypadku wyst±pienia b³êdów transmisji I/O (RESET, REWRITE, BLOCKREAD, BLOCKWRITE, CLOSE) wykonywany program zostaje zatrzymany,
generowany jest komunikat b³êdu 'ERROR xxx'. Wy³±czenie IOCHECK {$i-} przydaje siê gdy chcemy sprawdziæ istnienie pliku na dysku, np.:
</p>
<span style="color: #0000FF">
<pre>
function FileExists(name: TString): Boolean;
var f: file;
begin

  {$I-}     // io check off
  Assign (f, name);
  Reset (f);
  Result:=(IoResult<128) and (length(name)>0);
  Close (f);
  {$I+}     // io check 

end;
</pre>
</span>

W blokach PROCEDURE, FUNCTION dyrektywa IOCHECK jest zasiêgu lokalnego, po zakoñczeniu kompilacji takiego bloku przywracana jest warto¶æ IOCHECK która zosta³a
okre¶lona poza takim blokiem.

<p></p>
<br />

<tt><h2>{$INCLUDE %DATE%}</h2></tt>
<a href="https://www.freepascal.org/docs-html/prog/progsu41.html">Include DATE</a>
<p>
Dyrektywa do³±czenia tekstu z aktualn± dat± kompilacji.
</p>
<br />

<tt><h2>{$INCLUDE %TIME%}</h2></tt>
<a href="https://www.freepascal.org/docs-html/prog/progsu41.html">Include TIME</a>
<p>
Dyrektywa do³±czenia tekstu z aktualnym czasem kompilacji.
</p>
<br />


<tt><h2>INCLUDE {$I filename}, {$INCLUDE filename}</h2></tt>
<a href="https://www.freepascal.org/docs-html/prog/progsu40.html#x47-460001.2.40">Include file</a>
<p>
Dyrektywa do³±czenia tekstu zawartego w pliku.
</p>
<br />


<tt><h2>LIBRARY PATH {$LIBRARYPATH path1;path2;...}</h2></tt>
<a href="https://www.freepascal.org/docs-html/prog/progsu99.html">Specify library path</a>
<p>
Dyrektywa pozwalaj±ca wskazaæ dodatkowe ¶cie¿ki poszukiwañ dla bibliotek (unit).
</p>
<br />


<tt><h2>INFO {$INFO user_defined}</h2></tt>
<a href="https://www.freepascal.org/docs-html/prog/progsu35.html#x42-410001.2.35">Generate info message</a>
<p>
</p>
<br />

<tt><h2>WARNING {$WARNING user_defined}</h2></tt>
<a href="https://www.freepascal.org/docs-html/prog/progsu81.html#x88-870001.2.81">Generate warning message</a>
<p>
</p>
<br />

<tt><h2>ERROR {$ERROR user_defined}</h2></tt>
<a href="https://www.freepascal.org/docs-html/prog/progsu17.html#x24-230001.2.17">Generate error message</a>
<p>
</p>
<br />


<A NAME="resource">

<tt><h2>RESOURCE {$R filename}, {$RESOURCE filename}</h2></tt>
<a href="http://www.freepascal.org/docs-html/prog/progsu67.html#x74-730001.2.67">Include resource</a>
<p>
<h2>RCLABEL RCTYPE RCFILE [PAR0 PAR1 PAR2 PAR3 PAR4 PAR5 PAR6 PAR7]</h2>

Dyrektywa do³±czenia pliku z zasobami. Plik zasobów jest plikiem tekstowym, ka¿dy jego kolejny wiersz powinien sk³adaæ siê z trzech pól rozdzielonych "bia³ym znakiem": etykieta RCLABEL (jej deklaracja musi znale¼æ siê tak¿e w programie),
typ zasobów RCTYPE, lokalizacja pliku RCFILE. Aktualnie w pliku BASE\RES6502.ASM znajduj± siê makra do obs³ugi 10 typów zasobów RCTYPE:
<p></p>
 
<table border="1">
<tr>
	<td><tt><b>RCDATA</b></tt></td>
	<td><tt>dowolny typ danych</tt></td>
</tr>
<tr>
	<td><tt><b>RCASM</b></tt></td>
	<td><tt>plik w assemlerze, który zostanie do³±czony i zasemblowany</tt></td>
</tr>
<tr>
	<td><tt><b>DOSFILE</b></tt></td>
	<td><tt>plik z nag³ówkiem Atari DOS, adres ³adowania takiego pliku powiniem byæ identyczny jak <b>RCLABEL</b></tt></td>
</tr>
<tr>
	<td><tt><b>RELOC</b></tt></td>
	<td><tt>plik relokowalny w formacie MadAssemblera, plik zostanie poddany relokacji pod wskazany adres <b>RCLABEL</b></tt></td>
</tr>
<tr>
	<td><tt><b>RMT</b></tt></td>
	<td><tt>plik modu³u Raster Music Tracker-a, plik zostanie poddany relokacji pod wskazany adres <b>RCLABEL</b></tt></td>
</tr>
<tr>
	<td><tt><b>MPT</b></tt></td>
	<td><tt>plik modu³u Music ProTracker-a, plik zostanie poddany relokacji pod wskazany adres <b>RCLABEL</b></tt></td>
</tr>
<tr>
	<td><tt><b>CMC</b></tt></td>
	<td><tt>plik modu³u Chaos Music Composer-a, plik zostanie poddany relokacji pod wskazany adres <b>RCLABEL</b></tt></td>
</tr>
<tr>
	<td><tt><b>RMTPLAY</b></tt></td>
	<td><tt>player dla modu³u RMT, jako <b>RCFILE</b> podajemy plik *.FEAT oraz dodatkowo <b>PAR0</b> tryb playera 0..3</tt>

<pre>	
0 => compile RMTplayer for 4 tracks mono
1 => compile RMTplayer for 8 tracks stereo
2 => compile RMTplayer for 4 tracks stereo L1 R2 R3 L4
3 => compile RMTplayer for 4 tracks stereo L1 L2 R3 R4	
</pre>
	
	</td>
</tr>
<tr>
	<td><tt><b>MPTPLAY</b></tt></td>
	<td><tt>player dla modu³u MPT</tt></td>
</tr>
<tr>
	<td><tt><b>CMCPLAY</b></tt></td>
	<td><tt>player dla modu³u CMC</tt></td>
</tr>
<tr>
	<td><tt><b>XBMP</b></tt></td>
	<td><tt>plik Windows Bitmap (8 BitsPerPixel) ³adowany do pamiêci VBXE pod wskazany adres <b>RCLABEL</b> od indeksu koloru <b>PAR0</b> w palecie kolorów VBXE nr 1</tt></td>
</tr>
</table> 
 
 
<pre>
Przyk³ad:

bmp1  RCDATA   'pic.mic'

msx   MPT      'porazka.mpt'

play  RMTPLAY   'modul.feat' 1

bmp   XBMP     'pic.bmp' 80
</pre>

<p></p>
<br />



<A NAME="const">
<A NAME="c_ord">

<p class="duzy">
CONSTANTS
</p>

<a href="http://www.freepascal.org/docs-html/ref/refse9.html">Ordinary constants</a>

<p>
Do deklaracji sta³ych CONST s³u¿y znak '='. Dopuszczalne jest u¿ycie operatorów +, -, *, /, not, and, or, div, mod, ord, chr, sizeof, pi</p>

<span style="color: #0000ff">
<pre>
Const  
  e = 2.7182818;       { Real type constant }
  f : single = 3.14;   { Single type constant }
  a = 2;               { Ordinal BYTE type constant }
  c = '4';             { Character type constant }
  s = 'atari';         { String type constant } 
  sc = chr(32);
  ls = SizeOf(cardinal);  

  x: word = 5;         { wymuszenie typu sta³ej }	
</pre>
</span>

<p></p>
<br />



<A NAME="types">
<p class="duzy">
TYPES
</p>


<A NAME="t_ord">
<u><tt><h2>Typy porz±dkowe</h2></tt></u>

<a href="https://pl.wikibooks.org/wiki/Object_Pascal/Typy_zmiennych#Porz.C4.85dkowy">Typ porz±dkowy</a>

<br />

<a href="http://www.freepascal.org/docs-html/ref/refsu4.html#x26-250003.1.1">Ordinal types</a>

<p></p>

<table border="0" class="tekst">
<tr>
	<td>Type</td>
	<td>Range</td>
	<td>Size in bytes</td>
</tr>
<tr>
	<td><hr /></td>
	<td><hr /></td>
	<td><hr /></td>
</tr>
<tr>
	<td>BYTE</td>
	<td>0 .. 255</td>
	<td ALIGN=CENTER>1</td>
</tr>
<tr>
	<td>SHORTINT</td>
	<td>-128 .. 127</td>
	<td ALIGN=CENTER>1</td>
</tr>
<tr>
	<td>WORD</td>
	<td>0 .. 65535</td>
	<td ALIGN=CENTER>2</td>
</tr>
<tr>
	<td>SMALLINT</td>
	<td>-32768 .. 32767</td>
	<td ALIGN=CENTER>2</td>
</tr>
<tr>
	<td>CARDINAL</td>
	<td>0 .. 4294967295</td>
	<td ALIGN=CENTER>4</td>
</tr>

<tr>
	<td>LONGWORD</td>
	<td>0 .. 4294967295</td>
	<td ALIGN=CENTER>4</td>
</tr>

<tr>
	<td>DWORD</td>
	<td>0 .. 4294967295</td>
	<td ALIGN=CENTER>4</td>
</tr>

<tr>
	<td>UINT32</td>
	<td>0 .. 4294967295</td>
	<td ALIGN=CENTER>4</td>
</tr>

<tr>
	<td>INTEGER</td>
	<td>-2147483648 .. 2147483647</td>
	<td ALIGN=CENTER>4</td>
</tr>

<tr>
	<td>LONGINT</td>
	<td>-2147483648 .. 2147483647</td>
	<td ALIGN=CENTER>4</td>
</tr>

</table>


<A NAME="bool">
<u><tt><h2>Typy logiczne</h2></tt></u>

<a href="http://www.freepascal.org/docs-html/ref/refsu4.html#x26-270003.1.1">Boolean types</a>

<p></p>

<table border="0" class="tekst">
<tr>
	<td>Name</td>
	<td>Size</td>
	<td>Ord(True)</td>
</tr>

<tr>
	<td><hr /></td>
	<td><hr /></td>
	<td><hr /></td>
</tr>

<tr>
	<td>BOOLEAN</td>
	<td ALIGN=CENTER>1</td>
	<td ALIGN=CENTER>1</td>
</tr>
</table>



<A NAME="enum">
<u><tt><h2>Typy wyliczeniowe</h2></tt></u>

<a href="http://www.freepascal.org/docs-html/ref/refsu4.html#x26-280003.1.1">Enumeration types</a>

<p>
Typ wyliczeniowy w MP zosta³ zaimplementowany w podstawowej postaci, tzn.:
</p>

<span style="color: #0000FF">
<pre>
Type  
  Days = (monday,tuesday,wednesday,thursday,friday,  
          saturday,sunday);

  Joy = (right_down = 5, right_up, right, left_down = 9, left_up, left, down = 13, up, none);
</pre>
</span>

<p>
Typ wyliczeniowy przechowywany jest tylko w pamiêci kompilatora MP, do pliku wynikowego nie zostan± zapisane jakiekolwiek informacje dotycz±ce pól typu wyliczeniowego. Dopuszczalne jest u¿ycie komendy
ORD, SIZEOF oraz rzutowania dla typu wyliczeniowego. 
</p>

<span style="color: #0000FF">
<pre>
var
   d: Days;
	
   d:=friday;
   writeln(ord(d));
   writeln(ord(sunday));
   writeln(sizeof(days));
   writeln(sizeof(monday));
   
   d:=days(20);
   
   case d of
    sunday: writeln('sunday');
   end;   
</pre>
</span>


<p>
Aktualnie kompilator MP nie sprawdzi poprawno¶ci typów wyliczeniowych dla operacji IF ELSE.
</p>

<p></p>
<br />



<A NAME="real">
<u><tt><h2>Typy rzeczywiste</h2></tt></u>

<a href="http://www.freepascal.org/docs-html/ref/refsu5.html#x27-300003.1.2">Real types</a>

<p></p>

<table border="0" class="tekst">
<tr>
	<td>Type</td>
	<td>Range</td>
	<td>Size in bytes</td>
</tr>

<tr>
	<td><hr /></td>
	<td><hr /></td>
	<td><hr /></td>
</tr>

<tr>
	<td>SHORTREAL (Q8.8)</td>
	<td>-128..127</td>
	<td ALIGN=CENTER>2</td>
</tr>

<tr>
	<td>REAL (Q24.8)</td>
	<td>-8388607..8388608</td>
	<td ALIGN=CENTER>4</td>
</tr>

<tr>
	<td>SINGLE (IEEE-754)</td>
	<td>1.5E-45 .. 3.4E38</td>
	<td ALIGN=CENTER>4</td>
</tr>

<tr>
	<td>FLOAT (IEEE-754)</td>
	<td>1.5E-45 .. 3.4E38</td>
	<td ALIGN=CENTER>4</td>
</tr>

</table>

<p></p>

Konwersja typu FLOAT / SINGLE do liczby ca³kowitej dostêpna jest tylko w zakresie INTEGER. Typ INTEGER nie pozwoli zaprezentowaæ maksymalnej warto¶ci 3.4E38 typu FLOAT / SINGLE.

<p></p>


<p></p>
<br />


<A NAME="char">
<u><tt><h2>Typy znakowe</h2></tt></u>

<a href="http://www.freepascal.org/docs-html/ref/refsu6.html#x29-320003.2.1">Char</a>
<br />
<a href="http://www.freepascal.org/docs-html/ref/refsu9.html#x32-350003.2.4">Short strings</a>

<p></p>

<table border="0" class="tekst">
<tr>
	<td>Type</td>
	<td>Range</td>
	<td>Size in bytes</td>
</tr>

<tr>
	<td><hr /></td>
	<td><hr /></td>
	<td><hr /></td>
</tr>

<tr>
	<td>CHAR</td>
	<td>ATASCII (0 .. 255)</td>
	<td ALIGN=CENTER>1</td>
</tr>

<tr>
	<td>STRING</td>
	<td>1 .. 255</td>
	<td ALIGN=CENTER>256</td>
</tr>

<tr>
	<td>PCHAR</td>
	<td>0 .. 65535</td>
	<td ALIGN=CENTER>2</td>
</tr>

</table>

<p>
Ci±g znaków STRING reprezentowany jest jako tablica o mo¿liwym maksymalnym rozmiarze [0..255]. Pierwszym bajtem takiej tablicy [0] jest d³ugo¶æ ci±gu z zakresu 0..255. Od bajtu [1..] zaczyna siê w³a¶ciwy ci±g znaków.
</p>

<p>
Ci±g znaków PCHAR reprezentowany jest przez wska¼nik do typu CHAR. Znakiem koñca ci±gu PCHAR jest znak #0.
</p>

<p>
Dopuszczalne jest u¿ycie dodatkowych znaków po koñcowym apostrofie, takich jak '*', '~'. Znak '*' oznacza ci±g w inwersie, tylda '~' ci±g w kodach ANTIC-a.
</p>

<p>
Innym sposobem modyfikacji wyprowadzanych znaków jest u¿ycie systemowej zmiennej TextAttr, ka¿dy znak wyprowadzany na ekran jest zwiêkszany o warto¶æ TextAttr (domy¶lnie = 0).
</p>

<span style="color: #0000FF">
<pre>
 a: string = 'Atari'*;         // ci±g znaków w inwersie
 b: string = 'Spectrum'~;      // ci±g znaków w kodach ANTIC-a
 c: char = 'X'~*;              // znak w inwersie, kodach ANTIC-a
</pre>
</span>


<p></p>
<br />



<A NAME="pointers">
<u><tt><h2>Wska¼niki</h2></tt></u>

<a href="http://www.freepascal.org/docs-html/ref/refse15.html">Pointers</a>

<p></p>

<table border="0" class="tekst">
<tr>
	<td>Type</td>
	<td>Range</td>
	<td>Size in bytes</td>
</tr>

<tr>
	<td><hr /></td>
	<td><hr /></td>
	<td><hr /></td>
</tr>

<tr>
	<td>POINTER</td>
	<td>0 .. 65535</td>
	<td ALIGN=CENTER>2</td>
</tr>
</table>

<p>
Wska¼niki w MP mog± byæ typowane i bez okre¶lonego typu, np.:
</p>

<span style="color: #0000FF">
<pre>
 a: ^word;         // wska¼nik typowany na s³owo
 b: pointer;       // wska¼nik bez typu
</pre>
</span>

<p>
Niezaincjowany wska¼nik najczê¶ciej bêdzie mia³ adres $0000, nale¿y zadbaæ aby przed jego wykorzystaniem zaincjowaæ go adresem odpowiedniej zmiennej, np.:
</p>

<span style="color: #0000FF">
<pre>
 a := @tmp;         // wska¼nikowi A zostaje przypisany adres zmiennej TMP
</pre>
</span>

<p>
Je¶li tego nie zrobimy to w przypadku uruchomienia takiego programu na PC spowodujemy b³±d ochrony pamiêci 'Access Violation'.
</p>
Zwiêkszanie wska¼nika przez INC zwiêkszy go o rozmiar typu na jaki wskazuje. Zmniejszenie wska¼nika przez DEC zmniejszy go o rozmiar typu na jaki wskazuje.
Je¶li typ jest nieokre¶lony, wówczas domy¶ln± warto¶ci± zwiêkszania/zmniejszanie bêdzie 1.

<p></p>
<br />



<A NAME="arrays">
<u><tt><h2>Tablice</h2></tt></u>

</p>
<a href="http://www.freepascal.org/docs-html/ref/refsu14.html#x38-500003.3.1">Static Arrays</a>


<p>
Tablice w MP s± tylko statyczne, jednowymiarowe lub dwuwymiarowe z pocz±tkowym indeksem =0, np.:
</p>

<span style="color: #0000FF">
<pre>
var tb: array [0..100] of word;
var tb2: array [0..15, 0..31] of Boolean;
</pre>
</span>

<p>
W przypadku pocz±tkowego indeksu innego ni¿ zero zostanie wygenerowany b³±d <tt>'Error: Array lower bound is not zero'</tt>.
</p>

W pamiêci tablica reprezentowana jest przez wska¼nik (POINTER), wska¼nik jest adresem tablicy w pamiêci (WORD). Najszybsz± metod± odwo³ania siê do tablicy z poziomu assemblera jest zastosowanie przedrostka 'ADR.', np.:

<span style="color: #885500">
<pre>
asm
{ lda adr.tb,y   ; bezpo¶rednie odwo³anie do tablicy TB
  lda tb         ; odwo³anie do wska¼nika tablicy TB
};
</pre>
</span>

<p>
Kompilator generuje kod dla tablic zale¿nie od ich deklaracji:
</p>

<table border="1">
<tr>
	<td><tt><b>array [0..255] of byte<br />array [0..127] of word<br />array [0..63] of cardinal</b></tt></td>
	<td><tt>Gdy liczba bajtów zajmowanych przez tablicê nie przekracza 256 bajtów generowany jest najszybszy kod odwo³uj±cy siê bezpo¶rednio do adresu tablicy (przedrostek ADR.) z pominiêciem wska¼nika. Dla takiej tablicy nie ma mo¿liwo¶ci zmiany adresu.</tt>
	
<span style="color: #0000FF">
<pre>
 ldy #118
 lda adr.tb,y
</pre>
</span>	

</td>	
	
</tr>
<tr>
	<td><tt><b>array [0..0] of type</b></tt></td>
	<td><tt>Gdy liczba elementów tablicy wynosi '1' jest ona traktowana specjalnie. Generowany kod odwo³uje siê do tablicy poprzez wzka¼nik. Istnieje mo¿liwo¶æ ustalenia nowego adresu takiej tablicy.</tt>
	
<span style="color: #0000FF">
<pre>
 lda TB
 add I
 tay
 lda TB+1
 adc #$00
 sta bp+1
 lda (bp),y
</pre>
</span>	
	
	
	</td>
</tr>
<tr>
	<td><tt><b>array [0..255+1] of byte<br />array [0..127+1] of word<br />array [0..63+1] of cardinal</b></tt></td>
	<td><tt>Gdy liczba bajtów zajmowanych przez tablicê przekracza 256 bajtów generowany kod odwo³uje siê do tablicy poprzez wska¼nik. Istnieje mo¿liwo¶æ ustalenia nowego adresu takiej tablicy.</tt>
	
<span style="color: #0000FF">
<pre>
 lda TB
 add I
 tay
 lda TB+1
 adc #$00
 sta bp+1
 lda (bp),y
</pre>
</span>	

	</td>
</tr>
</table>

<p></p>
<br />



<A NAME="records">
<u><tt><h2>Rekordy</h2></tt></u>

</p>
<a href="http://www.freepascal.org/docs-html/ref/refsu15.html#x39-550003.3.2">Record types</a>

<p>
W pamiêci rekord reprezentowany jest przez wska¼nik (POINTER).

<span style="color: #0000FF">
<pre>
type
    TPoint = record x,y: byte end;

var px: TPoint;
</pre>
</span>

Domy¶lnie rekordy w MP s± typu <b>PACKED</b>. 

<p>
Je¶li zale¿y nam na zachowania kompatybilno¶ci z FPC nale¿y dodatkowo poprzedziæ s³owo 'record' s³owem 'packed'.
<br />

Bez tego rozmiar pamiêci jaki zajmuje rekord bêdzie móg³ siê ró¿niæ, bêzie mniej zajmowa³ pamiêci na Atari XE/XL, potencjalnie wiêcej o kilka bajtów na PC.
</p>

<span style="color: #0000FF">
<pre>
type
    TPoint = packed record x,y: byte end;

var px: TPoint;
</pre>
</span>


Dostêp do pól rekordu z poziomu asm:

<span style="color: #0000FF">
<pre>
 mwa px bp2
 ldy #px.x-DATAORIGIN
 lda (bp2),y
</pre>
</span>	

<p></p>
<br />



<A NAME="objects">
<u><tt><h2>Obiekty</h2></tt></u>

</p>
<a href="https://www.freepascal.org/docs-html/ref/refse28.html#x60-780005.1">Objects types</a>

<p>
Obiekty to rekordy z dodatkowymi metodami. W pamiêci obiekt reprezentowany jest przez wska¼nik (POINTER). 

<span style="color: #0000FF">
<pre>
type
	TRMT = Object

	player: pointer;
	modul: pointer;

	procedure Init(a: byte); assembler;
	procedure Play; assembler;
	procedure Stop; assembler;

	end;
</pre>
</span>


<p></p>
<br />



<A NAME="files">
<u><tt><h2>Pliki</h2></tt></u>

</p>
<a href="http://www.freepascal.org/docs-html/ref/refsu17.html#x41-590003.3.4">File types</a>

<p>
Typ FILE reprezentuje uchwyt do pliku oraz definiuje rozmiar rekordu.
</p>

<span style="color: #0000FF">
<pre>
type
 ftype = array [0..63] of cardinal;

var f: file;               // rekord domy¶lny =128 bajtów
    f: file of byte;       // rekord 1 bajt
    f: file of ftype;      // rekord 256 bajtów (ftype = 64 * 4)   
</pre>
</span>


W pamiêci XE/XL uchwyt FILE reprezentowany jest przez wska¼nik (POINTER) do tablicy o strukturze (rozmiar 12 bajtów):

<span style="color: #885500">
<pre>
.struct	s@file
pfname   .word		; pointer to string with filename
record   .word		; record size
chanel   .byte		; channel *$10
eof      .byte		; EOF status
buffer   .word		; load/write buffer
nrecord  .word		; number of records for load/write
numread  .word		; pointer to variable, length of loaded data
.ends
</pre>
</span>

<p>
Do procedur, funkcji typ FILE mo¿e byæ przekazywany tylko jako zmienna (VAR).
</p>

<p></p>
<br />



<A NAME="war">
<p class="duzy">
INSTRUKCJE WARUNKOWE
</p>

<u><tt><h2>CASE OF ELSE</h2></tt></u>

<a href="http://www.freepascal.org/docs-html/ref/refsu57.html">The Case statement</a>

<p>Obecnie Mad Pascal akceptuje dla zmiennej CASE typy tylko o d³ugo¶ci 1 bajta: SHORTINT, BYTE, CHAR, BOOLEAN</p>

<span style="color: #885500">
<pre>
 case a of             // dla zmiennej A typu CHAR
  'A'..'Z': begin end;
  '0'..'9': begin end;
   '+','*': begin end;
 end;
</pre>
</span>

<p></p>
<br />


<u><tt><h2>IF THEN ELSE</h2></tt></u>

<a href="http://www.freepascal.org/docs-html/ref/refsu58.html">The If..then..else statement</a>

<p>
Instrukcje warunkowe IF mog± byæ zagnie¿d¿ane. Wykorzystywane jest to przy budowie bardziej z³o¿onych warunków. 
</p>

<p></p>
<br />



<A NAME="ite">
<p class="duzy">
INSTRUKCJE ITERACYJNE
</p>

<u><tt><h2>FOR TO DOWNTO DO</h2></tt></u>
<a href="http://www.freepascal.org/docs-html/ref/refsu59.html">The For..to/downto..do statement</a>

<pre>
FOR zmienna := { warto¶æ pocz±tkowa } TO { warto¶æ koñcowa } DO { instrukcje do wykonania }
FOR zmienna := { warto¶æ koñcowa } DOWNTO { warto¶æ pocz±tkowa } DO { instrukcje do wykonania }
</pre>

Instrukcja ta s³u¿y do organizacji obliczeñ, które bêd± wykonywane z góry okre¶lon± liczbê razy. Zmienna steruj±ca musi byæ identyfikatorem typu porz±dkowego, a oba wyra¿enia powinny byæ zgodne w sensie przypisania z typem zmiennej steruj±cej. W czasie realizacji pêtli TO zmiennej steruj±cej przypisywana jest nastêpna warto¶æ w danym typie, w pêtli DOWNTO poprzednia. Zabroniona jest "rêczna" zmiana warto¶ci zmiennej steruj±cej. W przypadku takiej próby  MP nie zasygnalizuje b³êdu.
<p>

Kompilator dba o to aby nie wyst±pi³a pêtla bez koñca, dlatego mo¿na bez obaw stosowaæ tak± pêtlê:

<span style="color: #885500">
<pre>
 for i:=0 to 255 do writeln(i);    // dla zmiennej I typu BYTE
</pre>
</span>

<p></p>
<br />



<u><tt><h2>WHILE DO</h2></tt></u>
<a href="http://www.freepascal.org/docs-html/ref/refsu62.html">The While..do statement</a>

<pre>
while { warunek } do
{ instrukcja do wykonania }
</pre>

Konstrukcja ta s³u¿y do organizacji obliczeñ, które bêd± wykonywane tak d³ugo jak wyra¿enie znajduj±ce siê po s³owie WHILE jest prawd±. Tak skonstruowana pêtla mo¿e nie zostaæ wykonana ani razu. 

<span style="color: #885500">
<pre>
 while BlitterBusy do;   // oczekiwanie na zakoñczenie dzia³ania blittera VBXE
</pre>
</span>

<p></p>
Ograniczenia dla instrukcji WHILE:
<span style="color: #885500">
<pre>
 while i<=255 do inc(i); // pêtla bez koñca gdy zmienna I typu BYTE
</pre>
</span>


<p></p>
<br />



<u><tt><h2>REPEAT UNTIL</h2></tt></u>
<a href="http://www.freepascal.org/docs-html/ref/refsu61.html">The Repeat..until statement</a>

<pre>
repeat
  { instrukcje do wykonania }
until { warunek zakoñczenia }
</pre>

Instrukcja ta wykonuje cyklicznie inne instrukcje zawarte pomiêdzy s³owami REPEAT i UNTIL do momentu gdy wyra¿enie znajduj±ce siê za s³owem UNTIL nie przyjmie warto¶ci PRAWDA (czyli TRUE). 

<p>
Efekt zastosowania pêtli REPEAT jest bardzo podobny do dzia³ania pêtli WHILE. Pêtla ta tak¿e mo¿e byæ wykonywana ogromn± liczbê razy. Jedyna ró¿nica polega na tym, ¿e w pêtli REPEAT warunek zakoñczenia sprawdzany jest dopiero po wykonaniu instrukcji. Oznacza to, ¿e pêtla REPEAT zawsze bêdzie wykonana co najmniej raz. Dopiero po tej iteracji program sprawdzi, czy mo¿na zakoñczyæ dzia³anie pêtli. W przypadku pêtli WHILE warunek jest sprawdzany bezpo¶rednio przed jej wykonaniem, co w rezultacie mo¿e spowodowaæ, ¿e taka pêtla nigdy niezostanie wykonana.
</p>

<span style="color: #885500">
<pre>
 i:=0;
 repeat
 inc(i);
 until i=0;		 // pêtla wykona siê 256 razy
</pre>
</span>
 

<p></p>
<br />



<A NAME="proc">
<p class="duzy">
PROCEDURY I FUNKCJE
</p>

<u><tt><h2>Procedure</h2></tt></u>

<a href="http://www.freepascal.org/docs-html/ref/refse87.html">Procedure declaration</a>

<p>
MP pozwala na przekazanie do procedury maksymalnie 8 parametrów. S± dostêpne trzy sposoby przekazywania parametrów - przez warto¶æ, sta³± (CONST) i zmienn± (VAR). Mo¿liwe jest u¿ycie modyfikatora OVERLOAD w celu przeci±¿enia procedur.
</p>

Dostêpne <a href="#mody">modyfikatory</a> procedur: OVERLOAD, ASSEMBLER, FORWARD, REGISTER, INTERRUPT.
<p>
Mo¿liwa jest rekurencja procedur, pod warunkiem ¿e parametry procedury bêd± przekazywane przez warto¶æ, bêd± typu <a href="#t_ord">prostego - porz±dkowego</a>. Typ rekordowy, wska¼nikowy nie bêdzie w³a¶ciwie alokowany w pamiêci.
</p>
<p></p>
<br />


<u><tt><h2>Function</h2></tt></u>

<a href="http://www.freepascal.org/docs-html/ref/refse88.html">Function declaration</a>

<p>
MP pozwala na przekazanie do funkcji maksymalnie 8 parametrów. S± dostêpne trzy sposoby przekazywania parametrów - przez warto¶æ, sta³± (CONST) i zmienn± (VAR). Wynik funkcji zwracamy przypisuj±c go do nazwy funkcji lub korzystaj±c z automatycznie deklarowanej zmiennej RESULT, np.:
</p>

<span style="color: #0000FF">
<pre>
function add(a,b: word): cardinal;
begin

 Result := a+b;

end;


function mul(a,b: word): cardinal;
begin

 mul := a*b;

end;
</pre>
</span>

Dostêpne <a href="#mody">modyfikatory</a> funkcji: OVERLOAD, ASSEMBLER, FORWARD, REGISTER, INTERRUPT (nie zalecane dla funkcji).

<p>
Mo¿liwa jest rekurencja funkcji, pod warunkiem ¿e parametry funkcji bêd± przekazywane przez warto¶æ, bêd± typu <a href="#t_ord">prostego - porz±dkowego</a>. Typ rekordowy, wska¼nikowy nie bêdzie w³a¶ciwie alokowany w pamiêci.
</p>

<p></p>
<br />




<A NAME="mody">
<p class="duzy">
MODYFIKATORY PROCEDUR I FUNKCJI
</p>

<A NAME="asm">
<u><tt><h2>ASSEMBLER</h2></tt></u>

Procedury/Funkcje oznaczona przez ASSEMBLER mog± sk³adaæ siê tylko z bloku ASM. Kompilator nie dokonuje analizy sk³adni takich bloków, traktuje je jak komentarz,
ewentualne b³êdy zostan± wychwycone dopiero podczas asemblacji.

<span style="color: #0000FF">
<pre>
procedure color(a: byte); assembler;
asm
{	mva a 712
};
end;
</pre>
</span>


<A NAME="ovr">
<u><tt><h2>OVERLOAD</h2></tt></u>

Procedury/Funkcje przeci±¿one rozpoznawane s± na podstawie listy parametrów.

<span style="color: #0000FF">
<pre>
procedure suma(var i: integer; a,b: integer); overload;
begin
 i := a+b;
end;

procedure suma(var i: integer; a,b,c: integer); overload;
begin
 i := a+b+c;
end;

function fsuma(a,b: word): cardinal; assembler; overload;
asm
{
 adw a b result
};
end;

function fsuma(a,b: real): real; overload;
begin
 Result := a+b;
end;
</pre>
</span>


<A NAME="for">
<u><tt><h2>FORWARD</h2></tt></u>

Je¿eli chcemy aby procedura/funkcja by³a zadeklarowana za miejscem jej pierwszego wywo³ania, nale¿y u¿yæ modyfikator FORWARD.

<span style="color: #0000FF">
<pre>
procedure nazwa [(lista-parametrów-formalnych)]; forward;

...
...
...

procedure nazwa;
begin
end;
</pre>
</span>


<A NAME="reg">
<u><tt><h2>REGISTER</h2></tt></u>

U¿ycie modyfikatora REGISTER spowoduje ¿e trzy pierwsze parametry formalne procedury/funkcji bêd± umieszczone na stronie zerowej, w 32-bitowych rejestrach programowych, odpowiednio EDX, ECX, EAX.

<span style="color: #0000FF">
<pre>
procedure nazwa (a,b,c: cardinal); register;

// a = edx
// b = ecx
// c = eax
</pre>
</span>

<A NAME="int">
<u><tt><h2>INTERRUPT</h2></tt></u>

Procedury/Funkcje oznaczone przez INTERRUPT kompilator bêdzie koñczy³ 
rozkazem RTI (standardowo RTS). Niezale¿nie czy w programie wyst±pi wywo³anie takiej procedury/funkcji kompilator zawsze wygeneruje dla niej kod.

Zaleca siê u¿ywanie bloku ASM w przypadku takich procedur/funkcji, w innym przypadku stos programowy Mad Pascala zostanie zniszczony, co
mo¿e doprowadziæ do niestabilnego dzia³ania programu, ³±cznie z zawieszeniem siê komputera. Na wej¶ciu procedury/funkcji oznaczonej przez INTERRUPT programista musi
zadbaæ o zachowanie rejestrów CPU (A, X, Y), na wyj¶ciu o przywrócenie stanu takich rejestrów, kompilator ogranicza siê tylko do wstawienia koñcowego rozkazu RTI.

<span style="color: #0000FF">
<pre>
procedure dli; interrupt;
asm
{	pha

	lda #$c8
	sta wsync
	sta $d01a

	pla 
};
end;             // rozkaz RTI zostanie wstawiony automatycznie
</pre>
</span>


<p></p>
<br />



<A NAME="units">
<p class="duzy">
UNITS
</p>

<a href="http://www.freepascal.org/docs-html/ref/refse106.html#x216-23800016.2">Units</a>
<br />
<a href="https://pl.wikipedia.org/wiki/Modu%C5%82_(informatyka)">Modu³y</a>

<p></p>

Modu³y (UNIT) w MP sk³adaj± siê z sekcji INTERFACE (wymagany), IMPLEMENTATION (wymagany), INITIALIZATION (opcjonalny).


<span style="color: #0000FF">
<pre>
unit test;

interface

type	TUInt24 =
	record
		byte0: byte;
		byte1: byte;
		byte2: byte;
	end;

const
	LoRes = 1;
	MedRes = 2;
	HiRes = 3;

	procedure Print(a: string);

implementation

uses test2;

procedure Print(a: string);
begin

 writeln(a);

end;

end.
</pre>
</span>


<br />
<p></p>


<A NAME="ulib">
<p class="duzy">
BIBLIOTEKA PODSTAWOWA
</p>

W katalogu 'LIB' Mad-Pascala znajduj± siê potrzebne do kompilacji podstawowe modu³y (unit), takie jak SYSTEM, CRT, GRAPH, SYSUTILS, MATH, DOS. W programie wybierane s± przez instrukcjê USES, np.:

<span style="color: #0000ff">
<pre>
uses crt, sysutils;
</pre>
</span>

Modu³ SYSTEM jest domy¶lnie dopisywany do listy USES i kompilowany jako pierwszy.


<A NAME="u_system">
<u><tt><h2>SYSTEM</h2></tt></u>

<a href="http://www.freepascal.org/docs-html/rtl/system/index-5.html">Reference for unit 'System': Procedures and functions</a>


<p class="tekst-wiekszy2">[ Constants ]</p>

<pre>
M_PI_2           = 6.283285;  // pi * 2
D_PI_2           = 1.570796;  // pi / 2
D_PI_180         = 0.017453;  // pi / 180

mGTIA            = 0;
mVBXE            = $80;
WINDOW           = $10;
NARROW           = $20;


VBXE_XDLADR      = $0000;     // XDLIST
VBXE_MAPADR      = $1000;     // COLOR MAP ADDRESS
VBXE_BCBADR      = $0100;     // BLITTER LIST ADDRESS
VBXE_OVRADR      = $5000;     // OVERLAY ADDRESS
VBXE_WINDOW      = $B000;     // 4K WINDOW $B000..$BFFF

iDLI             = 0;
iVBL             = 1;

CH_DELCHR        = $FE;
CH_ENTER         = $9B;
CH_ESC           = $1B;
CH_CURS_UP       = 28;
CH_CURS_DOWN     = 29;
CH_CURS_LEFT     = 30;
CH_CURS_RIGHT    = 31;

CH_TAB           = $7F;
CH_EOL           = $9B;
CH_CLR           = $7D;
CH_BEL           = $FD;
CH_DEL           = $7E;
CH_DELLINE       = $9C;
CH_INSLINE       = $9D;

COLOR_BLACK      = $00;
COLOR_WHITE      = $0e;
COLOR_RED        = $32;
COLOR_CYAN       = $96;
COLOR_VIOLET     = $68;
COLOR_GREEN      = $c4;
COLOR_BLUE       = $74;
COLOR_YELLOW     = $ee;
COLOR_ORANGE     = $4a;
COLOR_BROWN      = $e4;
COLOR_LIGHTRED   = $3c;
COLOR_GRAY1      = $04;
COLOR_GRAY2      = $06;
COLOR_GRAY3      = $0a;
COLOR_LIGHTGREEN = $cc;
COLOR_LIGHTBLUE  = $7c;
</pre>

<p class="tekst-wiekszy2">[ Types ]</p>

<table border="1">
 
<tr>
	<td><b><tt>TPoint</b></td>
	<td><tt>
  <b><tt>TPoint = record x,y: SmallInt end;;</b></tt>
  <p>Definicja wspó³rzêdnych (x,y).</p>
	</td>
</tr>

<tr>
	<td><b><tt>TRect</b></td>
	<td><tt>
  <b><tt>TRect = record left, top, right, bottom: smallint end;</b></tt>
  <p>Definicja po³o¿enia i rozmiaru czworok±ta o parametrach (left, top) - lewy górny naro¿nik, (right, bottom) - prawy dolny naro¿nik.</p>
	</td>
</tr>

<tr>
	<td><b><tt>TString</b></td>
	<td><tt>
  <b><tt>TString = string[32];</b></tt>
  <p>Definicja krótkiego ci±gu znakowego wykorzystywanego do przekazywania nazw plików itp.</p>
	</td>
</tr>


</table>


<p class="tekst-wiekszy2">[ Variables ]</p>

<table border="1">
 
<tr>
	<td><b><tt>IOResult</b></td>
	<td><tt>
  <b><tt>IOResult: byte;</b></tt>
  <p>
   Kod b³êdu (>127) dla ostatnio przeprowadzonej operacji I/O. 
	</p>
	</td>
</tr>


<tr>
	<td><b><tt>ScreenWidth</b></td>
	<td><tt>
  <b><tt>ScreenWidth: word = 40;</b></tt>
  <p>
Zmienna przechowuj±ca aktualn± szeroko¶æ ekranu. Domy¶lnie jest to warto¶æ 40 dla ekranu edytora.
	</p>
	</td>
</tr>

<tr>
	<td><b><tt>ScreenHeight</b></td>
	<td><tt>
  <b><tt>ScreenHeight: word = 24;</b></tt>
  <p>
Zmienna przechowuj±æa aktualn± wysoko¶æ ekranu. Domy¶lnie jest to warto¶æ 24 dla ekranu edytora.
	</p>
	</td>
</tr>

</table>


<p class="tekst-wiekszy2">[ Procedures and functions ]</p>

<table border="1">
 
<tr>
	<td><b><tt>Abs</b></td>
	<td><tt>
  <b><tt>function Abs(x: real): real;<br />
         function Abs(x: integer): integer;</b></tt>
  <p>
 Funkcja obliczaj±ca warto¶æ bezwzglêdn± podanej liczby (ang. Absolute value). Warto¶æ bezwzglêdna liczby nieujemnej to ta sama liczba, a liczby ujemnej - liczba do niej przeciwna. Funkcja w przypadku podania jej argumentu ca³kowitego zwraca wynik równie¿ typu ca³kowitego.
	</p>
	</td>
</tr>


<tr>
	<td><b><tt>ArcTan</b></td>
	<td><tt>
  <b><tt>function ArcTan(x: real): real;</b></tt>
  <p>
Funkcja ArcTan (arcus tangens) zwraca warto¶æ k±ta, którego tangens wynosi x.
	</p>
	</td>
</tr>


<tr>
	<td><b><tt>Assign</b></td>
	<td><tt>
	<b><tt>procedure Assign(var F:File; FileName:string)</tt></b>
<p>
Procedura przypisuje zmiennej plikowej F
plik o nazwie FileName. Aby móc odwo³ywaæ siê do jakiego¶
pliku, zawsze nale¿y najpierw u¿yæ procedury
Assign. Przy dalszych operacjach pliki s±
identyfikowane przy pomocy zmiennej
plikowej, a nie nazwy. 
</p>
	</td>
</tr>


<tr>
	<td><b><tt>BinStr</b></td>
	<td><tt>
  <b><tt>function BinStr(Value: cardinal; Digits: byte): TString;</b></tt>
  <p>
Funkcja BinStr zwraca ci±g znakowy z reprezentacj± binarn± warto¶ci Value. Digits okre¶la d³ugo¶æ ci±gu, który maksymalnie mo¿e liczyæ 32 znaki.
	</p>
	</td>
</tr>

<tr>
	<td><b><tt>Concat</b></td>
	<td><tt>
  <b><tt>function Concat(a,b: string): string; assembler<br>function Concat(a: string; b: char): string; assembler;<br>
function Concat(a: char; b: string): string; assembler;<br>	function Concat(a,b: char): string;</b></tt>
  <p>
Funkcja ³±czy dwa ci±gi tekstowe w nowy ci±g znakowy.
	</p>
	</td>
</tr>


<tr>
	<td><b><tt>Blockread<br />Blockwrite</td>
	<td><tt>
  <b><tt>procedure BlockRead(var f: file; var Buf; Count: word; var Result: word);<br>
procedure BlockWrite(var f: file; var Buf; Count: word; var Result: word);</b></tt>
  <p>
Procedura BlockRead wczytuje z pliku plik do zmiennej Buf nie wiêcej ni¿ Count bajtów i umieszcza w zmiennej Result ilo¶æ rzeczywi¶cie przeczytanych bajtów (która mo¿e byæ mniejsza od oczekiwanej np. ze wzglêdu na rzeczywist± d³ugo¶æ pliku). Procedura BlockWrite dzia³a tak samo, tylko zapisuje do pliku.
  </p>
	</td>
</tr>

<tr>
	<td><b><tt>Chr</b></td>
<td><tt>
<b><tt>function Chr(X: Byte): Char;</tt></b>
<p>
Funkcja zwraca znak (Char) o odpowiadaj±cym kodzie ATASCII podanym w parametrze.
</p>
<span style="color: #0000ff">
<pre>
Chr(65); // Zwraca znak A
Chr(90); // Zwraca znak Z
Chr(32); // Zwraca znak spacji
</pre>
</span>

Zamiennie z funkcj± Chr, chc±c uzyskaæ odpowiedni znak mo¿emy u¿yæ jego kodu ATASCII poprzedzaj±c go #
<span style="color: #0000ff">
<pre>
Writeln(#65);       // Znak A
Writeln(#65#32#65); // Napisze 'A Z'	
</pre>
</span>

</td>
</tr>

<tr>
	<td><b><tt>Cos</b></td>
	<td><tt>
  <b><tt>function Cos(x: real): real;</b></tt>
  <p>
Cosinus k±ta (x w radianach).
	</p>
	</td>
</tr>

<tr>
	<td><b><tt>Close</b></td>
	<td><tt>
  <b><tt>procedure Close(var f: file);</b></tt>
  <p>
Procedura s³u¿±ca do zamykania otwartego pliku dowolnego typu. Ka¿dy plik otwarty przy pomocy Reset lub Rewrite powinno siê zamkn±æ przy pomocy Close. 
	</p>
	</td>
</tr>


<tr>
	<td><b><tt>Dec</b></td>
	<td><tt>
<b><tt>procedure Dec(var X [, N: int]);</tt></b>

<p>
Procedura zmniejsza warto¶æ parametru X o 1 lub warto¶æ parametru N.
</p>
Warto¶æ parametru X mo¿e byæ typu CHAR, BYTE, WORD, CARDINAL. Procedura DEC generuje optymalny kod,
jest zalecana do u¿ywania w pêtlach, zamiast operatora odejmowania (-).
<span style="color: #0000ff">
<pre>
 dec(tmp);
 dec(tmp[2]);
</pre>
</span>	
	
	</td>
</tr>


<tr>
	<td><b><tt>DeleteFile</b></td>
	<td><tt>
  <b><tt>function DeleteFile(FileName: string): Boolean;</b></tt>
  <p>
Funkcja pozwala skasowaæ plik z dysku o nazwie FileName, zwraca TRUE kiedy operacja powiod³a siê, FALSE w przypadku wyst±pienia b³êdu (najczê¶ciej z powodu zabezpieczenia przed zapisem lub b³êdnej nazwy pliku).
	</p>
	</td>
</tr>


<tr>
	<td><b><tt>DPeek</b></td>
	<td><tt>
   <b><tt>function DPeek(a: word): word;</tt></b>
	<p>
	Funkcja zwraca s³owo spod adresu A.
	</p>
	</td>
</tr>

<tr>
	<td><b><tt>DPoke</b></td>
	<td><tt>
	<b><tt>procedure DPoke(a: word; value: word);</tt></b>
	<p>
	Procedura zapisuje s³owo Value pod adresem A.
	</p>
	</td>
</tr>


<tr>
	<td><b><tt>Eof</b></td>
	<td><tt>
	<b><tt>function Eof(var f: file): Boolean;</tt></b>
	<p>
Funkcja zwraca warto¶æ logiczn± True je¶li osi±gniêty zosta³ koniec pliku.
</p>
	</td>
</tr>

<tr>
	<td><b><tt>Exit</b></td>
	<td><tt>
Wywo³anie procedury Exit powoduje natychmiastowe opuszczenie bloku programu, w którym to wywo³anie nast±pi³o. Mo¿na jej u¿yæ do opuszczenia pêtli, wyj¶cia z procedury/funkcji lub programu g³ównego. 
	</td>
</tr>


<tr>
	<td><b><tt>Exp</b></td>
	<td><tt>
	<b><tt>function Exp(x: real): real;</tt></b>
	<p>
Funkcja podnosz±ca liczbê e (=2.71) do potêgi podanej przez argument.
</p>
	</td>
</tr>


<tr>
	<td><b><tt>FilePos</b></td>
	<td><tt>
	<b><tt>function FilePos(var f: file): cardinal;</tt></b>
	<p>
Funkcja zwraca aktualn± pozycjê pliku. Plik nie mo¿e byæ tekstowy i musi byæ otwarty (np. poleceniem Reset). 
Bity 0..15 zwróconej warto¶ci to numer sektora dysku, bity 16..23 pozycja w sektorze [0..255]. Jest to odpowiednik instrukcji NOTE.
</p>
	</td>
</tr>


<tr>
	<td><b><tt>FileSize</b></td>
	<td><tt>
	<b><tt>function FileSize(var f: file): cardinal;</tt></b>
	<p>
Funkcja zwraca d³ugo¶æ pliku w bajtach (Sparta DOS X). Plik nie mo¿e byæ tekstowy i musi byæ otwarty (np. poleceniem Reset).
</p>
	</td>
</tr>


<tr>
	<td><b><tt>FillChar</tt></b></td>
	<td><tt>
<b><tt>procedure FillChar(a: pointer; count: word; value: char);</tt></b>
<p>
Procedura wype³nia bufor okre¶lony w parametrze X identycznymi znakami lub bajtami. Parametr Value musi okre¶laæ dane, natomiast Count - ilo¶æ danych jakie zostan± przypisane do bufora.
</p>
<span style="color: #0000ff">
<pre>
var
  Buffer : array[0..100] of Char;
begin
  FillChar(Buffer, SizeOf(Buffer), 'A');
end.
</pre>
</span>
</tt>
	</td>
</tr>

<tr>
	<td><b><tt>Frac</b></td>
	<td><tt>
	<b><tt>function Frac(x: real): real;</tt></b>
<p>
Zwraca czê¶æ u³amkow± liczby x w postaci rzeczywistej.
</p>
	</td>
</tr>


<tr>
	<td><b><tt>GetIntVec</b></td>
	<td><tt>
   <b><tt>procedure GetIntVec(intno: Byte; var vector: pointer);</tt></b>
<p>   
 Procedura odczytuje adres wektora przerwañ wg. kodu INTNO. Obecnie dopuszczalnymi kodami s±:
<span style="color: #0000ff">
<pre>
iDLI - przerwanie DLI
iVBL - przerwanie VBL
</pre>
</span>
</td>
</tr>


<tr>
	<td><b><tt>Halt</b></td>
	<td><tt>
	<b><tt>procedure halt;</tt></b>
<p>
Wywo³anie powoduje natychmiastowe wyj¶cie z programu. Mo¿na (opcjonalnie) podaæ kod b³êdu, w przypadku MP jest on ignorowany.
</p>
	</td>
</tr>


<tr>
	<td><b><tt>Hi</b></td>
	<td><tt>
   <b><tt>function Hi(x): byte</tt></b>	
   <p>
	Funkcja zwracaj±ca starszy bajt parametru X.
	</p>
	</td>
</tr>


<tr>
	<td><b><tt>HexStr</b></td>
	<td><tt>
  <b><tt>function HexStr(Value: cardinal; Digits: byte): TString;</b></tt>
  <p>
Funkcja HexStr zwraca ci±g znakowy z reprezentacj± heksadecymaln± warto¶ci Value. Digits okre¶la d³ugo¶æ ci±gu, który maksymalnie mo¿e liczyæ 32 znaki.
	</p>
	</td>
</tr>


<tr>
	<td><b><tt>Inc</b></td>
	<td><tt>
<b><tt>procedure Inc(var X [, N: int]);</tt></b>

<p>
Procedura zwiêksza warto¶æ parametru X o 1 lub warto¶æ parametru N.
</p>
Warto¶æ parametru X mo¿e byæ typu CHAR, BYTE, WORD, CARDINAL. Procedura INC generuje optymalny kod,
jest zalecana do u¿ywania w pêtlach, zamiast operatora dodawania (+).
<span style="color: #0000ff">
<pre>
 inc(tmp);
 inc(tmp[2]);
</pre>
</span>	
	
	</td>
</tr>

<tr>
	<td><b><tt>Int</b></td>
	<td><tt>
   <b><tt>function Int(x: real): real;</tt></b>
   <p>
 Funkcja zwraca czê¶æ ca³kowit± argumentu bêd±cego liczb± rzeczywist±.
	</p>
	</td>
</tr>


<tr>
	<td><b><tt>IOResult</b></td>
	<td><tt>
	<b><tt>var IOResult: byte;</tt></b>
	<p>
	Zmienna IOResult przechowuje ostatni b³±d operacji I/O.
<a href="http://atariki.krap.pl/index.php/Kody_statusowe_Atari_OS">Kody b³êdów I/O</a>
	</p>
	</td>
</tr>

<tr>
	<td><b><tt>Ln</b></td>
	<td><tt>
   <b><tt>function Ln(x: real): real;</tt></b>
   <p>
 Funkcja licz±ca logarytm naturalny (o podstawie e) z podanej liczby. Argument funkcji musi byæ dodatni!
	</p>
	</td>
</tr>

<tr>
	<td><b><tt>Lo</b></td>
	<td><tt>
   <b><tt>function Lo(x): byte;</tt></b>
   <p>
	Funkcja zwracaj±ca m³odszy bajt parametru X.
	</p>
	</td>
</tr>

<tr>
	<td><b><tt>LowerCase</b></td>
	<td><tt>
   <b><tt>function LowerCase(a: char): char;</tt></b>
   <p>
 Funkcja zmieniaj±ca znaki 'A'..'Z' na odpowiednie ma³e znaki 'a'..'z'
	</p>
	</td>
</tr>


<tr>
	<td><b><tt>Move</b></td>
	<td><tt><b><tt>procedure Move(source, dest: pointer; count: word);</tt></b>
<p>
Procedura s³u¿y do kopiowania danych ze ¼ród³a (parametr Source) do bufora oznaczonego jako przeznaczenie (parametr Dest). Ilo¶æ kopiowanych danych okre¶la parametr Count.
</p>
</td>
</tr>


<tr>
	<td><b><tt>OctStr</b></td>
	<td><tt>
  <b><tt>function OctStr(Value: cardinal; Digits: byte): TString;</b></tt>
  <p>
Funkcja OctStr zwraca ci±g znakowy z reprezentacj± ósemkow± warto¶ci Value. Digits okre¶la d³ugo¶æ ci±gu, który maksymalnie mo¿e liczyæ 32 znaki.
	</p>
	</td>
</tr>


<tr>
	<td><b><tt>Odd</b></td>
	<td><tt>
  <b><tt>function Odd(x: cardinal): Boolean;<br />function Odd(x: integer): Boolean;</b></tt>
  <p>
Funkcja Odd zwraca warto¶æ True je¿eli liczba okre¶lona w parametrze X jest nieparzysta, False je¿eli jest parzysta.
	</p>
	</td>
</tr>



<tr>
	<td><b><tt>Ord</b></td>
	<td><tt>
<b><tt>function Ord(X);</tt></b>
<p>
Funkcja ta dzia³a odwrotnie do Chr. Z podanego znaku jako parametr zwraca nam jego kod w ATASCII.
</p>
<span style="color: #0000ff">
<pre>
Ord('A'); // Zwraca 65
Ord('Z'); // Zwraca 90
Ord(' '); // Zwraca 32	
</pre>
</span>
	</td>
</tr>


<tr>
	<td><b><tt>ParamCount</b></td>
	<td><tt>
<b><tt>function ParamCount: byte;</tt></b>
<p>
Funkcja ParamCount zwraca ilo¶æ dostêpnych argumentów (Sparta Dos X, BWDos), tzn. maksymalny indeks dla procedury ParamStr. ParamCount okre¶la ilo¶æ parametrów przekazanych do programu z linii poleceñ. 
</p>
	</td>
</tr>


<tr>
	<td><b><tt>ParamStr</b></td>
	<td><tt>
<b><tt>function ParamStr(Index: byte): TString;</tt></b>
<p>
Funkcja ParamStr zwraca parametry programu (Sparta Dos X, BWDos). Index to numer parametru, czyli ci±gu znaków oddzielonego spacj±. Je¿eli uruchomimy program TEST.EXE w taki sposób:
<span style="color: #0000ff">
<pre>
TEST.EXE parametr1 parametr2 parametr3
</pre>
</span>
To aby uzyskaæ parametr3 nale¿y podaæ Index=3, za¶ aby uzyskaæ parametr1 nale¿y Index=1. Index=0 to specjalny argument, wtedy funkcja zwraca napêd z którego zosta³ uruchomiony programu, np. 'D1:'
</p>
	</td>
</tr>



<tr>
	<td><b><tt>Pause</b></td>
	<td><tt>
	<b><tt>procedure Pause;<br />
	procedure Pause(n: word);</tt></b>
	<p>
Zatrzymuje dzia³anie programu na N * 1.50 sek
   </p>
   </td>
</tr>


<tr>
	<td><b><tt>Peek</b></td>
	<td><tt>
	<b><tt>function Peek(a: word): byte;</tt></b>
	<p>
Funkcja zwraca bajt spod adresu A.
   </p>
   </td>
</tr>


<tr>
	<td><b><tt>Point</b></td>
	<td><tt>
	<b><tt>function Point(AX, AY: smallint): TPoint;</tt></b>
	<p>
Na podstawie parametrów AX oraz AY tworzony jest rekord typu TPoint.
	</p>
	</td>
</tr>


<tr>
	<td><b><tt>PointsEqual</b></td>
	<td><tt>
	<b><tt>function PointsEqual(const P1, P2: TPoint): Boolean; </tt></b>
	<p>
Funkcja sprawdza czy warto¶ci wspó³rzêdnych okre¶lone w parametrach P1 oraz P2 s± sobie równe. W takim wypadku funkcja zwraca warto¶æ True.
	</p>
	</td>
</tr>


<tr>
	<td><b><tt>Poke</b></td>
	<td><tt>
	<b><tt>procedure Poke(a: word; value: byte);</tt></b>
	<p>
	Procedura zapisuje bajt Value pod adresem A.
	</p>
	</td>
</tr>


<tr>
	<td><b><tt>Pi</b></td>
	<td><tt>Zwraca warto¶æ liczby pi.</td>
</tr>


<tr>
	<td><b><tt>Pred</b></td>
	<td><tt>
	<b><tt>function Pred(X: TOrdinal): TOrdinal;</tt></b>
	<p>
	Poprzednik elementu X.	
	</p>
</tr>


<tr>
	<td><b><tt>Random</b></td>
	<td><tt>
	<b><tt>function Random: Real; assembler;</tt></b>
<p>
Funkcja zwraca losow± warto¶æ z przedzia³u <0 .. 1>	
</p>
	<b><tt>function Random(range: byte): byte; assembler;</tt></b>
<p>
Funkcja zwraca losow± warto¶æ z przedzia³u <0 .. range-1>, w przypadku Range=0 zwraca warto¶æ losow± z przedzia³u <0 .. 255 >
</p>

	<b><tt>function Random(range: smallint): smallint;</tt></b>
<p>	
Funkcja zwraca losow± warto¶æ z przedzia³u <0 .. range-1>	
</p>
	</td>
</tr>


<tr>
	<td><b><tt>ReadConfig</b></td>
	<td><tt>
	<b><tt>function ReadConfig(devnum: byte): cardinal;</tt></b>
	<p></p>
	Odczyt statusu stacji DEVNUM. Wynikiem s± cztery bajty DVSTAT ($02EA..$02ED).
<pre>
Byte 0 ($02ea):
Bit 0:Indicates the last command frame had an error. 
Bit 1:Checksum, indicates that there was a checksum error in the last command or data frame
Bit 2:Indicates that the last operation by the drive was in error. 
Bit 3:Indicates a write protected diskette. 1=Write protect 
Bit 4:Indicates the drive motor is on. 1=motor on 
Bit 5:A one indicates MFM format (double density) 
Bit 6:Not used 
Bit 7:Indicates Density and a Half if 1 

Byte 1 ($02eb):
Bit 0:FDC Busy should always be a 1 
Bit 1:FDC Data Request should always be 1 
Bit 2:FDC Lost data should always be 1 
Bit 3:FDC CRC error, a 0 indicates the last sector read had a CRC error 
Bit 4:FDC Record not found, a 0 indicates last sector not found 
Bit 5:FDC record type, a 0 indicates deleted data mark 
Bit 6:FDC write protect, indicates write protected disk 
Bit 7:FDC door is open, 0 indicates door is open 

Byte 2 ($2ec):
Timeout value for doing a format. 

Byte 3 ($2ed):
not used, should be zero
</pre>	
</tr>


<tr>
	<td><b><tt>ReadSector</b></td>
	<td><tt>
	<b><tt>procedure ReadSector(devnum: byte; sector: word; var buf);</tt></b>
	<p>
	Odczyt sektora SECTOR dyskietki w stacji dysków DEVNUM i zapisanie go w buforze BUF.
	</p>
</tr>


<tr>
	<td><b><tt>Rect</b></td>
	<td><tt>
	<b><tt>function Rect(ALeft, ATop, ARight, ABottom: smallint): TRect;</tt></b>
	<p>
Na podstawie parametrów tworzony jest rekord typu TRect. 	
	</p>
</tr>



<tr>
	<td><b><tt>RenameFile</b></td>
	<td><tt>
  <b><tt>function RenameFile(OldName, NewName: string): Boolean;</b></tt>
  <p>
Funkcja pozwala zmieniæ nazwê pliku OldName na now± nazwê NewName, zwraca TRUE kiedy operacja powiod³a siê, FALSE w przypadku wyst±pienia b³êdu (najczê¶ciej z powodu zabezpieczenia przed zapisem lub b³êdnej nazwy pliku).
	</p>
<span style="color: #0000ff">
<pre>
RenameFile('D:OLDNAME.TMP', 'NEWNAME.TMP');
</pre>
</span>
	</td>
</tr>


<tr>
	<td><b><tt>Reset</b></td>
	<td><tt>
  <b><tt>procedure Reset(var f: file; l: Word);</b></tt>
  <p>
	Otwiera istniej±cy plik z nazw± przekazan± do F poleceniem Assign. Opcjonalnie mo¿emy podaæ rozmiar rekordu w bajtach L, domy¶lnie jest to warto¶æ 128.
	</p>
	</td>
</tr>


<tr>
	<td><b><tt>Rewrite</b></td>
	<td><tt>
  <b><tt>procedure Rewrite(var f: file; l: Word);</b></tt>
  <p>
	Tworzy i otwiera nowy plik. F jest nazw± przekazan± za pomoc± polecenia Assign. Opcjonalnie mo¿emy podaæ rozmiar rekordu w bajtach L, domy¶lnie jest to warto¶æ 128.
	</p>	
	</td>
</tr>

<tr>
	<td><b><tt>Round</b></td>
	<td><tt>
	<b><tt>function Round(x: real): integer;</tt></b>
	<p>
Funkcja Round dokonuje zaokr±glenia podanej liczby rzeczywistej do najbli¿szej liczby ca³kowitej.
</p>
	</td>
</tr>


<tr>
	<td><b><tt>Seek</b></td>
	<td><tt>
	<b><tt>procedure Seek(var f: file; N: cardinal);</tt></b>
	<p>
Ustawia pozycjê w pliku na N. N powinno byæ warto¶ci± zwrócon± przez FilePos. Jest to odpowiednik instrukcji POINT.
</p>
	</td>
</tr>


<tr>
	<td><b><tt>SetLength</b></td>
	<td><tt>
	<b><tt>procedure SetLength(var S: string; Len: byte);</tt></b>
	<p>
Ustawia d³ugo¶æ ci±gu S na LEN.
</p>
	</td>
</tr>


<tr>
	<td><b><tt>SetIntVec</b></td>
	<td><tt>
   <b><tt>procedure SetIntVec(intno: Byte; vector: pointer);</tt></b><br />
<p>   
 Procedura ustawia adres wektora przerwañ wg. kodu INTNO. Obecnie dopuszczalnymi kodami s±:
<span style="color: #0000ff">
<pre>
iDLI - przerwanie DLI
iVBL - przerwanie VBL
</pre>
</span>
</td>
</tr>


<tr>
	<td><b><tt>Sin</b></td>
	<td><tt>
  <b><tt>function Sin(x: real): real;</b></tt>
  <p>
Sinus k±ta (x w radianach).
	</p>
	</td>
</tr>


<tr>
	<td><b><tt>Succ</b></td>
	<td><tt>
	<b><tt>function Succ(X: TOrdinal): TOrdinal;</tt></b>
	<p>
	Nastêpnik elementu X.	
	</p>
</tr>


<tr>
	<td><b><tt>Space</b></td>
	<td><tt>
<b><tt>function Space(Len: Byte): ^char;</tt></b>	
<p>
Funkcja generuje nowy ci±g znakowy o d³ugo¶ci LEN wype³niony znakami spacji.
</p>
	</td>
</tr>



<tr>
	<td><b><tt>SizeOf</tt></b></td>
	<td><tt>
<b><tt>function SizeOf(X: AnyType): byte;</tt></b>	
<p>
Funkcja zwraca rozmiar podanej zmiennej (lub typu) w bajtach.
</p>
	</td>
</tr>

<tr>
	<td><b><tt>Str</b></td>
	<td><tt>
	<b><tt>procedure Str(var X: TNumericType; var S: string);</tt></b>
<p>
Instrukcja zamienia liczbê X na ³añcuch znaków S.
</p>
	</td>
</tr>


<tr>
	<td><b><tt>StringOfChar</b></td>
	<td><tt>
	<b><tt>procedure StringOfChar(ch: Char; len: byte): ^char;</tt></b>
<p>
Funkcja generuje nowy ci±g znakowy o d³ugo¶ci LEN wype³niony znakami CH.
</p>
	</td>
</tr>


<tr>
	<td><b><tt>Sqr</b></td>
	<td><tt>
   <b><tt>function Sqr(x: real): real;<br>function Sqr(x: integer): integer;</tt></b>
   <p>
  Funkcja obliczaj±ca kwadrat podanej liczby (ang. Square).
	</p>
	</td>
</tr>


<tr>
	<td><b><tt>Sqrt</b></td>
	<td><tt>
   <b><tt>function Sqrt(x: real): real;<br>function Sqrt(x: single): single;<br>function Sqrt(x: integer): single;</tt></b>
   <p>
   Funkcja obliczaj±ca pierwiastek kwadratowy podanej liczby (ang. Square root).
	</p>
	</td>
</tr>


<tr>
	<td><b><tt>Trunc</b></td>
	<td><tt>
   <b><tt>function Trunc(x: real): integer;</tt></b>
   <p>
Funkcja zwraca czê¶æ ca³kowit± liczby rzeczywistej w postaci liczby ca³kowitej.
	</p>
	</td>
</tr>


<tr>
	<td><b><tt>UpCase</b></td>
	<td><tt>
   <b><tt>function UpCase(a: char): char;</tt></b>
   <p>
 Funkcja zmieniaj±ca znaki 'a'..'z' na odpowiednie du¿e znaki 'A'..'Z'
	</p>
	</td>
</tr>


<tr>
	<td><b><tt>Val</b></td>
	<td><tt>
	<b><tt>procedure Val(const S: string; var V; var Code: Byte);</tt></b>
<p>
Procedura przekszta³ca ci±g znaków S na liczbê V. Code przyjmie warto¶æ 0 je¶li nie by³o b³êdnych znaków, w przeciwnym wypadku przyjmie numer znaku który spowodowa³ b³±d konwersji.

</p>
	</td>
</tr>


<tr>
	<td><b><tt>WriteSector</b></td>
	<td><tt>
	<b><tt>procedure WriteSector(devnum: byte; sector: word; var buf);</tt></b>
<p>
Zapis sektora SECTOR dyskietki w stacji DEVNUM na podstawie bufora BUF.
</p>
	</td>
</tr>


</table>

<p></p>
<br />



<A NAME="u_crt">
<u><tt><h2>CRT</h2></tt></u>

<a href="http://www.freepascal.org/docs-html/rtl/crt/index-5.html">Reference for unit 'Crt': Procedures and functions</a>

<p class="tekst-wiekszy2">[ Constants ]</p>

<pre>
CN_START_SELECT_OPTION	= 0;
CN_SELECT_OPTION	= 1;
CN_START_OPTION		= 2;
CN_OPTION		= 3;
CN_START_SELECT		= 4;
CN_SELECT		= 5;
CN_START		= 6;
CN_NONE			= 7;
</pre>


<p class="tekst-wiekszy2">[ Variables ]</p>

<table border="1">

<tr>
	<td><tt><b>Consol</b></td>
	<td><tt>
	<b><tt>Consol: byte absolute $d01f;</tt></b>
	<p>
	Zmienna 'Consol' zwraca kod naci¶niêtego klawisza/klawiszy konsoli.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>TextAttr</b></td>
	<td><tt>
	<b><tt>TextAttr: byte = 0;</tt></b>
	<p>
	Zmienna 'TextAttr' przechowuje warto¶æ jaka jest dodawana do ka¿dego wy¶wietlanego znaku, np. TextAttr = $80 spowoduje ¿e znaki bêd± wy¶wietlane w inwersie.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>WhereX</b></td>
	<td><tt>
	<b><tt>WhereX: byte absolute $54;</tt></b>
	<p>
	Zmienna 'WhereX' przechowuje aktualn± poziom± pozycjê kursora.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>WhereY</b></td>
	<td><tt>
	<b><tt>WhereY: byte absolute $55;</tt></b>
	<p>
	Zmienna 'WhereY' przechowuje aktualn± pionow± pozycjê kursora.
	</p>
	</td>
</tr>

</table>


<p class="tekst-wiekszy2">[ Procedures and functions ]</p>

<table border="1">

<tr>
	<td><tt><b>ClrEol</b></td>
	<td><tt>
	<b><tt>procedure ClrEol;</tt></b>
	<p>
	Procedura czy¶ci wiersz od aktualnej pozycji kursora do prawej strony krawêdzi ekranu. Pozycja kursora nie ulega zmianie.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>ClrScr</b></td>
	<td><tt>
	<b><tt>procedure ClrScr;</tt></b>
	<p>
	Procedura czy¶ci ekran edytora, wykonuje kod znaku CH_CLR
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>CursorOff</b></td>
	<td><tt>
	<b><tt>procedure CursorOff;</tt></b>
	<p>
	Procedura wy³±cza kursor.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>CursorOn</b></td>
	<td><tt>
	<b><tt>procedure CursorOn;</tt></b>
	<p>
	Procedura w³±cza kursor.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>Delay</b></td>
	<td><tt>
	<b><tt>procedure Delay(MS: Word);</tt></b>
	<p>
	Procedura czeka zadan± ilo¶æ milisekund MS. W przybli¿eniu Delay(1000) generuje opó¼nienie jednej sekundy.	
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>DelLine</b></td>
	<td><tt>
   <b><tt>procedure DelLine;</tt></b>
   <p>
 Procedura kasuje wiersz na aktualnej pozycji kursora, wykonuje kod znaku CH_DELLINE
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>GotoXY</b></td>
	<td><tt>
   <b><tt>procedure GotoXY(x, y: byte);</tt></b>
   <p>
 Procedura ustawia now± pozycjê kursora.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>InsLine</b></td>
	<td><tt>
   <b><tt>procedure InsLine;</tt></b>
   <p>
 Procedura wstawia pusty wiersz na aktualnej pozycji kursora, wykonuje kod znaku CH_INSLINE
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>Keypressed</b></td>
	<td><tt>
	<b><tt>function Keypressed: Boolean;</tt></b>
	<p>
	Funkcja zwraca TRUE gdy zosta³ naci¶niêty jaki¶ klawisz klawiatury, w przeciwnym razie zwraca FALSE.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>NoSound</b></td>
	<td><tt>
	<b><tt>procedure NoSound;</tt></b>
	<p>
	Procedura wycisza kana³y obu POKEY-i ($D200, $D210)
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>ReadKey</b></td>
	<td><tt>
	<b><tt>function ReadKey: char;</tt></b>
	<p>
	Funkcja zwraca kod naci¶niêtego klawisza klawiatury.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>Sound</b></td>
	<td><tt>
	<b><tt>procedure Sound(Chan,Freq,Dist,Vol: byte);</tt></b>
	<p>
	Procedura odtwarza d¼wiêk na kanale POKEY-a CHAN (0..3, 4..7), o czêstotliwo¶ci FREQ (0..255), filtrach DIST (0..7), g³o¶no¶ci VOL (0..15).
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>TextBackground</b></td>
	<td><tt>
	<b><tt>procedure TextBackground(a: byte);</tt></b>
	<p>
   Procedura ustawia nowy kolor t³a znaków (dzia³a najlepiej z w³±czonym VBXE).	</p>
	</td>
</tr>

<tr>
	<td><tt><b>TextColor</b></td>
	<td><tt>
	<b><tt>procedure TextColor(a: byte);</tt></b>
	<p>
	Procedura ustawia nowy kolor znaków (dzia³a najlepiej z w³±czonym VBXE).	</p>
	</td>
</tr>

</table>


<p></p>
<br />


<A NAME="u_graph">
<u><tt><h2>GRAPH</h2></tt></u>

<a href="http://www.freepascal.org/docs-html/rtl/graph/index-5.html">Reference for unit 'Graph': Procedures and functions</a>


<p class="tekst-wiekszy2">[ Constants ]</p>

<pre>
	{ graphic drivers }
	D1bit	= 11;
	D2bit	= 12;
	D4bit	= 13;
	D6bit	= 14;		// 64 colors Half-brite mode - Amiga
	D8bit	= 15;
	D12bit	= 16;		// 4096 color modes HAM mode - Amiga

	m640x480 = 8 + 16;

	{ error codes }
	grOK		= 0;
	grNoInitGraph	= -1;
	grNotDetected	= -2;
	grFileNotFound	= -3;
	grInvalidDriver	= -4;
	grNoLoadMem	= -5;
	grNoScanMem	= -6;
	grNoFloodMem	= -7;
	grFontNotFound	= -8;
	grNoFontMem	= -9;
	grInvalidMode	= -10;
	grError		= -11;
	grIOerror	= -12;
	grInvalidFont	= -13;
	grInvalidFontNum= -14;
	grInvalidVersion= -18;
</pre>


<p class="tekst-wiekszy2">[ Variables ]</p>

<table border="1">

<tr>
	<td><tt><b>GraphResult</td>
	<td><tt>
<b><tt>GraphResult : byte;</tt></b>
<p>
</p>
	</td>
</tr>

</table>


<p class="tekst-wiekszy2">[ Procedures and functions ]</p>

<table border="1">

<tr>
	<td><tt><b>Bar</b></td>
	<td><tt>
	<b><tt>procedure Bar(x1, y1, x2, y2: Smallint);</tt></b>
	<p>
	Prostok±t, np. dla wykresów s³upkowych.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>Bar3D</b></td>
	<td><tt>
	<b><tt>procedure Bar3D(x1, y1, x2, y2: smallint; depth: word; top: boolean);</tt></b>
	<p>
	S³upek trójwymiarowy.
	</p>
	</td>
</tr>


<tr>
	<td><tt><b>Circle</b></td>
	<td><tt>
	<b><tt>procedure Circle(x0,y0,radius: word);</tt></b>
	<p>
	Okr±g.
	</p>
	</td>
</tr>


<tr>
	<td><tt><b>ClipLine</b></td>
	<td><tt>
	<b><tt>procedure ClipLine(x1, y1, x2, y2: smallint);</tt></b>
	<p>
	</p>
	</td>
</tr>


<tr>
	<td><tt><b>Ellipse</b></td>
	<td><tt>
	<b><tt>procedure Ellipse(x0, y0, a, b: word);</tt></b>
	<p>
	Elipsa.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>FillEllipse</b></td>
	<td><tt>
	<b><tt>procedure FillEllipse(x0, y0, a, b: word);</tt></b>
	<p>
	Elipsa wype³niona wewn±trz.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>FillRect</b></td>
	<td><tt>
	<b><tt>procedure FillRect(Rect: TRect);</tt></b>
	<p>
	Prostok±t wype³niony wewn±trz.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>FloodFill</b></td>
	<td><tt>
	<b><tt>procedure FloodFill(x, y: smallint; color: byte);</tt></b>
	<p>
	Wype³nienie zamkniêtego obszaru ekranu.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>GetColor</b></td>
	<td><tt>
	<b><tt>function GetColor: byte; assembler;</tt></b>
	<p>
	Podaj bie¿±cy kolor rysowania.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>GetMaxX</b></td>
	<td><tt>
	<b><tt>function GetMaxX: word;</tt></b>
	<p>
	Podaj najwy¿sz± warto¶æ wspó³rzêdnej X na ekranie.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>GetMaxY</b></td>
	<td><tt>
	<b><tt>function GetMaxY: word;</tt></b>
	<p>
	Podaj najwy¿sz± warto¶æ wspó³rzêdnej Y na ekranie.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>GetPixel</b></td>
	<td><tt>
	<b><tt>function GetPixel(x,y: smallint): byte;</tt></b>
	<p>
	Podaj kolor danego punktu na ekranie.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>GetX</b></td>
	<td><tt>
	<b><tt>function GetX: smallint;</tt></b>
	<p>
	Podaj bie¿±c± wspó³rzêdn± X kursora graficznego.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>GetY</b></td>
	<td><tt>
	<b><tt>function GetY: smallint;</tt></b>
	<p>
	Podaj bie¿±c± wspó³rzêdn± Y kursora graficznego.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>InitGraph</b></td>
	<td><tt>
	<b><tt>procedure InitGraph(mode: byte);<br />procedure InitGraph(driver, mode: byte; pth: TString);</tt></b>
	<p>
	Zainicjuj tryb graficzny.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>Line</b></td>
	<td><tt>
	<b><tt>procedure Line(x0, y0, x1, y1: smallint);</tt></b>
	<p>
  Linia prosta.	
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>LineTo</b></td>
	<td><tt>
	<b><tt>procedure LineTo(x, y: smallint);</tt></b>
	<p>
	Linia od bie¿±cej pozycji kursora do wskazanego punktu.
	</p>
	</td>
</tr>


<tr>
	<td><tt><b>MoveRel</b></td>
	<td><tt>
	<b><tt>procedure MoveRel(Dx, Dy: smallint);</tt></b>
	<p>
	Przesuñ kursor graficzny.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>MoveTo</b></td>
	<td><tt>
	<b><tt>procedure MoveTo(x, y: smallint);</tt></b>
	<p>
	Przesuñ kursor graficzny do wskazanego punktu.
	</p>
	</td>
</tr>



<tr>
	<td><tt><b>PutPixel</b></td>
	<td><tt>
	<b><tt>procedure PutPixel(x,y: smallint);<br>procedure PutPixel(x,y: smallint; color: byte);</tt></b>
	<p>
	Zapal punkt na ekranie.
	</p>
	</td>
</tr>


<tr>
	<td><tt><b>Rectangle</b></td>
	<td><tt>
	<b><tt>procedure Rectangle(x1, y1, x2, y2: smallint);<br>procedure Rectangle(Rect: TRect);</tt></b>
	<p>
	Prostok±t.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>SetBkColor</b></td>
	<td><tt>
	<b><tt>procedure SetBkColor(color: byte);</tt></b>
	<p>
	Ustaw kolor t³a.
	</p>
	</td>
</tr>


<tr>
	<td><tt><b>SetClipRect</b></td>
	<td><tt>
	<b><tt>procedure SetClipRect(x0,y0,x1,y1: smallint);<br>procedure SetClipRect(Rect: TRect);</tt></b>
	<p>
	</p>
	</td>
</tr>



<tr>
	<td><tt><b>SetColor</b></td>
	<td><tt>
	<b><tt>procedure SetColor(color: byte);</tt></b>
	<p>
	Ustaw kolor pisaka.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>SetColorMapEntry</b></td>
	<td><tt>
	<b><tt>procedure SetColorMapEntry;<br />procedure  SetColorMapEntry(a,b,c: byte);</tt></b>
	<p>
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>SetColorMapDimensions</b></td>
	<td><tt>
	<b><tt>procedure SetColorMapDimensions(w,h: byte);</tt></b>
	<p>
	</p>
	</td>
</tr>


</table>

<p></p>
<br />


<A NAME="u_sysutils">
<u><tt><h2>SYSUTILS</h2></tt></u>

<a href="http://www.freepascal.org/docs-html/rtl/sysutils/index-5.html">Reference for unit 'Sysutils': Procedures and functions</a>


<p class="tekst-wiekszy2">[ Constants ]</p>
<pre>
faReadOnly	= $01;
faHidden	= $02;
faSysFile	= $04;
faVolumeID	= $08;
faDirectory	= $10;
faArchive	= $20;
faAnyFile	= $3f;
</pre>


<p class="tekst-wiekszy2">[ Types ]</p>

<table border="1">

<tr>
	<td><tt><b>TSearchRec</td>
	<td><tt>
<b>
<pre>
TSearchRec = record
		Attr: Byte;
		Name: TString;
		FindHandle: Pointer;
	     end;
</pre></b>
<p>
</p>
	</td>
</tr>

</table>


<p class="tekst-wiekszy2">[ Procedures and functions ]</p>

<table border="1">

<tr>
	<td><tt><b>AnsiUpperCase</td>
	<td><tt>
<b><tt>function AnsiUpperCase(const a: string): string;</tt></b>
<p>
Funkcja konwertuje znaki z ³añcucha A na wielkie. 
</p>
	</td>
</tr>

<tr>
	<td><tt><b>Beep</td>
	<td><tt>
<b><tt>procedure Beep;</tt></b>
<p>
Sygna³ brzêczka (buzzer).
</p>
	</td>
</tr>

<tr>
	<td><tt><b>Click</td>
	<td><tt>
<b><tt>procedure Click;</tt></b>
<p>
Sygna³ klawiatury.
</p>
	</td>
</tr>

<tr>
	<td><tt><b>DeleteFile</td>
	<td><tt>
<b><tt>function DeleteFile(var FileName: TString): Boolean;</tt></b>
<p>
Funkcja kasuje plik okre¶lony w parametrze FileName, zwraca TRUE gdy operacja siê powiod³a.
</p>
	</td>
</tr>


<tr>
	<td><tt><b>ExtractFileExt</td>
	<td><tt>
<b><tt>function ExtractFileExt(const FileName: string): TString;</tt></b>
<p>
Na podstawie nazwy pliku lub pe³nej ¶cie¿ki do pliku (okre¶lonej w parametrze FileName), funkcja zwraca rozszerzenie (poprzedzone kropk± - np. .txt).
</p>
	</td>
</tr>


<tr>
	<td><tt><b>FileExists</td>
	<td><tt>
<b><tt>function FileExists(const FileName: string): Boolean;</tt></b>
<p>
Funkcja sprawdza czy plik okre¶lony w parametrze FileName, istnieje (True) czy te¿ nie (False). 
</p>
	</td>
</tr>

<tr>
	<td><tt><b>FindFirst</td>
	<td><tt>
<b><tt>function FindFirst(const FileMask: TString; Attributes: Byte; var SearchResult: TSearchRec): byte;</tt></b>
<p>
Funkcja FindFirst wyszukuje pliki pasuj±ce do wzorca FileMask i posiadaj±ce atrybuty okre¶lone w Attributes. Je¶li zosta³y znalezione pliki pasuj±ce do szablonu to pierwszy z nich jest zwracany w zmiennej SerchResult.
</p>
	</td>
</tr>


<tr>
	<td><tt><b>FindNext</td>
	<td><tt>
<b><tt>function FindNext(var f: TSearchRec): byte;</tt></b>
<p>
Funkcja przechodzi do nastêpnego rekordu znalezionego wcze¶niej przy pomocy FindFirst. W parametrze musi zostaæ przekazane wskazanie na rekord, który wcze¶niej zosta³ u¿yty w funkcji FindFirst.
</p>
	</td>
</tr>


<tr>
	<td><tt><b>FindClose</td>
	<td><tt>
<b><tt>procedure FindClose(var f: TSearchRec);</tt></b>
<p>
Procedura zwalnia zasoby (pamiêæ) zaalokowan± przez funkcjê FindFirst. Procedura ta powinna byæ wywo³ywana za ka¿dym razem po zakoñczeniu procesu wyszukiwania.
</p>
	</td>
</tr>

<tr>
	<td><tt><b>GetTickCount</td>
	<td><tt>
<b><tt>function GetTickCount: cardinal;</tt></b>
<p>
GetTickCount zwraca 24-bitowy licznik czasu (PEEK(RTCLOK+2) + PEEK(RTCLOK+1)*256 + PEEK(RTCLOK)*65536). Jest to przydatne do pomiaru czasu.
</p>
	</td>
</tr>

<tr>
	<td><tt><b>IntToHex</td>
	<td><tt>
<b><tt>function IntToHex(Value: cardinal; Digits: byte): TString;</tt></b>
<p>
Funkcja konwertuje warto¶æ liczbow± na jej odpowiednik ³añcuchowy w systemie szesnastkowym.
</p>
	</td>
</tr>

<tr>
	<td><tt><b>IntToStr</td>
	<td><tt>
<b><tt>function IntToStr(a: integer): ^char;</tt></b>
<p>
Funkcja s³u¿y do konwersji liczby ca³kowitej podanej w parametrze do postaci ³añcuchowej.
</p>
	</td>
</tr>

<tr>
	<td><tt><b>RenameFile</td>
	<td><tt>
<b><tt>function RenameFile(var OldName,NewName: TString): Boolean;</tt></b>
<p>
RenameFile próbuje zmieniæ nazwê pliku (okre¶lonego w parametrze OldName) na NewName. Je¿eli operacja siê powiedzie, funkcja zwróci warto¶æ True; w przeciwnym wypadku - False. Mo¿e siê zdarzyæ, ¿e funkcja nie bêdzie mog³a zmieniæ nazwy (np. gdy aplikacja nie ma prawa do tego) - wówczas funkcja zwróci False. 
</p>
	</td>
</tr>

<tr>
	<td><tt><b>StrToFloat</td>
	<td><tt>
<b><tt>function StrToFloat(var s: TString): real;</tt></b>
<p>
Funkcja konwertuje ³añcuch do postaci zmiennoprzenkowej typu Real.
</p>
	</td>
</tr>

<tr>
	<td><tt><b>StrToInt</td>
	<td><tt>
<b><tt>function StrToInt(const S: char): byte;<br />function StrToInt (const S: TString): integer; </tt></b>
<p>
Funkcja s³u¿y do konwersji tekstu zapisanego w zmiennej S na liczbê ca³kowit± - o ile to mo¿liwe.
</p>
	</td>
</tr>

</table>

<p></p>
<br />



<A NAME="u_vbxe">
<u><tt><h2>VBXE</h2></tt></u>

<p>
Mapa pamiêci dla VBXE zdefiniowana jest w module SYSTEM
</p>
<pre>
VBXE_XDLADR = $0000;	// XDLIST
VBXE_MAPADR = $1000;	// COLOR MAP ADDRESS
VBXE_BCBADR = $0100;	// BLITTER LIST ADDRESS
VBXE_OVRADR = $5000;	// OVERLAY ADDRESS
VBXE_WINDOW = $B000;	// 4K WINDOW $B000..$BFFF
</pre>

<p class="tekst-wiekszy2">[ Constants ]</p>

<pre>
LoRes  = 1;
MedRes = 2;
HiRes  = 3;
</pre>


<p class="tekst-wiekszy2">[ Types ]</p>

<table border="1">

<tr>
	<td><tt><b>TUInt24</b></td>
	<td><tt>
	<pre>
record
	byte0: byte;
	byte1: byte;
	byte2: byte;
end;
</pre></td>
<td><tt>Typ 24-bitowy wykorzystywany do definicji adresów pamiêci VBXE.
</tt></td>
</tr>

<tr>
	<td><tt><b>TXDL</b></td>
	<td><tt>
	<pre>
record
	xdlc_: word;
	rptl_: byte;
	xdlc: word;
	rptl: byte;
	ov_adr: TUInt24;
	ov_step: word;
	mp_adr: TUInt24;
	mp_step: word;
	mp_hscrol: byte;
	mp_vscrol: byte;
	mp_width: byte;
	mp_height: byte;
	ov_width: byte;
	ov_prior: byte;
end;
</pre></td>
<td><tt>Typ TXDL wykorzystywany przez procedury GetXDL i SetXDL. Pozwala na modyfikacjê programu dla VBXE wykorzystywanego przez MadPascal.</td>
</tr>

<tr>
	<td><tt><b>TBCB</b></td>
	<td><tt>
	<pre>
record
	src_adr: TUInt24;
	src_step_y: smallint;
	src_step_x: shortint;
	dst_adr: TUInt24;
	dst_step_y: smallint;
	dst_step_x: shortint;
	blt_width: word;
	blt_height: byte;
	blt_and_mask: byte;
	blt_xor_mask: byte;
	blt_collision_mask: byte;
	blt_zoom: byte;
	pattern_feature: byte;
	blt_control: byte;
end;
</pre></td>
<td><tt>Typ TBCB (21 bajtów), Blitter Code Block. Definicja typu bloku programu dla Blittera VBXE.</td>
</tr>




<tr>
	<td><tt><b>TVBXEMemoryStream</b></td>
	<td><tt>
	<pre>
Object
	Position: cardinal;
	Size: cardinal;			// 0..Size-1

	procedure Create;

	procedure Clear;
	procedure SetBank;

	procedure ReadBuffer(var Buffer; Count: word);
	procedure WriteBuffer(var Buffer; Count: word);

	function ReadByte: Byte;
	function ReadWord: Word;
	function ReadDWord: Cardinal;

	procedure WriteByte(b: Byte);
	procedure WriteWord(w: Word);
	procedure WriteDWord(d: Cardinal);
end;
</pre></td>
<td><tt>Obiekt TVBXEMemoryStream pozwala na liniowy dostêp do pamiêci VBXE.</td>
</tr>


</table>



<p class="tekst-wiekszy2">[ Procedures and functions ]</p>

<table border="1">
<tr><tt>
	<td><tt><b>BlitterBusy</b></tt></td>
	<td><tt><b>function BlitterBusy: Boolean; assembler;</b>
	<p>Funkcja zwraca TRUE je¶li blitter VBXE zajêty jest wykonywaniem programu blittera.</p></td>
</tr>
<tr>
	<td><tt><b>ColorMapOff</b></tt></td>
	<td><tt><b>procedure ColorMapOff; assembler;</b>
	<p>Wy³±czenie mapy kolorów w programie XDLIST dla VBXE.</p></td>
</tr>
<tr>
	<td><tt><b>ColorMapOn</b></tt></td>
	<td><tt><b>procedure ColorMapOn; assembler;</b>
	<p>W³±czenie mapy kolorów w programie XDLIST dla VBXE.</p></td>
</tr>

<tr>
	<td><tt><b>DstBCB</b></td>
	<td><tt>
	<b><tt>procedure DstBCB(var a: TBCB; dst: cardinal);</b>
	<p>Procedura zmieniaj±ca adres docelowy (dst_adr) w programie blittera A.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>GetXDL</b></td>
	<td><tt>
	<b><tt>procedure GetXDL(var a: txdl); register; assembler;</b>
	<p>Procedura przepisuje do zmiennej A program XDLIST spod adresu VBXE_XDLADR w pamiêci VBXE.</p>
	</td>
</tr>

<tr>
	<td><tt><b>IniBCB</b></td>
	<td><tt>
	<b><tt>procedure IniBCB(var a: TBCB; src,dst: cardinal; w0, w1: smallint; w: word; h: byte; ctrl: byte);</b>
	<p>Procedura INIBCB pozwala zaincjowaæ pamiêæ dla programu blittera pod adresem A. Dodatkowe parametry okre¶laj± adres spod którego bêd± kopiowane dane
   	SRC, adres docelowy kopiowanych danych DST, szeroko¶æ okna danych ¼ród³owych W0, docelowych W1, rozmiar okna wynikowego, jego szeroko¶æ W, wysoko¶æ H, oraz 
   	okre¶liæ parametry koñcowe bloku programu blittera CTRL (ustawiony bit 3 CTRL nakazuje blitterowi odczyt kolejnego programu i jego wykonanie).
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>OverlayOff</b></td>
	<td><tt>
	<b>procedure OverlayOff; assembler;</b>
	<p>Wy³±czenie trybu overlay w programie XDLIST.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>RunBCB</b></td>
	<td><tt>
	<b><tt>procedure RunBCB(var a: TBCB); assembler;</b>
	<p>Wystartowanie blittera VBXE na podstawie adresu programu A.
	</p>
	</td>
</tr>


<tr>
	<td><tt><b>SetHorizontalRes</b></td>
	<td><tt>
	<b><tt>procedure SetHorizontalRes(a: byte); assembler;</b><br />
	<b><tt>procedure SetHRes(a: byte); assembler;</b>

	<p>Ustanowienie trybu overlay w programie XDLIST (LoRes: 160x240x256c, MedRes: 320x240x256c, HiRes: 640x240x16c).
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>VBXEMemoryBank</b></td>
	<td><tt>
	<b><tt>procedure VBXEMemoryBank(b: byte); assembler;</b>
	<p>W³±czenie 4K banku VBXE w okno pamiêci XE/XL $B000..$BCFF 
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>SetXDL</b></td>
	<td><tt>
	<b><tt>procedure SetXDL(var a: txdl); register; assembler;</b>
	<p>Procedura przepisuje program A pod adres VBXE_XDLADR w pamiêci VBXE.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>SrcBCB</b></td>
	<td><tt>
	<b><tt>procedure SrcBCB(var a: TBCB; src: cardinal);</tt></b>
	<p>Procedura zmieniaj±ca adres ¼ród³owy (src_adr) w programie blittera A.
	</p>
	</td>
</tr>


<tr>
	<td><tt><b>VBXEControl</b></td>
	<td><tt>
	<b><tt>procedure VBXEControl(a: byte); assembler;</tt></b>
	<p>Procedura ustawia warto¶c FX_VIDEO_CONTROL.
	</p>
	</td>
</tr>

<tr>
	<td><tt><b>VBXEOff</b></td>
	<td><tt>
	<b><tt>procedure VBXEOff</tt></b>
	<p>Wy³±czenie, reset VBXE.
	</p>
	</td>
</tr>

</table>

<p></p>
<br />



<A NAME="u_math">
<u><tt><h2>MATH</h2></tt></u>

<a href="http://www.freepascal.org/docs-html/rtl/math/index-5.html">Reference for unit 'Math': Procedures and functions</a>

<p class="tekst-wiekszy2">[ Procedures and functions ]</p>

<table border="1">


<tr>
	<td><tt><b>ArcCos</td>
	<td><tt>
<b><tt>function ArcCos(x: real): real;</tt></b>
<p>
Arcus cosinus jest funkcj± odwrotn± do funkcji Cos (cosinus). Warto¶æ parametru X musi nale¿eæ do przedzia³u obustronnie domkniêtego <-1; 1>. Warto¶ci± zwracan± przez funkcjê jest k±t z przedzia³u <0; ?> wyra¿ony w mierze ³ukowej (radianach).
</p>
	</td>
</tr>

<tr>
	<td><tt><b>ArcSin</td>
	<td><tt>
<b><tt>function ArcSin(x: real): real;</tt></b>
<p>
Funkcja ArcSin s³u¿y do obliczenia funkcji matematycznej arcus sinus z liczby X. Jest to funkcja odwrotna do funkcji sinus, tzn. sin(arcsin(x)) = x.
</p>
	</td>
</tr>

<tr>
	<td><tt><b>ArcTan2</td>
	<td><tt>
<b><tt>function ArcTan2(y, x: real) : real;</tt></b>
<p>
Funkcja oblicza arcus tangens (odwrotno¶æ tangensa) z liczby Y/X i zwraca warto¶æ w radianach.
</p>
	</td>
</tr>


<tr>
	<td><tt><b>Ceil</td>
	<td><tt>
<b><tt>function Ceil(a: real): smallint;</tt></b>
<p>
Funkcja zwraca najmniejsz± liczbê ca³kowit± wiêksz± lub równ± od tej podanej w parametrze.
</p>
	</td>
</tr>

<tr>
	<td><tt><b>CycleToRad</td>
	<td><tt>
<b><tt>function CycleToRad(cycle : real) : real;</tt></b>
<p>
Funkcja CycleToRad przelicza warto¶æ k±ta wyra¿onego w cyklach (obrotach) na k±t wyra¿ony w radianach.
</p>
	</td>
</tr>


<tr>
	<td><tt><b>DegNormalize</td>
	<td><tt>
<b><tt>function DegNormalize(deg : real) : real;</tt></b>
<p>
</p>
	</td>
</tr>


<tr>
	<td><tt><b>DegToGrad</td>
	<td><tt>
<b><tt>function DegToGrad(deg : real) : real;</tt></b>
<p>
Funkcja DegToGrad przelicza warto¶æ k±ta wyra¿onego w stopniach na k±t wyra¿ony w gradach.
</p>
	</td>
</tr>


<tr>
	<td><tt><b>DegToRad</td>
	<td><tt>
<b><tt>function DegToRad(deg : real) : real;</tt></b>
<p>
Funkcja DegToRad przelicza warto¶æ k±ta wyra¿onego w stopniach na k±t wyra¿ony w mierze ³ukowej, czyli radianach.
</p>
	</td>
</tr>


<tr>
	<td><tt><b>DivMod</td>
	<td><tt>
<b><tt>procedure DivMod(Dividend: integer; Divisor: Word; var r, Remainder: Word);<br />procedure DivMod(Dividend: integer; Divisor: Word; var r, Remainder: smallint);</tt></b>
<p>
</p>
	</td>
</tr>


<tr>
	<td><tt><b>EnsureRange</td>
	<td><tt>
<b><tt>function EnsureRange(const AValue, AMin, AMax: byte): Integer;<br />function EnsureRange(const AValue, AMin, AMax: Integer): Integer;</tt></b>
<p>
</p>
	</td>
</tr>

<tr>
	<td><tt><b>Floor</td>
	<td><tt>
<b><tt>function Floor(a: real): smallint;</tt></b>
<p>
Funkcja zwraca najbli¿sz± liczbê ca³kowit± mniejsz± lub równ± od tej podanej w parametrze.
</p>
	</td>
</tr>

<tr>
	<td><tt><b>FMod</td>
	<td><tt>
<b><tt>function FMod(a, b: real): real;</tt></b>
<p>
Funkcja FMod zwraca resztê z dzielenia dwóch liczb rzeczywistych.
</p>
	</td>
</tr>

<tr>
	<td><tt><b>GradToDeg</td>
	<td><tt>
<b><tt>function GradToDeg(grad : real) : real;</tt></b>
<p>
Funkcja GradToDeg przelicza warto¶æ k±ta wyra¿onego w gradach na k±t wyra¿ony w stopniach.
</p>
	</td>
</tr>

<tr>
	<td><tt><b>GradToRad</td>
	<td><tt>
<b><tt>function GradToRad(grad : real) : real;</tt></b>
<p>
Funkcja GradToRad przelicza warto¶æ k±ta wyra¿onego w gradach na k±t wyra¿ony w radianach.
</p>
	</td>
</tr>

<tr>
	<td><tt><b>InRange</td>
	<td><tt>
<b><tt>function InRange(const AValue, AMin, AMax: byte): Boolean;<br />function InRange(const AValue, AMin, AMax: Integer): Boolean;</tt></b>
<p>
</p>
	</td>
</tr>


<tr>
	<td><tt><b>IsNan</td>
	<td><tt>
<b><tt>function IsNan(const d : Single): Boolean;</tt></b>
<p>
Funkcja sprawdza czy warto¶æ parametru D jest poprawn± liczb±.
</p>
	</td>
</tr>


<tr>
	<td><tt><b>Log2</td>
	<td><tt>
<b><tt>function log2(x : single): single;</tt></b>
<p>
Funkcja zwraca warto¶æ logarytmu przy podstawie 2 dla parametru rzeczywistego X>0.
</p>
	</td>
</tr>


<tr>
	<td><tt><b>Log10</td>
	<td><tt>
<b><tt>function log10(x : single): single;</tt></b>
<p>
Funkcja zwraca warto¶æ logarytmu dziesiêtnego (logarytmu przy podstawie 10) dla parametru rzeczywistego X>0.
</p>
	</td>
</tr>


<tr>
	<td><tt><b>LogN</td>
	<td><tt>
<b><tt>function logN(n,x : single): single;</tt></b>
<p>
Funkcja zwraca warto¶æ logarytmu przy podstawie N>0 dla parametru rzeczywistego X>0.
</p>
	</td>
</tr>



<tr>
	<td><tt><b>Max</td>
	<td><tt>
<b><tt>function Max(a, b: real): real;<br />function Max(a, b: integer): integer;</tt></b>
<p>
Przeci±¿ona funkcja porównuje warto¶ci dwóch parametrów: A i B, oraz zwraca ten, który jest wiêkszy.
</p>
	</td>
</tr>

<tr>
	<td><tt><b>Min</td>
	<td><tt>
<b><tt>function Min(a, b: real): real;<br />function Min(a, b: integer): integer;</tt></b>
<p>
Przeci±¿ona funkcja porównuje warto¶ci dwóch parametrów A i B, oraz zwraca warto¶æ tego który jest mniejszy.
</p>
	</td>
</tr>

<tr>
	<td><tt><b>Power</td>
	<td><tt>
<b><tt>function Power(base : real; const exponent : shortint): real;<br />power(base : integer; const exponent : shortint): integer;</tt></b>
<p>
Funkcja podnosi liczbê A do dowolnej potêgi N, potêga mo¿e byæ u³amkiem.
</p>
	</td>
</tr>

<tr>
	<td><tt><b>RadToCycle</td>
	<td><tt>
<b><tt>function RadToCycle(rad : real) : real;</tt></b>
<p>
Funkcja RadToCycle przelicza warto¶æ k±ta wyra¿onego w radianach na k±t wyra¿ony w cyklach (obrotach).
</p>
	</td>
</tr>

<tr>
	<td><tt><b>RadToDeg</td>
	<td><tt>
<b><tt>function RadToDeg(rad : real) : real;</tt></b>
<p>
Funkcja RadToDeg przelicza warto¶æ k±ta wyra¿onego w radianach na k±t wyra¿ony w stopniach (deg).
</p>
	</td>
</tr>

<tr>
	<td><tt><b>RadToGrad</td>
	<td><tt>
<b><tt>function RadToGrad(rad : real) : real;</tt></b>
<p>
Funkcja RadToGrad przelicza warto¶æ k±ta wyra¿onego w radianach na k±t wyra¿ony w gradach.
</p>
	</td>
</tr>

<tr>
	<td><tt><b>RandG</td>
	<td><tt>
<b><tt>function RandG(mean, stddev : single) : single;</tt></b>
<p>
RandG reprezentuje generator liczb pseudolosowych o rozk³adzie Gaussa wokó³ ¶redniej Mean. Parametr StdDev jest odchyleniem standardowym generowanych liczb od warto¶ci ¶redniej (Mean).
</p>
	</td>
</tr>

<tr>
	<td><tt><b>RandomRange</td>
	<td><tt>
<b><tt>function RandomRange(const aFrom, aTo: smallint): smallint;</tt></b>
<p>
Funkcja zwraca losow± liczbê z przedzia³u AFrom - ATo (³±cznie z warto¶ci± ATo).
</p>
	</td>
</tr>

<tr>
	<td><tt><b>RandomRangeF</td>
	<td><tt>
<b><tt>function RandomRangeF(const min, max: single): single;</tt></b>
<p>
</p>
	</td>
</tr>

<tr>
	<td><tt><b>Tan</td>
	<td><tt>
<b><tt>function Tan(x: Real): Real;</tt></b>
<p>
Funkcja zwraca warto¶æ tangensa k±ta podanego w parametrze X.
</p>
	</td>
</tr>

</table>

<p></p>
<br />


<A NAME="change">
</tt><h2>HISTORIA</h2></tt>


<p class="tekst-wiekszy">
1.6.3
<p class="tekst">
- poprawki, optymalizacje
- SYSUTILS: Trim<br>
- SYSTEM: PByte, PByteArray, PWord<br>
- GRAPH, FASTGRAPH: TFrameBuffer, DisplayBuffer, FrameBuffer, SwitchBuffer, Scanline<br>
- BLIBS: unit GR10PP<br>
- LIB: unit GR4PP<br>

<p class="tekst-wiekszy">
1.6.0 - 1.6.2
<p class="tekst">
- nowy unit EFAST dla przyspieszenia wyprowadzania znaków na urz±dzenie E:<br>
- SYSTEM: function Copy(var S: String; Index: Byte; Count: Byte): String;<br>
- SYSTEM: Palette, HPalette<br>
- dodana obs³uga tablic jednowymiarowych typu ^RECORD (wskaznik do rekordu)<br>
- optymalizacja bloków warunkowych, generowany jest mo¿liwie najkrótszy, najszybszy kod wynikowy<br>
- dodany typ PChar, https://www.freepascal.org/docs-html/rtl/system/pchar.html<br>
- dodana mo¿liwo¶æ zwracania warto¶ci funkcji przez typ wyliczeniowy<br>
- dodany nowy prze³±cznik -define:symbol<br>
- dodany nowy prze³±cznik -ipath:includepath<br>


<p class="tekst-wiekszy">
1.5.9 - 1.6.0
<p class="tekst">
- SYSTEM: TDateTime<br>
- GRAPH, FASTGRAPH: Arc, PieSlice, TLastArcCoords, LastArcCoords<br>
- SYSUTILS: Now, Date, DateToStr, DecodeDate, DecodeDateTime, DecodeTime, EncodeDate, EncodeDateTime, EncodeTime, IsLeapYear, BoolToStr, StrToBool<br>
- STRUTILS: AddChar, AddCharR, PadLeft, PadRight<br>
- dodana obs³uga {$INCLUDE %DATE%}, {$INCLUDE %TIME%}, https://www.freepascal.org/docs-html/prog/progsu41.html<br>
- prze³±czniki -CODE:, -DATA:, -STACK:, -ZPAGE: domy¶lnie wymagaj± podania warto¶ci HEX bez znaku pocz±tkowego '$'<br>

<p class="tekst-wiekszy">
1.5.8
<p class="tekst">
- GRAPHICS: Font, FontInitialize, FillRect, TextOut, TextWidth, MoveTo, LineTo<br>
- SYSTEM: FileMode (RESET), [fmOpenRead, fmOpenWrite, fmOpenAppend, fmOpenReadWrite]<br>
- dodana obs³uga dyrektyw {$info user_defined}, {$warning user_defined}, {$error user_defined}, {$include filename}, {$resource filename}<br>
- akceptuje zapis PROGRAM (par1, par2 ...)<br>
- poprawione FillFlood, dodane FillFloodH (wype³nianie poziomymi liniami)<br>
- kompilator generuje krótszy kod gdy procedura/funkcja nie ma parametrów<br>
- dostêp do definicji .DEFINE z poziomu ASM, MAIN.@DEFINES.nazwa<br>
- procedury/funkcje INTERRUPT niezale¿nie czy zostan± u¿yte kompilator zawsze wygeneruje dla nich kod<br>
- poprawiona optymalizacja bloków REPEAT UNTIL<br>
- dodana informacja o czasie kompilacji<br>
- dodana obs³uga inicjalizacji tablic dwuwymiarowych sta³ych i zmiennych<br>

<p class="tekst-wiekszy">
1.5.6 - 1.5.7
<p class="tekst">
- SYSUTILS: Click<br>
- SYSTEM: Sqrt(Integer): Single<br>
- MATH: Sign<br>
- dodana mo¿liwo¶æ u¿ycia nazwy funkcji dla zwracanej warto¶ci, dotychczas tylko przez RESULT<br>
- dodana obs³uga tablic typu STRING<br>
- dodana obs³uga dyrektywy {$LIBRARYPATH path1;path2;...}<br>
- nowa biblioteka BLIBS<br>
- nowa dokumentacja dla LIB, BLIBS wygenerowana przez PASDOC (https://gitlab.com/bocianu/pasdoc)<br>


<p class="tekst-wiekszy">
1.5.3 - 1.5.5
<p class="tekst">
- CRT: TextMode<br>
- SYSUTILS: ExtractFilePath<br>
- SYSTEM: EoLn<br>
- dodana obs³uga linii poleceñ z poziomu DOS II/D dla ParamCount, ParamStr<br>
- OBJECT, mo¿na zdefiniowaæ je bez zmiennych, tylko same metody<br>
- OBJECT, mo¿na wywo³aæ metodê z poziomu metody<br>
- dodana automatyczna konwersja wyra¿eñ typu INTEGER na REAL<br>

<p class="tekst-wiekszy">
1.5.2
<p class="tekst">
- nowy typ FLOAT jako odpowiednik typu SINGLE<br>
- SYSTEM unti: FileSize (SDX)<br>
- SYSTEM unit: EXP:Single, LN:Single, LN:Real, EXP:Real (wysoka precyzja obliczeñ)<br>
- SYSUTILS unit: AnsiUpperCase, ExtractFileExt<br>
- TYPES unit: Bounds, CenterPoint, EqualRect, InflateRect, IntersectRect, IsRectEmpty, NormalizeRect, OffsetRect, Point, PointsEqual, PtInRect, PtInEllipse, Rect, RectWidth, RectHeight, Size, UnionRect<br>
- IMAGE unit: LoadMIC, LoadPIC, LoadBMP, LoadPCX, LoadGIF<br>
- VIMAGE unit: LoadVBMP, LoadVPCX, LoadVGIF<br>
- GRAPH, FASTGRAPH unit: SetClipRect, ClipLine, FillRect(TRect), Rectangle(TRect)<br>


<p class="tekst-wiekszy">
1.5.1
<p class="tekst">
- dodane nowe prze³±czniki -CODE:$address, -DATA:$address -STACK:$address, -ZPAGE:$address<br>
- SYSTEM unit: RandomF (Result as Single), VAL (Integer, Single)<br>
- GRAPH, FASTGRAPH unit: Bar, Bar3D, GetX, GetY, MoveRel, FloodFill<br>
- MATH unit: RandomRange, RandomRangeF, RandG (gaussian distributed random number)<br>
- CRT unit: SOUND (dzia³a identycznie jak SOUND w Atari BASIC)<br>
- VBXE unit: TVBXEMemoryStream<br>
- dodany komunikat ostrze¿enia 'Comparison might be always true/false due to range of constant and expression'<br>
- zasoby RCASM, CMCPLAY, MPTPLAY mo¿na teraz ³adowaæ pod ROM<br>
- dodana mo¿liwo¶æ oznaczenia kodowania ci±gu znakowego jako internal ANTIC-a poprzez znak tyldy '~', np.:
<pre>
 txt0: string = 'Atari'~;      // ci±g w kodach ANTIC-a
 txt1: string = 'Spectrum'*~;  // ci±g w inwersie w kodach ANTIC-a
</pre>

<p class="tekst-wiekszy">
1.5.0
<p class="tekst">
- poprawiona i uzupe³niona inicjalizacja tablic typu POINTER<br>
- poprawiona i uzupe³niona inicjalizacja zmiennych typu wyliczeniowego<br>
- wprowadzony typ LONGWORD, DWORD, UINT32 jako odpowiednik CARDINAL<br>
- wprowadzony typ LONGINT jako odpowiednik INTEGER<br>
- zreorganizowane typy rzeczywiste, typ ShortReal (fixed point Q8.8), Real (fixed point Q24.8), Single (32bit IEEE-754)<br>
- unit SYSTEM (const SINGLE): NaN, Infinity, NegInfinity<br>
- unit SYSTEM (type SINGLE): SIN, COS, ABS, SQRT, ISQRT, ROUND, TRUNC<br>
- unit MATH (type SINGLE): LOG2, LOG10, LOGN, IsNaN<br>
- dla WRITE/WRITELN akceptowane i ingorowane jest formatowanie wyniku, np.: writeln(f:8:8)<br>


<p class="tekst-wiekszy">
1.4.8 / 1.4.9
<p class="tekst">
- zmniejszenie wska¼nika stosu programowego w przypadku wywo³ania funkcji bez odebrania jej warto¶ci<br>
- lepsza ocena mo¿liwo¶ci ustalenia adresu sta³ej/zmiennej, dodany komunikat "Can't take the address of constant expressions"<br>


<p class="tekst-wiekszy">
1.4.7
<p class="tekst">
- optymalizacja dla imulBYTE, imulWORD, imulCARD, mulSHORTINT, mulSMALLINT, mulINTEGER<br>
- dodana obs³uga wska¼nika rekordu, np.:
<pre>
type
	TPoint = record x,y: smallint end;
var
	a,b: ^TPoint;
begin
	a^.y := b^.x;
	a^ := b^;
end.
</pre>
<p class="tekst">
- dodana obs³uga sekcji INITIALIZATION w modu³ach UNIT<br>
- dodany nowy typ EXTMEM dla pliku resource $R, pozwalajacy ³adowaæ dane do pamiêci dodatkowej<br>
- dodany nowy typ OBJECT, czyli RECORD z dodatkowymi metodami
<pre>
type
	TMemoryStream = Object

	Position: cardinal;
	Size: cardinal;
	
	procedure Create;
	procedure ReadBuffer(var Buffer; Count: word);
	procedure WriteBuffer(var Buffer; Count: word);

	end;
</pre>
<p class="tekst">
- poprawione biblioteki CMC, MPT, RMT<br>


<p class="tekst-wiekszy">
1.4.6
<p class="tekst">
- dodana obs³uga dyrektyw warunkowych $IFDEF, $IFNDEF, $ELSE, $ENDIF, $DEFINE, $UNDEF przez DMSC
<pre>
{$define test}

const
	{$ifdef test}
	a=1;
	{$else}
	a=2;
	{$endif}
</pre>
<p class="tekst">
- dodana mo¿liwo¶æ przekazania warto¶ci funkcji przez EXIT(expression)<br>
- dodana podstawowa implementacja dla typu wyliczeniowego (w pliku wynikowym nie s± zapisywane nazwy etykiet)<br>
- dodana obs³uga tablic dwuwymiarowych<br>


<p class="tekst-wiekszy">
1.4.4/1.4.5
<p class="tekst">
- poprawione porównanie typów tego samego rozmiaru ale o przeciwnych znakach<br>
- dodana mo¿liwo¶æ u¿ycia klauzuli USES w blokach modu³ów UNIT<br>
- dodany wymóg deklaracji funkcji/procedur w sekcji INTERFACE modu³ów UNIT<br>
- poprawione zauwa¿one b³êdy optymalizatora<br>


<p class="tekst-wiekszy">
1.4.3
<p class="tekst">
- dodana mo¿liwo¶æ zwrócenia warto¶ci funkcji przez RECORD, np:
<pre>
  var p: TPoint;

  p:=Point(x,y);
</pre>
<p class="tekst">
- {$f page} FAST_MUL, procedury szybkiego mno¿enia dla BYTE, SHORTINT, WORD, SMALLINT, SINGLE<br>
- SYSTEM: ReadConfig, ReadSector, WriteSector<br>
- SYSTEM: Point, Rect, Bounds, PointsEqual<br>
  (https://github.com/graemeg/freepascal/blob/577d99e594f4958bad4f343fb419b8dddda2ebe6/rtl/objpas/classes/classes.inc)<br>
- DOS: CurrentMinuteOfDay, CurrentSec100OfDay, CurrentSecondOfDay, MinuteOfDay, MinutesToTime, SecondOfDay, SecondsToTime<br>
  (https://github.com/graemeg/freepascal/blob/master/packages/fv/src/time.pas#L309)<br>
- MATH: Power, ArcTan2, InRange, EnsureRange, CycleToRad, DegNormalize, DegToGrad, DegToRad, DivMod, GradToDeg, GradToRad, RadToCycle, RadToDeg, RadToGrad<br>
  (https://github.com/graemeg/freepascal/blob/master/rtl/objpas/math.pp)<br>
- nowy typ LABEL<br>
- dodana obs³uga GOTO label


<p class="tekst-wiekszy">
1.4.1 / 1.4.2
<p class="tekst">
- optymalizacja kodu wynikowego 6502 generowanego dla pêtli FOR<br>
- poprawiony odczyt plików include i resource<br>
- MISC: DetectCPUSpeed<br>
- dodatkowy typ danych rzeczywistych SINGLE <-128..127>


<p class="tekst-wiekszy">
1.4.0
<p class="tekst">
- w parametrach formalnych procedur i funkcji dodana mo¿liwo¶æ podania typu UNTYPED (tylko przez VAR), np.
<pre>
 procedure move(var x,y; count: word);
 begin
 end;

 move(tab[100], tab[200], 50);
</pre>
<p class="tekst">
- SYSTEM: poprawki dla FILLCHAR, FILLBYTE, MOVE
<pre>
 fillchar(pointer($bc40+40*8), 100, ord('a')); 
 fillchar(scr[40*8], 100, ord('a'));            // teraz takie wywo³anie te¿ jest mo¿liwe
</pre>
<p class="tekst">
- funkcja INTTOREAL usuniêta, zast±piona przez wbudowan± konwersjê typu REAL, np.
<pre>
 var f: real;
     i: word;

 f:=real(i);
</pre>
<p class="tekst">
- FASTGRAPH: SetClipRect, ClipLine (Cohen-Sutherland algorithm)<br>
- poprawki dla {$i filename}, poprawne liczenie linii kompilowanego programu


<p class="tekst-wiekszy">
1.3.8
<p class="tekst">
- SYSTEM: RANDOM(RANGE: BYTE): BYTE; RANDOM(RANGE: INTEGER): SMALLINT;<br>
- CRT: WHEREX, WHEREY<br>
- SYSUTILS: BEEP<br>
- dodatkowy znak * po apostrofie '' oznacza inwers znaków, np.:
<pre>
 writeln('inwers'*'bez inwersu');
</pre>


<p class="tekst-wiekszy">
1.3.7
<p class="tekst">
- dodana mo¿liwo¶æ ³adowania bloku resource {$R} pod adres tablicy


<p class="tekst-wiekszy">
1.3.6
<p class="tekst">
- dodane rozkazy GetIntVec, SetIntVec w zastêpstwie rozkazu Intr<br>
- umo¿liwione zwracanie warto¶ci RESULT dla funkcji poprzez tablice<br>
- poprawki dla MOVE (downwards, upwards)<br>
- optymalizacja ASM dla procedur/funkcji POKE, DPOKE, PEEK, DPEEK, FILLCHAR, MOVE, INTTOREAL<br>
- SYSTEM: ParamCount, ParamStr (SDX, BWDOS)<br>


<p class="tekst-wiekszy">
1.3.5
<p class="tekst">
- dodana mo¿liwo¶æ odczytu adresu sta³ej, np.:
<pre>
  const tb: array [0..0] of byte = ( lo(word(@tb)) );
</pre>
<p class="tekst">
- dodany odczyt wektorów DLI, VBL przez rozkaz INTR
<pre>
  intr(rVBL, label);
  intr(rDLI, label);
</pre>

	
<p class="tekst-wiekszy">
1.3.4
<p class="tekst">
- dodana dodatkowa informacja o zajmowanej pamiêci przez kolejne kompilowane modu³y<br>
- dodany nowy modu³ VBXE (tryb OVERLAY, BLITTER)<br>
- dodana obs³uga b³êdów dla operacji I/O {I+} {I-} IOCHECK ON/OFF<br>
- dwie dodatkowe poprawki Greblusa dla $I, $R z my¶l± o dzia³aniu w ¶rodowisku Linuxa<br>


<p class="tekst-wiekszy">
1.3.3
<p class="tekst">
- Greblus doda³ poprawki umo¿liwiaj±ce dzia³anie kompilatora z Linux-em<br>
- dodana mo¿liwo¶æ zaincjowania wska¼nika
<pre>
	tmp: byte;
	p: pointer = @tmp;
	a: ^byte = @tmp;
</pre>
<p class="tekst">
- dodana mo¿liwo¶æ przypisania rekordu
<pre>
type a = record x,y: byte end;
var k,w: a;

	k:=w;
</pre>
<p class="tekst">
- GRAPH: SetVideoBank, SetColorMapDimensions, SetColorMapEntry<br>
- VBXE: GetXDL, SetXDL, RunBlit, ClrVideoBank<br>


<p class="tekst-wiekszy">
1.3.2
<p class="tekst">
- DOS: GetTime, SetTime<br>
- MATH: Ceil<br>
- SYSUTILS: GetTickCount<br>
- FindFirst ... obs³uga Attributes<br>
- wbudowanie funkcji w kompilator: INT, FRAC, TRUNC, ROUND, ODD<br>

<p class="tekst-wiekszy">
1.3.1
<p class="tekst">
- dodana obs³uga rekordów RECORD<br>
- {$i filename}<br>
- {$r filename}, Resource Type: RCDATA, DOSFILE, RELOC, RMT, MPT, CMC<br>
- dodany prze³±cznik -o Optimize code<br>
- mo¿liwo¶æ wymuszenia typu dla CONST<br>
<pre>
  const
      a: word = 5;     // WORD
      b = 5;           // BYTE
</pre>
<p class="tekst">
- dodana obs³uga modyfikatorów INTERRUPT, FORWARD, REGISTER dla procedur i funkcji<br>
- dodana obs³uga mapy kolorów (40x30x8x8) VBXE (modu³ GRAPH, CRT), SetColorMap, SetColorCell, SetVideoBank<br>
- SYSUTILS: TSearchRec, FindFirst, FindNext, FindClose<br>
- GRAPH, FASTGRAPH: FillRect, FillEllipse<br>
- SYSTEM: ODD, INT, LOW, HIGH, SIZEOF, INTR (INTERRUPT_NUMBER), BinStr, OctStr, HexStr, Pause, Sound, NoSound, Concat<br>
- RMT: RMTINIT, RMTPLAY, RMTSTOP<br>
- MPT: MPTINIT, MPTPLAY, MPTSTOP<br>
- CMC: CMCINIT, CMCPLAY, CMCSTOP<br>

</html>