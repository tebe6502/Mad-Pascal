<html>
<head>
	<link rel='stylesheet' type='text/css' href='pasdoc.css'>
	<title>unit system - reference</title>
</head>
<body>

<!--********************* HEADER **************************-->

<h1>unit system</h1>
<h3>Standard supported functions of Mad Pascal</h3>
<p>author: Tomasz Biela (Tebe)</p>
<br><p><a href='http://www.freepascal.org/docs-html/rtl/system/index-5.html'>http://www.freepascal.org/docs-html/rtl/system/index-5.html</a></p>

<!--********************* CONSTANTS **************************-->

<h2>Constants:</h2>
<table class='consts'>
<tr><th>name:</th><th>value:</th><th>description:</th></tr>

<tr><td class='tname'>__PORTB_BANKS</td><td class='tvalue'>$0101</td><td class='tdesc'>memory banks array</td></tr>
<tr><td class='tname'>M_PI_2</td><td class='tvalue'>pi*2</td><td class='tdesc'></td></tr>
<tr><td class='tname'>D_PI_2</td><td class='tvalue'>pi/2</td><td class='tdesc'></td></tr>
<tr><td class='tname'>D_PI_180</td><td class='tvalue'>pi/180</td><td class='tdesc'></td></tr>
<tr><td class='tname'>mGTIA</td><td class='tvalue'>0</td><td class='tdesc'></td></tr>
<tr><td class='tname'>mVBXE</td><td class='tvalue'>$80</td><td class='tdesc'></td></tr>
<tr><td class='tname'>//	WINDOW</td><td class='tvalue'>$10</td><td class='tdesc'>text window</td></tr>
<tr><td class='tname'>//	NARROW</td><td class='tvalue'>$20</td><td class='tdesc'>narrow screen</td></tr>
<tr><td class='tname'>VBXE_XDLADR</td><td class='tvalue'>$0000</td><td class='tdesc'>XDLIST</td></tr>
<tr><td class='tname'>VBXE_BCBTMP</td><td class='tvalue'>$00E0</td><td class='tdesc'>BLITTER TEMP</td></tr>
<tr><td class='tname'>VBXE_BCBADR</td><td class='tvalue'>$0100</td><td class='tdesc'>BLITTER LIST ADDRESS</td></tr>
<tr><td class='tname'>VBXE_MAPADR</td><td class='tvalue'>$1000</td><td class='tdesc'>COLOR MAP ADDRESS</td></tr>
<tr><td class='tname'>VBXE_CHBASE</td><td class='tvalue'>$1000</td><td class='tdesc'>CHARSET BASE ADDRESS</td></tr>
<tr><td class='tname'>VBXE_OVRADR</td><td class='tvalue'>$5000</td><td class='tdesc'>OVERLAY ADDRESS</td></tr>
<tr><td class='tname'>VBXE_WINDOW</td><td class='tvalue'>$B000</td><td class='tdesc'>4K WINDOW $B000..$BFFF</td></tr>
<tr><td class='tname'>iDLI</td><td class='tvalue'>0</td><td class='tdesc'>set new DLI vector</td></tr>
<tr><td class='tname'>iVBL</td><td class='tvalue'>1</td><td class='tdesc'>set new VBL vector</td></tr>
<tr><td class='tname'>iTIM1</td><td class='tvalue'>2</td><td class='tdesc'>set new IRQ TIMER1 vector</td></tr>
<tr><td class='tname'>iTIM2</td><td class='tvalue'>3</td><td class='tdesc'>set new IRQ TIMER2 vector</td></tr>
<tr><td class='tname'>iTIM4</td><td class='tvalue'>4</td><td class='tdesc'>set new IRQ TIMER4 vector</td></tr>
<tr><td class='tname'>CH_DELCHR</td><td class='tvalue'>chr($FE)</td><td class='tdesc'>delete char under the cursor</td></tr>
<tr><td class='tname'>CH_ENTER</td><td class='tvalue'>chr($9B)</td><td class='tdesc'></td></tr>
<tr><td class='tname'>CH_ESC</td><td class='tvalue'>chr($1B)</td><td class='tdesc'></td></tr>
<tr><td class='tname'>CH_CURS_UP</td><td class='tvalue'>chr(28)</td><td class='tdesc'></td></tr>
<tr><td class='tname'>CH_CURS_DOWN</td><td class='tvalue'>chr(29)</td><td class='tdesc'></td></tr>
<tr><td class='tname'>CH_CURS_LEFT</td><td class='tvalue'>chr(30)</td><td class='tdesc'></td></tr>
<tr><td class='tname'>CH_CURS_RIGHT</td><td class='tvalue'>chr(31)</td><td class='tdesc'></td></tr>
<tr><td class='tname'>CH_TAB</td><td class='tvalue'>chr($7F)</td><td class='tdesc'>tabulator</td></tr>
<tr><td class='tname'>CH_EOL</td><td class='tvalue'>chr($9B)</td><td class='tdesc'>end-of-line marker</td></tr>
<tr><td class='tname'>CH_CLR</td><td class='tvalue'>chr($7D)</td><td class='tdesc'>clear screen</td></tr>
<tr><td class='tname'>CH_BELL</td><td class='tvalue'>chr($FD)</td><td class='tdesc'>bell</td></tr>
<tr><td class='tname'>CH_DEL</td><td class='tvalue'>chr($7E)</td><td class='tdesc'>back space (delete char to the left)</td></tr>
<tr><td class='tname'>CH_DELLINE</td><td class='tvalue'>chr($9C)</td><td class='tdesc'>delete line</td></tr>
<tr><td class='tname'>CH_INSLINE</td><td class='tvalue'>chr($9D)</td><td class='tdesc'>insert line</td></tr>
<tr><td class='tname'>PAL_PMCOLOR0</td><td class='tvalue'>0</td><td class='tdesc'>palette index Palette[..] , HPalette[..]</td></tr>
<tr><td class='tname'>PAL_PMCOLOR1</td><td class='tvalue'>1</td><td class='tdesc'></td></tr>
<tr><td class='tname'>PAL_PMCOLOR2</td><td class='tvalue'>2</td><td class='tdesc'></td></tr>
<tr><td class='tname'>PAL_PMCOLOR3</td><td class='tvalue'>3</td><td class='tdesc'></td></tr>
<tr><td class='tname'>PAL_COLOR0</td><td class='tvalue'>4</td><td class='tdesc'></td></tr>
<tr><td class='tname'>PAL_COLOR1</td><td class='tvalue'>5</td><td class='tdesc'></td></tr>
<tr><td class='tname'>PAL_COLOR2</td><td class='tvalue'>6</td><td class='tdesc'></td></tr>
<tr><td class='tname'>PAL_COLOR3</td><td class='tvalue'>7</td><td class='tdesc'></td></tr>
<tr><td class='tname'>PAL_COLBAK</td><td class='tvalue'>8</td><td class='tdesc'></td></tr>
<tr><td class='tname'>COLOR_BLACK</td><td class='tvalue'>$00</td><td class='tdesc'></td></tr>
<tr><td class='tname'>COLOR_WHITE</td><td class='tvalue'>$0e</td><td class='tdesc'></td></tr>
<tr><td class='tname'>COLOR_RED</td><td class='tvalue'>$32</td><td class='tdesc'></td></tr>
<tr><td class='tname'>COLOR_CYAN</td><td class='tvalue'>$96</td><td class='tdesc'></td></tr>
<tr><td class='tname'>COLOR_VIOLET</td><td class='tvalue'>$68</td><td class='tdesc'></td></tr>
<tr><td class='tname'>COLOR_GREEN</td><td class='tvalue'>$c4</td><td class='tdesc'></td></tr>
<tr><td class='tname'>COLOR_BLUE</td><td class='tvalue'>$74</td><td class='tdesc'></td></tr>
<tr><td class='tname'>COLOR_YELLOW</td><td class='tvalue'>$ee</td><td class='tdesc'></td></tr>
<tr><td class='tname'>COLOR_ORANGE</td><td class='tvalue'>$28</td><td class='tdesc'></td></tr>
<tr><td class='tname'>COLOR_BROWN</td><td class='tvalue'>$e4</td><td class='tdesc'></td></tr>
<tr><td class='tname'>COLOR_LIGHTRED</td><td class='tvalue'>$3c</td><td class='tdesc'></td></tr>
<tr><td class='tname'>COLOR_GRAY1</td><td class='tvalue'>$04</td><td class='tdesc'></td></tr>
<tr><td class='tname'>COLOR_GRAY2</td><td class='tvalue'>$06</td><td class='tdesc'></td></tr>
<tr><td class='tname'>COLOR_GRAY3</td><td class='tvalue'>$0a</td><td class='tdesc'></td></tr>
<tr><td class='tname'>COLOR_LIGHTGREEN</td><td class='tvalue'>$cc</td><td class='tdesc'></td></tr>
<tr><td class='tname'>COLOR_LIGHTBLUE</td><td class='tvalue'>$7c</td><td class='tdesc'></td></tr>
<tr><td class='tname'>fmOpenRead</td><td class='tvalue'>$04</td><td class='tdesc'></td></tr>
<tr><td class='tname'>fmOpenWrite</td><td class='tvalue'>$08</td><td class='tdesc'></td></tr>
<tr><td class='tname'>fmOpenAppend</td><td class='tvalue'>$09</td><td class='tdesc'></td></tr>
<tr><td class='tname'>fmOpenReadWrite</td><td class='tvalue'>$0c</td><td class='tdesc'></td></tr>
<tr><td class='tname'>threehalfs: single</td><td class='tvalue'>1.5</td><td class='tdesc'></td></tr>

</table>

<!--********************* TYPES **************************-->

<h2>Types:</h2>
<table class='types'>
<tr><th>name:</th><th>type:</th><th>description:</th></tr>

<tr><td class='tname'>TString</td><td class='ttype'>string[32]</td><td class='tdesc'></td></tr>
<tr><td class='tname'>TSize</td><td class='ttype'>record cx, cy: smallint end</td><td class='tdesc'>TSize is a type to describe the size of a rectangular area, where cx is the width, cy is the height (in pixels) of the rectangle.</td></tr>
<tr><td class='tname'>TRect</td><td class='ttype'>record	left, top, right, bottom: smallint end</td><td class='tdesc'>TRect is a type to describe a rectangular area.</td></tr>
<tr><td class='tname'>TPoint</td><td class='ttype'>record x,y: SmallInt end</td><td class='tdesc'>This record describes a coordinate.</td></tr>
<tr><td class='tname'>TDateTime</td><td class='ttype'>record yy,mm,dd,h,m,s: byte end</td><td class='tdesc'>This record describes Date-Time.</td></tr>
<tr><td class='tname'>TLastArcCoords</td><td class='ttype'>record x,y,xstart,ystart,xend,yend: smallint end</td><td class='tdesc'></td></tr>
<tr><td class='tname'>PBoolean</td><td class='ttype'>^Boolean</td><td class='tdesc'></td></tr>
<tr><td class='tname'>PByte</td><td class='ttype'>^byte</td><td class='tdesc'></td></tr>
<tr><td class='tname'>PWord</td><td class='ttype'>^word</td><td class='tdesc'></td></tr>
<tr><td class='tname'>PLongWord</td><td class='ttype'>^cardinal</td><td class='tdesc'></td></tr>
<tr><td class='tname'>PCardinal</td><td class='ttype'>^cardinal</td><td class='tdesc'></td></tr>
<tr><td class='tname'>PSmallint</td><td class='ttype'>^smallint</td><td class='tdesc'></td></tr>
<tr><td class='tname'>PInteger</td><td class='ttype'>^integer</td><td class='tdesc'></td></tr>
<tr><td class='tname'>PSingle</td><td class='ttype'>^single</td><td class='tdesc'></td></tr>
<tr><td class='tname'>PFloat16</td><td class='ttype'>^float16</td><td class='tdesc'></td></tr>
<tr><td class='tname'>PString</td><td class='ttype'>^string</td><td class='tdesc'></td></tr>
<tr><td class='tname'>PByteArray</td><td class='ttype'>^byte</td><td class='tdesc'></td></tr>
<tr><td class='tname'>PWordArray</td><td class='ttype'>^word</td><td class='tdesc'></td></tr>

</table>

<!--********************* ABSOLUTE VARIABLES **************************-->

<h2>Register Variables:</h2>
<table class='registers'>
<tr><th>name:</th><th>address:</th><th>type:</th><th>description:</th></tr>

<tr><td class='tname'>[volatile] Rnd</td><td class='taddress'>$d20a</td><td class='ttype'>byte</td><td class='tdesc'></td></tr>
<tr><td class='tname'>Palette</td><td class='taddress'>704</td><td class='ttype'>array [0..8] of byte</td><td class='tdesc'></td></tr>
<tr><td class='tname'>HPalette</td><td class='taddress'>$d012</td><td class='ttype'>array [0..8] of byte</td><td class='tdesc'></td></tr>

</table>

<!--********************* GLOBAL VARIABLES **************************-->

<h2>Global Variables:</h2>
<table class='variables'>
<tr><th>name:</th><th>type:</th><th>description:</th></tr>

<tr><td class='tname'>ScreenWidth</td><td class='ttype'>smallint = 40</td><td class='tdesc'>current screen width</td></tr>
<tr><td class='tname'>ScreenHeight</td><td class='ttype'>smallint = 24</td><td class='tdesc'>current screen height</td></tr>
<tr><td class='tname'>GraphMode</td><td class='ttype'>byte</td><td class='tdesc'>current screen mode</td></tr>
<tr><td class='tname'>IOResult</td><td class='ttype'>byte</td><td class='tdesc'>result of last file IO operation</td></tr>
<tr><td class='tname'>EoLn</td><td class='ttype'>Boolean</td><td class='tdesc'>end of line status</td></tr>

</table>

<!--********************* INTERFACE **************************-->

<h2>Interface:</h2>
<table class='interface'>
<tr><th>name:</th><th>description:</th></tr>

<tr><td class='tname fname'>RunError</td><td class='tdesc'><h4>procedure RunError(a: byte);</h4><br>
	Print error message<br><ul><h5>parameters:</h5><li>a - error number</li></ul></td></tr>
<tr><td class='tname fname'>HexStr</td><td class='tdesc'><h4>function HexStr(Value: cardinal; Digits: byte): TString; register; assembler;</h4><br>
	Convert cardinal value to string with hexadecimal representation.<br><ul><h5>parameters:</h5><li>Value</li><li>Digits</li><h5>returns:</h5><li class='returns'>string[32]</li></ul></td></tr>
<tr><td class='tname fname'>Peek</td><td class='tdesc'><h4>function Peek(a: word): byte; register; stdcall; assembler;</h4><br>
	Reads BYTE from the desired memory address<br><ul><h5>parameters:</h5><li>a - memory address</li><h5>returns:</h5><li class='returns'>byte</li></ul></td></tr>
<tr><td class='tname fname'>DPeek</td><td class='tdesc'><h4>function DPeek(a: word): word; register; stdcall; assembler;</h4><br>
	Reads WORD from the desired memory address<br><ul><h5>parameters:</h5><li>a - memory address</li><h5>returns:</h5><li class='returns'>word</li></ul></td></tr>
<tr><td class='tname fname'>Abs</td><td class='tdesc'><h4>function Abs(x: Real): Real; register; assembler; overload;</h4><br>
	Abs returns the absolute value of a variable. <br> The result of the function has the same type as its argument, which can be any numerical type.<br><ul><h5>parameters:</h5><li>x - Real (Q24.8)</li><h5>returns:</h5><li class='returns'>Real (Q24.8)</li></ul></td></tr>
<tr><td class='tname fname'>Abs</td><td class='tdesc'><h4>function Abs(x: Single): Single; register; assembler; overload;</h4><br>
	Abs returns the absolute value of a variable. <br> The result of the function has the same type as its argument, which can be any numerical type.<br><ul><h5>parameters:</h5><li>x - Single</li><h5>returns:</h5><li class='returns'>Single</li></ul></td></tr>
<tr><td class='tname fname'>Abs</td><td class='tdesc'><h4>function Abs(x: float16): float16; register; assembler; overload;</h4><br>
	Abs returns the absolute value of a variable. <br> The result of the function has the same type as its argument, which can be any numerical type.<br><ul><h5>parameters:</h5><li>x - Single</li><h5>returns:</h5><li class='returns'>Single</li></ul></td></tr>
<tr><td class='tname fname'>Abs</td><td class='tdesc'><h4>function Abs(x: shortint): shortint; register; assembler; overload;</h4><br>
	Abs returns the absolute value of a variable. <br> The result of the function has the same type as its argument, which can be any numerical type.<br><ul><h5>parameters:</h5><li>x - shortint</li><h5>returns:</h5><li class='returns'>shortint</li></ul></td></tr>
<tr><td class='tname fname'>Abs</td><td class='tdesc'><h4>function Abs(x: smallint): smallint; register; assembler; overload;</h4><br>
	Abs returns the absolute value of a variable. <br> The result of the function has the same type as its argument, which can be any numerical type.<br><ul><h5>parameters:</h5><li>x - smallint</li><h5>returns:</h5><li class='returns'>smallint</li></ul></td></tr>
<tr><td class='tname fname'>Abs</td><td class='tdesc'><h4>function Abs(x: Integer): Integer; register; assembler; overload;</h4><br>
	Abs returns the absolute value of a variable. <br> The result of the function has the same type as its argument, which can be any numerical type.<br><ul><h5>parameters:</h5><li>x - Integer</li><h5>returns:</h5><li class='returns'>Integer</li></ul></td></tr>
<tr><td class='tname fname'>Sqr</td><td class='tdesc'><h4>function Sqr(x: Real): Real; overload;</h4><br>
	Sqr returns the square of its argument X<br><ul><h5>parameters:</h5><li>x - Real (Q24.8)</li><h5>returns:</h5><li class='returns'>Real (Q24.8)</li></ul></td></tr>
<tr><td class='tname fname'>Sqr</td><td class='tdesc'><h4>function Sqr(x: Single): Single; overload;</h4><br>
	Sqr returns the square of its argument X<br><ul><h5>parameters:</h5><li>x - Single</li><h5>returns:</h5><li class='returns'>Single</li></ul></td></tr>
<tr><td class='tname fname'>Sqr</td><td class='tdesc'><h4>function Sqr(x: integer): integer; overload;</h4><br>
	Sqr returns the square of its argument X<br><ul><h5>parameters:</h5><li>x - integer</li><h5>returns:</h5><li class='returns'>integer</li></ul></td></tr>
<tr><td class='tname fname'>Sqrt</td><td class='tdesc'><h4>function Sqrt(x: Real): Real; overload;</h4><br>
	Sqrt returns the square root of its argument X, which must be positive<br><ul><h5>parameters:</h5><li>x - Real (Q24.8)</li><h5>returns:</h5><li class='returns'>Real (Q24.8)</li></ul></td></tr>
<tr><td class='tname fname'>Sqrt</td><td class='tdesc'><h4>function Sqrt(x: Single): Single; overload;</h4><br>
	Sqrt returns the square root of its argument X, which must be positive<br><ul><h5>parameters:</h5><li>x - Single</li><h5>returns:</h5><li class='returns'>Single</li></ul></td></tr>
<tr><td class='tname fname'>Sqrt</td><td class='tdesc'><h4>function Sqrt(x: float16): float16; overload;</h4><br>
	Sqrt returns the square root of its argument X, which must be positive<br><ul><h5>parameters:</h5><li>x - Single</li><h5>returns:</h5><li class='returns'>Single</li></ul></td></tr>
<tr><td class='tname fname'>Sqrt</td><td class='tdesc'><h4>function Sqrt(x: Integer): Single; overload;</h4><br>
	Sqrt returns the square root of its argument X, which must be positive<br><ul><h5>parameters:</h5><li>x - integer</li><h5>returns:</h5><li class='returns'>integer</li></ul></td></tr>
<tr><td class='tname fname'>iSqrt</td><td class='tdesc'><h4>function iSqrt(number: Single): Single;</h4><br>
	Fast inverse square root <br> <a href='https://en.wikipedia.org/wiki/Fast_inverse_square_root'>https://en.wikipedia.org/wiki/Fast_inverse_square_root</a> <br> <a href='https://pl.wikipedia.org/wiki/Szybka_odwrotno%C5%9B%C4%87_pierwiastka_kwadratowego'>https://pl.wikipedia.org/wiki/Szybka_odwrotno%C5%9B%C4%87_pierwiastka_kwadratowego</a><br><ul><h5>parameters:</h5><li>number - Single</li><h5>returns:</h5><li class='returns'>Single</li></ul></td></tr>
<tr><td class='tname fname'>ArcTan</td><td class='tdesc'><h4>function ArcTan(value: real): real; overload;</h4><br>
	Arctan returns the Arctangent of Value, which can be any Real type. <br> The resulting angle is in radial units.<br><ul><h5>parameters:</h5><li>value - Real (Q24.8)</li><h5>returns:</h5><li class='returns'>Real (Q24.8)</li></ul></td></tr>
<tr><td class='tname fname'>ArcTan</td><td class='tdesc'><h4>function ArcTan(value: single): single; overload;</h4><br>
	Arctan returns the Arctangent of Value, which can be any Real type. <br> The resulting angle is in radial units.<br><ul><h5>parameters:</h5><li>value - Real (Q24.8)</li><h5>returns:</h5><li class='returns'>Real (Q24.8)</li></ul></td></tr>
<tr><td class='tname fname'>Exp</td><td class='tdesc'><h4>function Exp(x: Real): Real; overload;</h4><br>
	Exp returns the exponent of X, i.e. the number e to the power X. <br> <a href='https://www.codeproject.com/Tips/311714/Natural-Logarithms-and-Exponent'>https://www.codeproject.com/Tips/311714/Natural-Logarithms-and-Exponent</a><br><ul><h5>parameters:</h5><li>x - Real (Q24.8)</li><h5>returns:</h5><li class='returns'>Real (Q24.8)</li></ul></td></tr>
<tr><td class='tname fname'>Exp</td><td class='tdesc'><h4>function Exp(x: Float): Float; overload;</h4><br>
	Exp returns the exponent of X, i.e. the number e to the power X. <br> <a href='https://www.codeproject.com/Tips/311714/Natural-Logarithms-and-Exponent'>https://www.codeproject.com/Tips/311714/Natural-Logarithms-and-Exponent</a><br><ul><h5>parameters:</h5><li>x - Float (Single)</li><h5>returns:</h5><li class='returns'>Float (Single)</li></ul></td></tr>
<tr><td class='tname fname'>Ln</td><td class='tdesc'><h4>function Ln(x: Real): Real; overload;</h4><br>
	Ln returns the natural logarithm of the Real parameter X. X must be positive. <br> <a href='https://www.codeproject.com/Tips/311714/Natural-Logarithms-and-Exponent'>https://www.codeproject.com/Tips/311714/Natural-Logarithms-and-Exponent</a><br><ul><h5>parameters:</h5><li>x - Real (Q24.8)</li><h5>returns:</h5><li class='returns'>Real (Q24.8)</li></ul></td></tr>
<tr><td class='tname fname'>Ln</td><td class='tdesc'><h4>function Ln(x: Float): Float; overload;</h4><br>
	Ln returns the natural logarithm of the Real parameter X. X must be positive. <br> <a href='https://www.codeproject.com/Tips/311714/Natural-Logarithms-and-Exponent'>https://www.codeproject.com/Tips/311714/Natural-Logarithms-and-Exponent</a><br><ul><h5>parameters:</h5><li>x - Float (Single)</li><h5>returns:</h5><li class='returns'>Float (Single)</li></ul></td></tr>
<tr><td class='tname fname'>FileSize</td><td class='tdesc'><h4>function FileSize(var f: file): cardinal; assembler;</h4><br>
	Size of file (SDX only)<br><ul><h5>parameters:</h5><li>f - file handle</li><h5>returns:</h5><li class='returns'>cardinal</li></ul></td></tr>
<tr><td class='tname fname'>FilePos</td><td class='tdesc'><h4>function FilePos(var f: file): cardinal; assembler;</h4><br>
	Get position in file (SDX only)<br><ul><h5>parameters:</h5><li>f - file handle</li><h5>returns:</h5><li class='returns'>cardinal</li></ul></td></tr>
<tr><td class='tname fname'>Seek</td><td class='tdesc'><h4>procedure Seek(var f: file; a: cardinal); assembler;</h4><br>
	Set file position (SDX only)<br><ul><h5>parameters:</h5><li>f - file handle</li><li>a - new position</li></ul></td></tr>
<tr><td class='tname fname'>Eof</td><td class='tdesc'><h4>function Eof(var f: file): Boolean;</h4><br>
	Check for end of file<br><ul><h5>parameters:</h5><li>f - file handle</li><h5>returns:</h5><li class='returns'>TRUE if the file-pointer has reached the end of the file</li></ul></td></tr>
<tr><td class='tname fname'>IsLetter</td><td class='tdesc'><h4>function IsLetter(A: char): Boolean;</h4><br>
	Check if A is a letter.<br><ul><h5>parameters:</h5><li>A - char</li><h5>returns:</h5><li class='returns'>Boolean</li></ul></td></tr>
<tr><td class='tname fname'>IsDigit</td><td class='tdesc'><h4>function IsDigit(A: char): Boolean;</h4><br>
	Check if A is a digit.<br><ul><h5>parameters:</h5><li>A - char</li><h5>returns:</h5><li class='returns'>Boolean</li></ul></td></tr>
<tr><td class='tname fname'>LowerCase</td><td class='tdesc'><h4>function LowerCase(a: char): char;</h4><br>
	Converts a character to lowercase<br><ul><h5>parameters:</h5><li>a - char</li><h5>returns:</h5><li class='returns'>char</li></ul></td></tr>
<tr><td class='tname fname'>UpCase</td><td class='tdesc'><h4>function UpCase(a: char): char;</h4><br>
	Converts a character to uppercase<br><ul><h5>parameters:</h5><li>a - char</li><h5>returns:</h5><li class='returns'>char</li></ul></td></tr>
<tr><td class='tname fname'>Val</td><td class='tdesc'><h4>procedure Val(s: PString; var v: integer; var code: byte); assembler; overload;</h4><br>
	Calculate numerical value of a string<br><ul><h5>parameters:</h5><li>s - string</li><li>v - pointer to integer - result</li><li>code - pointer to integer - error code</li></ul></td></tr>
<tr><td class='tname fname'>Val</td><td class='tdesc'><h4>procedure Val(s: PString; var v: real; var code: byte); overload; //register;</h4><br>
	Calculate numerical value of a string<br><ul><h5>parameters:</h5><li>s - string</li><li>v - pointer to real - result</li><li>code - pointer to integer - error code</li></ul></td></tr>
<tr><td class='tname fname'>Val</td><td class='tdesc'><h4>procedure Val(s: PString; var v: single; var code: byte); overload; //register;</h4><br>
	Calculate numerical value of a string<br><ul><h5>parameters:</h5><li>s - string</li><li>v - pointer to integer - result</li><li>code - pointer to integer - error code</li></ul></td></tr>
<tr><td class='tname fname'>FloatToStr</td><td class='tdesc'><h4>function FloatToStr(a: real): TString; stdcall; assembler;</h4><br>
	Convert a float value to a string<br><ul><h5>parameters:</h5><li>a - Real (Q24.8)</li><h5>returns:</h5><li class='returns'>string[32]</li></ul></td></tr>
<tr><td class='tname fname'>Str</td><td class='tdesc'><h4>procedure Str(a: integer; var s: TString); overload; stdcall; assembler;</h4><br>
	Convert a numerical value to a string<br><ul><h5>parameters:</h5><li>a - integer</li><li>s - string[32] - result</li></ul></td></tr>
<tr><td class='tname fname'>Str</td><td class='tdesc'><h4>procedure Str(a: cardinal; var s: TString); overload; stdcall; assembler;</h4><br>
	Convert a numerical value to a string<br><ul><h5>parameters:</h5><li>a - integer</li><li>s - string[32] - result</li></ul></td></tr>
<tr><td class='tname fname'>Poke</td><td class='tdesc'><h4>procedure Poke(a: word; value: byte); register; stdcall; assembler;</h4><br>
	Store BYTE at the desired memory address<br><ul><h5>parameters:</h5><li>a - memory address</li><li>value (0..255)</li></ul></td></tr>
<tr><td class='tname fname'>DPoke</td><td class='tdesc'><h4>procedure DPoke(a: word; value: word); register; stdcall; assembler;</h4><br>
	Store WORD at the desired memory address<br><ul><h5>parameters:</h5><li>a - memory address</li><li>value (0..65535)</li></ul></td></tr>
<tr><td class='tname fname'>FillChar</td><td class='tdesc'><h4>procedure FillChar(a: pointer; count: word; value: char); assembler; register; overload; inline;</h4><br>
	Fills the memory starting at A with Count Characters with value equal to Value<br><ul><h5>parameters:</h5><li>a - pointer</li><li>count</li><li>value - Char</li></ul></td></tr>
<tr><td class='tname fname'>FillChar</td><td class='tdesc'><h4>procedure FillChar(a: pointer; count: word; value: byte); assembler; register; overload; inline;</h4><br>
	Fills the memory starting at A with Count Characters with value equal to Value<br><ul><h5>parameters:</h5><li>a - pointer</li><li>count</li><li>value - Byte</li></ul></td></tr>
<tr><td class='tname fname'>FillChar</td><td class='tdesc'><h4>procedure FillChar(a: pointer; count: word; value: Boolean); assembler; register; overload; inline;</h4><br>
	Fills the memory starting at A with Count Characters with value equal to Value<br><ul><h5>parameters:</h5><li>a - pointer</li><li>count</li><li>value - Boolean</li></ul></td></tr>
<tr><td class='tname fname'>FillChar</td><td class='tdesc'><h4>procedure FillChar(var a; count: word; value: Boolean); assembler; register; overload; inline;</h4><br>
	Fills the memory starting at A with Count Characters with value equal to Value<br><ul><h5>parameters:</h5><li>a - array</li><li>count</li><li>value - Boolean</li></ul></td></tr>
<tr><td class='tname fname'>FillChar</td><td class='tdesc'><h4>procedure FillChar(var a; count: word; value: Byte); assembler; register; overload; inline;</h4><br>
	Fills the memory starting at A with Count Characters with value equal to Value<br><ul><h5>parameters:</h5><li>a - array</li><li>count</li><li>value - Boolean</li></ul></td></tr>
<tr><td class='tname fname'>FillByte</td><td class='tdesc'><h4>procedure FillByte(a: pointer; count: word; value: byte); assembler; register; inline;</h4><br>
	Fills the memory starting at A with Count Characters with value equal to Value<br><ul><h5>parameters:</h5><li>a - pointer</li><li>count</li><li>value - Byte</li></ul></td></tr>
<tr><td class='tname fname'>Move</td><td class='tdesc'><h4>procedure Move(source, dest: pointer; count: word); assembler; register; overload; inline;</h4><br>
	Moves Count bytes from Source to Dest<br><ul><h5>parameters:</h5><li>source - pointer</li><li>dest - pointer</li><li>count - word</li><h5>returns:</h5><li class='returns'>cardinal</li></ul></td></tr>
<tr><td class='tname fname'>Move</td><td class='tdesc'><h4>procedure Move(var source, dest; count: word); assembler; register; overload; inline;</h4><br>
	<br><ul></ul></td></tr>
<tr><td class='tname fname'>Move</td><td class='tdesc'><h4>procedure Move(var source; dest: pointer; count: word); assembler; register; overload; inline;</h4><br>
	<br><ul></ul></td></tr>
<tr><td class='tname fname'>Move</td><td class='tdesc'><h4>procedure Move(source: pointer;var dest; count: word); assembler; register; overload; inline;</h4><br>
	<br><ul></ul></td></tr>
<tr><td class='tname fname'>Sin</td><td class='tdesc'><h4>function Sin(x: Real): Real; overload;</h4><br>
	Calculate sine of angle<br><ul><h5>parameters:</h5><li>X - angle in radians (Q24.8)</li><h5>returns:</h5><li class='returns'>Q24.8</li></ul></td></tr>
<tr><td class='tname fname'>Cos</td><td class='tdesc'><h4>function Cos(x: Real): Real; overload;</h4><br>
	Calculate cosine of angle<br><ul><h5>parameters:</h5><li>X - angle in radians (Q24.8)</li><h5>returns:</h5><li class='returns'>Q24.8</li></ul></td></tr>
<tr><td class='tname fname'>Sin</td><td class='tdesc'><h4>function Sin(x: single): single; overload;</h4><br>
	Calculate sine of angle<br><ul><h5>parameters:</h5><li>X - angle in radians (Single)</li><h5>returns:</h5><li class='returns'>Single</li></ul></td></tr>
<tr><td class='tname fname'>Cos</td><td class='tdesc'><h4>function Cos(x: single): single; overload;</h4><br>
	Calculate cosine of angle<br><ul><h5>parameters:</h5><li>X - angle in radians (Single)</li><h5>returns:</h5><li class='returns'>Single</li></ul></td></tr>
<tr><td class='tname fname'>Sin</td><td class='tdesc'><h4>function Sin(x: float16): float16; overload;</h4><br>
	Calculate sine of angle<br><ul><h5>parameters:</h5><li>X - angle in radians (Single)</li><h5>returns:</h5><li class='returns'>Single</li></ul></td></tr>
<tr><td class='tname fname'>Cos</td><td class='tdesc'><h4>function Cos(x: float16): float16; overload;</h4><br>
	Calculate cosine of angle<br><ul><h5>parameters:</h5><li>X - angle in radians (Single)</li><h5>returns:</h5><li class='returns'>Single</li></ul></td></tr>
<tr><td class='tname fname'>Space</td><td class='tdesc'><h4>function Space(b: Byte): ^string; assembler;</h4><br>
	Return a string of spaces<br><ul><h5>parameters:</h5><li>b - number of spaces</li><h5>returns:</h5><li class='returns'>pointer to string</li></ul></td></tr>
<tr><td class='tname fname'>StringOfChar</td><td class='tdesc'><h4>function StringOfChar(c: Char; l: byte): ^string; assembler;</h4><br>
	Return a string consisting of 1 character repeated N times.<br><ul><h5>parameters:</h5><li>c - character</li><li>l - counter (BYTE)</li><h5>returns:</h5><li class='returns'>pointer to string</li></ul></td></tr>
<tr><td class='tname fname'>SetLength</td><td class='tdesc'><h4>procedure SetLength(var S: string; Len: byte); register; assembler;</h4><br>
	Set length of a string.<br><ul><h5>parameters:</h5><li>S - string</li><li>len - new length (BYTE)</li></ul></td></tr>
<tr><td class='tname fname'>BinStr</td><td class='tdesc'><h4>function BinStr(Value: cardinal; Digits: byte): TString; assembler;</h4><br>
	Convert integer to string with binary representation.<br><ul><h5>parameters:</h5><li>Value - Cardinal</li><li>Digits - Byte</li><h5>returns:</h5><li class='returns'>string[32]</li></ul></td></tr>
<tr><td class='tname fname'>OctStr</td><td class='tdesc'><h4>function OctStr(Value: cardinal; Digits: byte): TString; assembler;</h4><br>
	Convert integer to a string with octal representation.<br><ul><h5>parameters:</h5><li>Value - Cardinal</li><li>Digits - Byte</li><h5>returns:</h5><li class='returns'>string[32]</li></ul></td></tr>
<tr><td class='tname fname'>Delete</td><td class='tdesc'><h4>procedure Delete(var s: string; index, count: byte);</h4><br>
	Delete removes Count characters from string S, starting at position Index.<br><ul><h5>parameters:</h5><li>sindex count</li></ul></td></tr>
<tr><td class='tname fname'>Pos</td><td class='tdesc'><h4>function Pos(c: char; s: string): byte; overload;</h4><br>
	Pos returns the index of Substr in S, if S contains Substr. In case Substr isn't found, 0 is returned. The search is case-sensitive.<br><ul><h5>parameters:</h5><li>c - char (Substr)s - string</li></ul></td></tr>
<tr><td class='tname fname'>Pos</td><td class='tdesc'><h4>function Pos(s1: string; s2: string): byte; overload;</h4><br>
	Pos returns the index of Substr in S, if S contains Substr. In case Substr isn't found, 0 is returned. The search is case-sensitive.<br><ul><h5>parameters:</h5><li>s1 - string (Substr)s2 - string</li></ul></td></tr>
<tr><td class='tname fname'>Concat</td><td class='tdesc'><h4>function Concat(a,b: PString): string; assembler; overload;</h4><br>
	Append one string to another.<br><ul><h5>parameters:</h5><li>a - first string</li><li>b - second string</li><h5>returns:</h5><li class='returns'>string (a+b)</li></ul></td></tr>
<tr><td class='tname fname'>Concat</td><td class='tdesc'><h4>function Concat(a: PString; b: char): string; assembler; overload;</h4><br>
	<br><ul></ul></td></tr>
<tr><td class='tname fname'>Concat</td><td class='tdesc'><h4>function Concat(a: char; b: PString): string; assembler; overload;</h4><br>
	<br><ul></ul></td></tr>
<tr><td class='tname fname'>Concat</td><td class='tdesc'><h4>function Concat(a,b: char): string; overload;</h4><br>
	<br><ul></ul></td></tr>
<tr><td class='tname fname'>Copy</td><td class='tdesc'><h4>function Copy(var S: String; Index: Byte; Count: Byte): string; assembler;</h4><br>
	<br><ul></ul></td></tr>
<tr><td class='tname fname'>Swap</td><td class='tdesc'><h4>function Swap(a: word): word; overload;</h4><br>
	Swap high and low bytes of a variable<br><ul><h5>parameters:</h5><li>a - word</li><h5>returns:</h5><li class='returns'>word</li></ul></td></tr>
<tr><td class='tname fname'>Swap</td><td class='tdesc'><h4>function Swap(a: cardinal): cardinal; overload;</h4><br>
	Swap high and low words of a variable<br><ul><h5>parameters:</h5><li>a - cardinal</li><h5>returns:</h5><li class='returns'>cardinal</li></ul></td></tr>
<tr><td class='tname fname'>GetMem</td><td class='tdesc'><h4>procedure GetMem(var p; size: word); assembler; register;</h4><br>
	Getmem reserves Size bytes memory, and returns a pointer to this memory in p.<br><ul><h5>parameters:</h5><li>p - pointer</li><li>size</li></ul></td></tr>
<tr><td class='tname fname'>FreeMem</td><td class='tdesc'><h4>procedure FreeMem(var p; size: word); assembler; register;</h4><br>
	Freemem releases the memory occupied by the pointer P<br><ul><h5>parameters:</h5><li>p - pointer</li><li>size</li></ul></td></tr>
<tr><td class='tname fname'>CompareByte</td><td class='tdesc'><h4>function CompareByte(P1,P2: PByte; Len: word): smallint; register; overload;</h4><br>
	Compare 2 memory buffers byte per byte<br><ul><h5>parameters:</h5><li>P1, P2 - pointer</li><li>Len - length</li></ul></td></tr>
<tr><td class='tname fname'>CompareByte</td><td class='tdesc'><h4>function CompareByte(P1,P2: PByte; Len: byte): smallint; register; overload;</h4><br>
	Compare 2 memory buffers byte per byte<br><ul><h5>parameters:</h5><li>P1, P2 - pointer</li><li>Len - length</li></ul></td></tr>

</table>

<!--********************* FOOTER **************************-->

<br>
<div class='footer'>This documentation was generated using <a href='https://gitlab.com/bocianu/pasdoc' target='_blank'>PasDoc</a>.</div>
</body>
</html>
