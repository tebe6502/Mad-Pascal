; ------------------------------------------------------------
; Mad Pascal Compiler version 1.6.4 [2020/05/28] for 6502
; ------------------------------------------------------------

STACKWIDTH	= 16
CODEORIGIN	= $2000

TRUE		= 1
FALSE		= 0

; ------------------------------------------------------------

	org $80

fxptr	.ds 2						; VBXE pointer
psptr	.ds 2						; PROGRAMSTACK Pointer

eax	.ds 4						;8 bytes (aex + edx) -> divREAL
edx	.ds 4
ecx	.ds 4
bp	.ds 2
bp2	.ds 2

ztmp
ztmp8	.ds 1
ztmp9	.ds 1
ztmp10	.ds 1
ztmp11	.ds 1

TMP	.ds 2

STACKORIGIN	.ds STACKWIDTH*4
zpend

; ------------------------------------------------------------

ax	= eax
al	= eax
ah	= eax+1

cx	= ecx
cl	= ecx
ch	= ecx+1

dx	= edx
dl	= edx
dh	= edx+1

	org eax

FP1MAN0	.ds 1
FP1MAN1	.ds 1
FP1MAN2	.ds 1
FP1MAN3	.ds 1

	org ztmp8

FP1SGN	.ds 1
FP1EXP	.ds 1

	org edx

FP2MAN0	.ds 1

FP2MAN1	.ds 1
FP2MAN2	.ds 1
FP2MAN3	.ds 1

	org ztmp10

FP2SGN	.ds 1
FP2EXP	.ds 1

	org ecx

FPMAN0	.ds 1
FPMAN1	.ds 1
FPMAN2	.ds 1
FPMAN3	.ds 1

	org bp2

FPSGN	.ds 1
FPEXP	.ds 1

	.ifdef MAIN.@DEFINES.S_VBXE
	opt h-
	ins 'atari\s_vbxe\sdxld2.obx'
	opt h+
	.endif

; ------------------------------------------------------------

	org CODEORIGIN

	STATICDATA

; ------------------------------------------------------------

RTLIB
	icl 'rtl6502.asm'

.print 'ZPAGE: ',fxptr,'..',zpend

.print 'RTLIB: ',RTLIB,'..',*

; ------------------------------------------------------------

START
	tsx
	stx MAIN.@halt+1

	.ifdef fmulinit
	fmulinit
	eif

VLEN	= VARDATASIZE-VARINITSIZE
VADR	= DATAORIGIN+VARINITSIZE

	ift VADR > $BFFF
	ert 'Invalid memory address range ',VADR
	eli (VLEN>0) && (VLEN<=256)
	ldx #256-VLEN
	lda #0
	sta:rne VADR+VLEN-256,x+
	eli VLEN>0
	@fill #VADR #VLEN #0
	eif

	.ifdef MAIN.@DEFINES.ROMOFF
	icl 'atari\romoff.asm'
	.endif

	mwa #PROGRAMSTACK psptr

	ldx #$0f					; DOS II+/D ParamStr
	mva:rpl $340,x MAIN.IOCB@COPY,x-

	inx						; X = 0
	stx bp						; BP = 0

	stx audctl					; reset POKEY
	lda #3
	sta skctl

	dex						; X = 255

	UNITINITIALIZATION

.local	MAIN						; PROCEDURE

	jmp l_06E6

; ------------------------------------------------------------

.local	SYSTEM						; UNIT

.local	PEEK						; FUNCTION | ASSEMBLER | REGISTER

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x A
	mva :STACKORIGIN+STACKWIDTH,x A+1
	dex

; ---------------------  ASM Block 001  ---------------------

	ldy #0
	mva (edx),y Result

@exit

; ------------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx
	mva RESULT :STACKORIGIN,x

	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif

; ------------------------------------------------------------

A	= edx
RESULT	= DATAORIGIN+$000B

@VarData	= RESULT
@VarDataSize	= 1

	rts						; ret
.endl

.local	VAL_0712					; PROCEDURE | ASSEMBLER | OVERLOAD

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x CODE
	mva :STACKORIGIN+STACKWIDTH,x CODE+1
	dex

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x V
	mva :STACKORIGIN+STACKWIDTH,x V+1
	dex

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x S
	mva :STACKORIGIN+STACKWIDTH,x S+1
	dex

; ---------------------  ASM Block 017  ---------------------

	@StrToInt s

	tya
	pha

	mwa code :bp2
	ldy #0

	pla
	sta (:bp2),y

	mwa v :bp2
	
	mva edx (:bp2),y+
	mva edx+1 (:bp2),y+
	mva edx+2 (:bp2),y+
	mva edx+3 (:bp2),y


; ------------------------------------------------------------

S	= DATAORIGIN+$000C
V	= DATAORIGIN+$000E
CODE	= DATAORIGIN+$0010

@VarData	= S
@VarDataSize	= 6

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	STR_0732					; PROCEDURE | ASSEMBLER | OVERLOAD

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x S
	mva :STACKORIGIN+STACKWIDTH,x S+1
	dex

; ------------------------------------------------------------

; Generate Assignment for CARDINAL / INTEGER / REAL / SINGLE
; as Pointer
	mva :STACKORIGIN,x A
	mva :STACKORIGIN+STACKWIDTH,x A+1
	mva :STACKORIGIN+STACKWIDTH*2,x A+2
	mva :STACKORIGIN+STACKWIDTH*3,x A+3
	dex

; ---------------------  ASM Block 019  ---------------------

	txa:pha

	inx

	@ValueToStr #@printINT

	@move #@buf s #16	; !!! koniecznie przez wskaznik

	pla:tax


; ------------------------------------------------------------

A	= DATAORIGIN+$0012
S	= DATAORIGIN+$0016

@VarData	= A
@VarDataSize	= 6

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	POKE						; PROCEDURE | ASSEMBLER | REGISTER

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x VALUE
	dex

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x A
	mva :STACKORIGIN+STACKWIDTH,x A+1
	dex

; ---------------------  ASM Block 021  ---------------------

	ldy #0
	mva value (edx),y


; ------------------------------------------------------------

A	= edx
VALUE	= ecx
@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	FILLBYTE_0740					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x VALUE
	dex

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x COUNT
	mva :STACKORIGIN+STACKWIDTH,x COUNT+1
	dex

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x A
	mva :STACKORIGIN+STACKWIDTH,x A+1
	dex

; ---------------------  ASM Block 029  ---------------------

	jsr @fill


; ------------------------------------------------------------

A	= edx
COUNT	= ecx
VALUE	= eax
@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	MOVE_074A					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x COUNT
	mva :STACKORIGIN+STACKWIDTH,x COUNT+1
	dex

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x DEST
	mva :STACKORIGIN+STACKWIDTH,x DEST+1
	dex

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x SOURCE
	mva :STACKORIGIN+STACKWIDTH,x SOURCE+1
	dex

; ---------------------  ASM Block 033  ---------------------

	jsr @move


; ------------------------------------------------------------

SOURCE	= edx
DEST	= ecx
COUNT	= eax
@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	SPACE						; FUNCTION | ASSEMBLER

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x B
	dex

; ---------------------  ASM Block 034  ---------------------

	ldy #0
	lda #' '
	sta:rne @buf,y+

	mva b @buf

	mwa #@buf Result

@exit

; ------------------------------------------------------------

; Push WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer

	inx
	mva RESULT :STACKORIGIN,x
	mva RESULT+1 :STACKORIGIN+STACKWIDTH,x

	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif

; ------------------------------------------------------------

B	= DATAORIGIN+$0018
RESULT	= DATAORIGIN+$0019

@VarData	= B
@VarDataSize	= 3

	rts						; ret
.endl

.local	CONCAT_076E					; FUNCTION | ASSEMBLER | OVERLOAD

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x :bp2
	mva :STACKORIGIN+STACKWIDTH,x :bp2+1
	ldy #$00
	mva:rne (:bp2),y adr.B,y+
	mwa #adr.B B
	dex

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x :bp2
	mva :STACKORIGIN+STACKWIDTH,x :bp2+1
	ldy #$00
	mva:rne (:bp2),y adr.A,y+
	mwa #adr.A A
	dex

; ---------------------  ASM Block 043  ---------------------

	cpw a #@buf
	beq skp

	mva #0 @buf
	@addString a
skp
	@addString b

	ldy #0
	mva:rne @buf,y adr.Result,y+

@exit

; ------------------------------------------------------------

; Push WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer

	inx
	mva RESULT :STACKORIGIN,x
	mva RESULT+1 :STACKORIGIN+STACKWIDTH,x

	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif

; ------------------------------------------------------------

adr.A	= DATAORIGIN+$001B
.var A	= adr.A .word
adr.B	= DATAORIGIN+$011B
.var B	= adr.B .word
adr.RESULT	= DATAORIGIN+$021B
.var RESULT	= adr.RESULT .word

@VarData	= A
@VarDataSize	= 768

	rts						; ret
.endl

.local	CONCAT_0777					; FUNCTION | ASSEMBLER | OVERLOAD

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x B
	dex

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x A
	mva :STACKORIGIN+STACKWIDTH,x A+1
	dex

; ---------------------  ASM Block 044  ---------------------

	cpw a #@buf
	beq skp

	mva #0 @buf
	@addString a
skp
	inc @buf
	ldy @buf
	lda b
	sta @buf,y

	ldy #0
	mva:rne @buf,y adr.Result,y+

@exit

; ------------------------------------------------------------

; Push WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer

	inx
	mva RESULT :STACKORIGIN,x
	mva RESULT+1 :STACKORIGIN+STACKWIDTH,x

	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif

; ------------------------------------------------------------

A	= DATAORIGIN+$031B
B	= DATAORIGIN+$031D
adr.RESULT	= DATAORIGIN+$031E
.var RESULT	= adr.RESULT .word

@VarData	= A
@VarDataSize	= 259

	rts						; ret
.endl

; ------------------------------------------------------------

__PORTB_BANKS	= $0101
M_PI_2	= $0648
D_PI_2	= $0192
D_PI_180	= $04
MGTIA	= $00
MVBXE	= $80
VBXE_XDLADR	= $00
VBXE_BCBADR	= $0100
VBXE_MAPADR	= $1000
VBXE_OVRADR	= $5000
VBXE_WINDOW	= $B000
IDLI	= $00
IVBL	= $01
CH_DELCHR	= $FE
CH_ENTER	= $9B
CH_ESC	= $1B
CH_CURS_UP	= $1C
CH_CURS_DOWN	= $1D
CH_CURS_LEFT	= $1E
CH_CURS_RIGHT	= $1F
CH_TAB	= $7F
CH_EOL	= $9B
CH_CLR	= $7D
CH_BELL	= $FD
CH_DEL	= $7E
CH_DELLINE	= $9C
CH_INSLINE	= $9D
COLOR_BLACK	= $00
COLOR_WHITE	= $0E
COLOR_RED	= $32
COLOR_CYAN	= $96
COLOR_VIOLET	= $68
COLOR_GREEN	= $C4
COLOR_BLUE	= $74
COLOR_YELLOW	= $EE
COLOR_ORANGE	= $28
COLOR_BROWN	= $E4
COLOR_LIGHTRED	= $3C
COLOR_GRAY1	= $04
COLOR_GRAY2	= $06
COLOR_GRAY3	= $0A
COLOR_LIGHTGREEN	= $CC
COLOR_LIGHTBLUE	= $7C
FMOPENREAD	= $04
FMOPENWRITE	= $08
FMOPENAPPEND	= $09
FMOPENREADWRITE	= $0C
SCREENWIDTH	= DATAORIGIN+$0000
SCREENHEIGHT	= DATAORIGIN+$0002
DATESEPARATOR	= DATAORIGIN+$0004
TVSYSTEM	= $D014
adr.PALETTE	= $02C0
.var PALETTE	= adr.PALETTE .word
adr.HPALETTE	= $D012
.var HPALETTE	= adr.HPALETTE .word
FILEMODE	= DATAORIGIN+$0005
GRAPHMODE	= DATAORIGIN+$0006
IORESULT	= DATAORIGIN+$0007
EOLN	= DATAORIGIN+$0008
RNDSEED	= DATAORIGIN+$0009

.endl							; UNIT SYSTEM

; ------------------------------------------------------------

.local	ATARI						; UNIT

; ------------------------------------------------------------

RTCLOK	= $12
ATRACT	= $4D
LMARGIN	= $52
RMARGIN	= $53
ROWCRS	= $54
COLCRS	= $55
DINDEX	= $57
SAVMSC	= $58
PALNTS	= $62
RAMTOP	= $6A
VDSLST	= $0200
SDLSTL	= $0230
TXTROW	= $0290
TXTCOL	= $0291
TINDEX	= $0293
TXTMSC	= $0294
SDMCTL	= $022F
GPRIOR	= $026F
CRSINH	= $02F0
CHACT	= $02F3
CHBAS	= $02F4
CH	= $02FC
PCOLR0	= $02C0
PCOLR1	= $02C1
PCOLR2	= $02C2
PCOLR3	= $02C3
COLOR0	= $02C4
COLOR1	= $02C5
COLOR2	= $02C6
COLOR3	= $02C7
COLOR4	= $02C8
COLBAKS	= $02C8
HPOSP0	= $D000
HPOSP1	= $D001
HPOSP2	= $D002
HPOSP3	= $D003
HPOSM0	= $D004
HPOSM1	= $D005
HPOSM2	= $D006
HPOSM3	= $D007
SIZEP0	= $D008
SIZEP1	= $D009
SIZEP2	= $D00A
SIZEP3	= $D00B
SIZEM	= $D00C
GRAFP0	= $D00D
GRAFP1	= $D00E
GRAFP2	= $D00F
GRAFP3	= $D010
GRAFM	= $D011
P0PF	= $D004
PAL	= $D014
COLPM0	= $D012
COLPM1	= $D013
COLPM2	= $D014
COLPM3	= $D015
COLPF0	= $D016
COLPF1	= $D017
COLPF2	= $D018
COLPF3	= $D019
COLBK	= $D01A
PRIOR	= $D01B
GRACTL	= $D01D
HITCLR	= $D01E
AUDF1	= $D200
AUDC1	= $D201
AUDF2	= $D202
AUDC2	= $D203
AUDF3	= $D204
AUDC3	= $D205
AUDF4	= $D206
AUDC4	= $D207
AUDCTL	= $D208
SKSTAT	= $D20F
PORTB	= $D301
DMACTL	= $D400
CHACTL	= $D401
DLISTL	= $D402
HSCROL	= $D404
VSCROL	= $D405
PMBASE	= $D407
CHBASE	= $D409
WSYNC	= $D40A
VCOUNT	= $D40B
PENH	= $D40C
PENV	= $D40D
NMIEN	= $D40E

.endl							; UNIT ATARI

; ------------------------------------------------------------

.local	CRT						; UNIT

.local	CURSOROFF					; PROCEDURE

; optimize OK (CRT), line = 116

	mva #$01 ATARI.CRSINH

; optimize FAIL (100, CRT), line = 118
	@print #$1F
	@print #$1E
@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	CURSORON					; PROCEDURE

; optimize OK (CRT), line = 129

	mva #$00 ATARI.CRSINH

; optimize FAIL (100, CRT), line = 131
	@print #$1F
	@print #$1E
@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	CLRSCR						; PROCEDURE

; optimize FAIL (100, CRT), line = 141
	@print #$7D
@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	READKEY						; FUNCTION | ASSEMBLER

; ---------------------  ASM Block 049  ---------------------

	txa:pha

	@GetKey

	sta Result

	pla:tax

@exit

; ------------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx
	mva RESULT :STACKORIGIN,x

	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif

; ------------------------------------------------------------

RESULT	= DATAORIGIN+$041F

@VarData	= RESULT
@VarDataSize	= 1

	rts						; ret
.endl

.local	DELAY						; PROCEDURE | ASSEMBLER

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x COUNT
	mva :STACKORIGIN+STACKWIDTH,x COUNT+1
	dex

; ---------------------  ASM Block 052  ---------------------

	txa:pha

	ldx #0
	ldy #0

loop	cpy count
	bne @+
	cpx count+1
	beq stop

@	:8 lda:cmp:req vcount

	iny
	sne
	inx

	bne loop

stop	pla:tax


; ------------------------------------------------------------

COUNT	= DATAORIGIN+$0420

@VarData	= COUNT
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	KEYPRESSED					; FUNCTION | ASSEMBLER

; ---------------------  ASM Block 053  ---------------------

	ldy #$00	; false
	lda kbcodes
	cmp #$ff
	beq skp
	iny		; true

;	sty kbcodes

skp	sty Result

@exit

; ------------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx
	mva RESULT :STACKORIGIN,x

	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif

; ------------------------------------------------------------

RESULT	= DATAORIGIN+$0422

@VarData	= RESULT
@VarDataSize	= 1

	rts						; ret
.endl

.local	GOTOXY						; PROCEDURE | ASSEMBLER

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x Y
	dex

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x X
	dex

; ---------------------  ASM Block 054  ---------------------

	ldy x
	beq @+

	dey

@	sty colcrs
	mvy #$00 colcrs+1

	ldy y
	beq @+

	dey

@	sty rowcrs


; ------------------------------------------------------------

X	= DATAORIGIN+$0423
Y	= DATAORIGIN+$0424

@VarData	= X
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	WHEREY						; FUNCTION | ASSEMBLER

; ---------------------  ASM Block 056  ---------------------


	ldy rowcrs
	iny
	sty Result

@exit

; ------------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx
	mva RESULT :STACKORIGIN,x

	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif

; ------------------------------------------------------------

RESULT	= DATAORIGIN+$0425

@VarData	= RESULT
@VarDataSize	= 1

	rts						; ret
.endl

; ------------------------------------------------------------

TEXTATTR	= DATAORIGIN+$041E
CONSOL	= $D01F
CN_START_SELECT_OPTION	= $00
CN_SELECT_OPTION	= $01
CN_START_OPTION	= $02
CN_OPTION	= $03
CN_START_SELECT	= $04
CN_SELECT	= $05
CN_START	= $06
CN_NONE	= $07
BW40	= $00
CO40	= $01
BW80	= $02
CO80	= $03
MONO	= $07
C40	= $01
C80	= $03
BLACK	= $00
BLUE	= $01
GREEN	= $02
CYAN	= $03
RED	= $04
MAGENTA	= $05
BROWN	= $06
LIGHTGRAY	= $07
DARKGRAY	= $08
LIGHTBLUE	= $09
LIGHTGREEN	= $0A
LIGHTCYAN	= $0B
LIGHTRED	= $0C
LIGHTMAGENTA	= $0D
YELLOW	= $0E
WHITE	= $0F
BLINK	= $80

.endl							; UNIT CRT

.local	GETSTRING					; PROCEDURE

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x MAXCHARS
	dex

; ---------------------  ASM Block 060  ---------------------


          
               iccmd    = $0342
               icbufa   = $0344
               icbufl   = $0348

               lda #<COPY_BUFFER_MEM
               ldy #>COPY_BUFFER_MEM
               ldx #$00
               sta icbufa,x
               tya
               sta icbufa+1,x
               lda maxChars
               sta icbufl,x
               lda #$00
               sta icbufl+1,x
               lda #$05
               sta iccmd,x
               jsr $E456
               
               sty CIOresult
          
          

; ------------------------------------------------------------

MAXCHARS	= DATAORIGIN+$048D

@VarData	= MAXCHARS
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	EXEC_SIO					; PROCEDURE

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x AUX
	mva :STACKORIGIN+STACKWIDTH,x AUX+1
	dex

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x SIZE
	mva :STACKORIGIN+STACKWIDTH,x SIZE+1
	dex

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x BUFFER
	mva :STACKORIGIN+STACKWIDTH,x BUFFER+1
	dex

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x TIMEOUT
	dex

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x DIRECTION
	dex

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x COMMAND
	dex

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x SUNIT
	dex

; optimize OK (milf.pas), line = 133

	mva BUFFER BL

; optimize OK (milf.pas), line = 134

	lda BUFFER+1
	sta BH

; optimize OK (milf.pas), line = 135

	mva AUX AL

; optimize OK (milf.pas), line = 136

	lda AUX+1
	sta AH

; optimize OK (milf.pas), line = 137

	mva SIZE SL

; optimize OK (milf.pas), line = 138

	lda SIZE+1
	sta SH

; ---------------------  ASM Block 061  ---------------------


               lda  #$31
               sta  DDEVIC
               lda  sunit
               sta  DUNIT
               lda  command
               sta  DCOMND
               lda  al
               sta  DAUX1
               lda  ah
               sta  DAUX2
               lda  direction
               sta  DSTATS
               lda  bl
               sta  DBUFLO
               lda  bh
               sta  DBUFHI
               lda  timeout
               sta  DTIMLO
               lda  sl
               sta  DBYTLO
               lda  sh
               sta  DBYTHI
               jsr  $E459
               
               sty  SIOresult
          

; ------------------------------------------------------------

SUNIT	= DATAORIGIN+$048E
COMMAND	= DATAORIGIN+$048F
DIRECTION	= DATAORIGIN+$0490
TIMEOUT	= DATAORIGIN+$0491
BUFFER	= DATAORIGIN+$0492
SIZE	= DATAORIGIN+$0494
AUX	= DATAORIGIN+$0496
BL	= DATAORIGIN+$0498
BH	= DATAORIGIN+$0499
AL	= DATAORIGIN+$049A
AH	= DATAORIGIN+$049B
SL	= DATAORIGIN+$049C
SH	= DATAORIGIN+$049D

@VarData	= SUNIT
@VarDataSize	= 16

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	EXITTODOS					; PROCEDURE

; ---------------------  ASM Block 062  ---------------------


               jmp ($a)
               rts
          
@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	COLDSTART					; PROCEDURE

; ---------------------  ASM Block 063  ---------------------


               jmp $e477;
               rts
          
@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	BREAKPRESSED					; FUNCTION

; optimize OK (milf.pas), line = 194

	lda CIORESULT
	cmp #$80
	jne l_0824

; optimize OK (milf.pas), line = 195

	mva #$01 RESULT
	jne l_0832
l_0824

; optimize OK (milf.pas), line = 197

	mva #$00 RESULT
l_0832
@exit

; ------------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx
	mva RESULT :STACKORIGIN,x

	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif

; ------------------------------------------------------------

RESULT	= DATAORIGIN+$049E

@VarData	= RESULT
@VarDataSize	= 1

	rts						; ret
.endl

.local	CLEARKEYS					; PROCEDURE

; optimize OK (milf.pas), line = 204

	mva #$FF CH

; optimize OK (milf.pas), line = 204

	mva #$00 KEY
@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	PRESSKEY					; PROCEDURE

; optimize FAIL ('CLEARKEYS', milf.pas), line = 212
	jsr CLEARKEYS

; optimize FAIL ('CRT.DELAY', milf.pas), line = 213
	inx
	mva #$02 :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	jsr CRT.DELAY

; optimize FAIL (100, milf.pas), line = 215
	@printEOL

; optimize FAIL (100, milf.pas), line = 216
	@printSTRING #CODEORIGIN+$0000
	@printEOL

; optimize FAIL (100, milf.pas), line = 217
	@printEOL

; --- RepeatUntilProlog
l_0850

; optimize FAIL ('CRT.KEYPRESSED', milf.pas), line = 218
	jsr CRT.KEYPRESSED
	dex
	lda :STACKORIGIN+1,x
	jeq l_0850
@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	CLEARBUFFER					; PROCEDURE

; optimize OK (milf.pas), line = 226

	.LOCAL
	ldy #$00
	tya
fill	:4 sta $6000+#*$80,y
	iny
	bpl fill
	.ENDL
@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	CLEARLOGBUFFER					; PROCEDURE

; optimize OK (milf.pas), line = 233

	lda #$00
	sta :edx
	lda #$62
	sta :edx+1
	lda #$C0
	sta :ecx
	lda #$4E
	sta :ecx+1
	lda #$00
	sta :eax
	jsr @fill
@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	CLEARPERCOMBUFFER				; PROCEDURE

; optimize OK (milf.pas), line = 240

	ldy #256-$0E
	lda #$00
	sta:rne $0600+$0E-256,y+
@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	PARSEINPUT					; PROCEDURE

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x NUMBEROFBYTESTOREAD
	dex

	mva #$00 adr.TMPSTRING
; --- For

; optimize OK (milf.pas), line = 250

	mva #$00 TMPBYTE

; optimize OK (milf.pas), line = 250

	mva NUMBEROFBYTESTOREAD :@FORTMP?087C_0
l_087F
; --- ForToDoCondition

; optimize OK (milf.pas), line = 250

	lda TMPBYTE
.def :@FORTMP?087C_0 = *+1
	cmp #$00
	scc
	jne l_088D

; optimize OK (milf.pas), line = 251

	mvy #$60 :bp+1
	ldy TMPBYTE
	lda (:bp),y
	cmp #$9B
	jeq l_08A4

; optimize FAIL ('SYSTEM.CONCAT_0777', milf.pas), line = 252
	inx
	mva TMPSTRING :STACKORIGIN,x
	mva TMPSTRING+1 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$00 :STACKORIGIN,x
	mva #$60 :STACKORIGIN+STACKWIDTH,x
	inx
	mva TMPBYTE :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	jsr addAX_CX
	dex
	jsr SYSTEM.PEEK
	jsr SYSTEM.CONCAT_0777
	@moveSTRING TMPSTRING
	dex
	jmp l_08B9
l_08A4

	jmp b_087F					; break
l_08B9

; --- ForToDoEpilog
	inc TMPBYTE					; inc ptr byte [CounterAddress]
	jne l_087F
l_088D
b_087F

; ------------------------------------------------------------

NUMBEROFBYTESTOREAD	= DATAORIGIN+$049F
@FORTMP_087C	= $00

@VarData	= NUMBEROFBYTESTOREAD
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	READPERCOM					; PROCEDURE

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x SILENT
	dex

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x DRIVE
	dex

; optimize OK (milf.pas), line = 274

	mva #$00 NUMBER_OF_SECTORS
	sta NUMBER_OF_SECTORS+1

; optimize FAIL ('CLEARPERCOMBUFFER', milf.pas), line = 276
	jsr CLEARPERCOMBUFFER

; optimize FAIL ('EXEC_SIO', milf.pas), line = 280
	inx
	mva DRIVE :STACKORIGIN,x
	inx
	mva #$53 :STACKORIGIN,x
	inx
	mva #$40 :STACKORIGIN,x
	inx
	mva #$07 :STACKORIGIN,x
	inx
	mva #$00 :STACKORIGIN,x
	mva #$06 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$04 :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$00 :STACKORIGIN,x
	sta :STACKORIGIN+STACKWIDTH,x
	jsr EXEC_SIO

; optimize FAIL ('EXEC_SIO', milf.pas), line = 291
	inx
	mva DRIVE :STACKORIGIN,x
	inx
	mva #$4E :STACKORIGIN,x
	inx
	mva #$40 :STACKORIGIN,x
	inx
	mva #$07 :STACKORIGIN,x
	inx
	mva #$00 :STACKORIGIN,x
	mva #$06 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$0C :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$00 :STACKORIGIN,x
	sta :STACKORIGIN+STACKWIDTH,x
	jsr EXEC_SIO

; ------------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx
	mva SIORESULT :STACKORIGIN,x

; GenerateCaseProlog
	dex

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #138
	jne l_08ED
@

; optimize FAIL (100, milf.pas), line = 295
	@printSTRING #CODEORIGIN+$0010
	@printEOL
	jmp a_0002
l_08ED
	lda :STACKORIGIN+1,x
	cmp #139
	jne l_08F9
@

; optimize OK (milf.pas), line = 297

	lda SILENT
	jne l_0908

; optimize FAIL (100, milf.pas), line = 298
	@printSTRING #CODEORIGIN+$0029
	@printEOL

; optimize FAIL (100, milf.pas), line = 299
	@printSTRING #CODEORIGIN+$0049
	@printEOL

; optimize FAIL (100, milf.pas), line = 300
	@printSTRING #CODEORIGIN+$006C
	@printEOL
l_0908

; optimize FAIL ('EXEC_SIO', milf.pas), line = 302
	inx
	mva DRIVE :STACKORIGIN,x
	inx
	mva #$52 :STACKORIGIN,x
	inx
	mva #$40 :STACKORIGIN,x
	inx
	mva #$07 :STACKORIGIN,x
	inx
	mva #$00 :STACKORIGIN,x
	mva #$06 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$80 :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$D1 :STACKORIGIN,x
	mva #$02 :STACKORIGIN+STACKWIDTH,x
	jsr EXEC_SIO

; optimize OK (milf.pas), line = 303

	lda SIORESULT
	cmp #$01
	jne l_0930

; optimize OK (milf.pas), line = 304

	mva #$10 NUMBER_OF_SECTORS
	mva #$04 NUMBER_OF_SECTORS+1

; optimize OK (milf.pas), line = 305

	mva #$80 BYTES_PER_SECTOR
	mva #$00 BYTES_PER_SECTOR+1
	jeq l_0942
l_0930

; optimize OK (milf.pas), line = 307

	mva #$D0 NUMBER_OF_SECTORS
	mva #$02 NUMBER_OF_SECTORS+1

; optimize OK (milf.pas), line = 308

	mva #$80 BYTES_PER_SECTOR
	mva #$00 BYTES_PER_SECTOR+1
l_0942

; optimize OK (milf.pas), line = 310

	lda SILENT
	jne l_0959

; optimize OK (milf.pas), line = 311

	lda DRIVE
	cmp #$01
	jne l_096C

; optimize OK (milf.pas), line = 312

	mva BYTES_PER_SECTOR BYTES_PER_SECTOR_SOURCE
	mva BYTES_PER_SECTOR+1 BYTES_PER_SECTOR_SOURCE+1

; optimize FAIL (100, milf.pas), line = 313
	lda NUMBER_OF_SECTORS
	ldy NUMBER_OF_SECTORS+1
	jsr @printWORD._ay
	@printSTRING #CODEORIGIN+$0089
	lda BYTES_PER_SECTOR_SOURCE
	ldy BYTES_PER_SECTOR_SOURCE+1
	jsr @printWORD._ay
	@printSTRING #CODEORIGIN+$0097
	@printEOL
	jmp l_098F
l_096C

; optimize OK (milf.pas), line = 315

	mva BYTES_PER_SECTOR BYTES_PER_SECTOR_DEST
	mva BYTES_PER_SECTOR+1 BYTES_PER_SECTOR_DEST+1

; optimize FAIL (100, milf.pas), line = 316
	lda NUMBER_OF_SECTORS
	ldy NUMBER_OF_SECTORS+1
	jsr @printWORD._ay
	@printSTRING #CODEORIGIN+$0089
	lda BYTES_PER_SECTOR_DEST
	ldy BYTES_PER_SECTOR_DEST+1
	jsr @printWORD._ay
	@printSTRING #CODEORIGIN+$0097
	@printEOL
l_098F
l_0959

; optimize OK (milf.pas), line = 319

	mva #$01 SIORESULT

; optimize OK (milf.pas), line = 320

	lda DRIVE
	cmp #$01
	jne l_09C0

; optimize OK (milf.pas), line = 321

	mva #$01 SOURCE_DRIVE_NOT_CONFIGURABLE
	jne l_09CE
l_09C0

; optimize OK (milf.pas), line = 323

	mva #$01 DEST_DRIVE_NOT_CONFIGURABLE
l_09CE

; GenerateCaseStatementEpilog
	jmp a_0002
l_08F9
; --- For

; optimize OK (milf.pas), line = 328

	mva #$00 TMPBYTE

; optimize OK (milf.pas), line = 328

l_09DF
; --- ForToDoCondition

; optimize OK (milf.pas), line = 328

	lda TMPBYTE
	cmp #$0C
	jcs l_09ED

; optimize OK (milf.pas), line = 329

	sta TMPWORD
	lda #$06
	sta TMPWORD+1

; optimize OK (milf.pas), line = 330

	sta :bp+1
	ldy TMPWORD
	lda (:bp),y
	ldy TMPBYTE
	sta adr.PERCOMBLOCK,y

; --- ForToDoEpilog
	inc TMPBYTE					; inc ptr byte [CounterAddress]
	jne l_09DF
l_09ED

; optimize OK (milf.pas), line = 333

	lda adr.PERCOMBLOCK+$00
	sta :STACKORIGIN+9
	lda adr.PERCOMBLOCK+$02
	sta :eax
	lda #$00
	sta :ecx
	lda #$01
	sta :ecx+1
	lda #$00
	sta :eax+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX
	eif
	lda :eax
	add adr.PERCOMBLOCK+$03
	sta :ecx
	lda :eax+1
	adc #$00
	sta :ecx+1
	lda :STACKORIGIN+9
	sta :eax
	lda #$00
	sta :eax+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX
	eif
	lda :eax
	sta NUMBER_OF_SECTORS
	lda :eax+1
	sta NUMBER_OF_SECTORS+1

; optimize OK (milf.pas), line = 334

	lda adr.PERCOMBLOCK+$04
	add #$01
	sta :ecx
	lda #$00
	adc #$00
	sta :ecx+1
	lda NUMBER_OF_SECTORS
	sta :eax
	lda NUMBER_OF_SECTORS+1
	sta :eax+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX
	eif
	lda :eax
	sta NUMBER_OF_SECTORS
	lda :eax+1
	sta NUMBER_OF_SECTORS+1

; optimize OK (milf.pas), line = 335

	lda adr.PERCOMBLOCK+$06
	sta :eax+1
	lda adr.PERCOMBLOCK+$07
	sta BYTES_PER_SECTOR
	lda :eax+1
	sta BYTES_PER_SECTOR+1

; optimize OK (milf.pas), line = 337

	lda DRIVE
	cmp #$01
	jne l_0A52

; optimize OK (milf.pas), line = 337

	mva #$00 SOURCE_DRIVE_NOT_CONFIGURABLE
	jeq l_0A60
l_0A52

; optimize OK (milf.pas), line = 338

	mva #$00 DEST_DRIVE_NOT_CONFIGURABLE
l_0A60

; optimize OK (milf.pas), line = 340

	lda SILENT
	jne l_0A73

; optimize OK (milf.pas), line = 341

	lda DRIVE
	cmp #$01
	jne l_0A86

; optimize OK (milf.pas), line = 342

	mva BYTES_PER_SECTOR BYTES_PER_SECTOR_SOURCE
	mva BYTES_PER_SECTOR+1 BYTES_PER_SECTOR_SOURCE+1

; optimize FAIL (100, milf.pas), line = 343
	lda NUMBER_OF_SECTORS
	ldy NUMBER_OF_SECTORS+1
	jsr @printWORD._ay
	@printSTRING #CODEORIGIN+$0089
	lda BYTES_PER_SECTOR
	ldy BYTES_PER_SECTOR+1
	jsr @printWORD._ay
	@printSTRING #CODEORIGIN+$0097
	@printEOL
	jmp l_0AA9
l_0A86

; optimize OK (milf.pas), line = 345

	mva BYTES_PER_SECTOR BYTES_PER_SECTOR_DEST
	mva BYTES_PER_SECTOR+1 BYTES_PER_SECTOR_DEST+1

; optimize FAIL (100, milf.pas), line = 346
	lda NUMBER_OF_SECTORS
	ldy NUMBER_OF_SECTORS+1
	jsr @printWORD._ay
	@printSTRING #CODEORIGIN+$0089
	lda BYTES_PER_SECTOR
	ldy BYTES_PER_SECTOR+1
	jsr @printWORD._ay
	@printSTRING #CODEORIGIN+$0097
	@printEOL
l_0AA9
	jmp l_0ACB
l_0A73

; optimize OK (milf.pas), line = 349

	lda DRIVE
	cmp #$01
	jne l_0ADD

; optimize OK (milf.pas), line = 350

	mva BYTES_PER_SECTOR BYTES_PER_SECTOR_SOURCE
	mva BYTES_PER_SECTOR+1 BYTES_PER_SECTOR_SOURCE+1
	jmp l_0AEC
l_0ADD

; optimize OK (milf.pas), line = 352

	mva BYTES_PER_SECTOR BYTES_PER_SECTOR_DEST
	mva BYTES_PER_SECTOR+1 BYTES_PER_SECTOR_DEST+1
l_0AEC
l_0ACB

; GenerateCaseEpilog
a_0002

; ------------------------------------------------------------

DRIVE	= DATAORIGIN+$04A1
SILENT	= DATAORIGIN+$04A2
@FORTMP_09DC	= $0B

@VarData	= DRIVE
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	ERRORMESSAGE					; PROCEDURE

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x ERR
	dex

; optimize FAIL ('SYSTEM.STR_0732', milf.pas), line = 366
	inx
	mva ERR :STACKORIGIN,x
	jsr @expandToCARD.BYTE
	inx
	mva TMPSTRING :STACKORIGIN,x
	mva TMPSTRING+1 :STACKORIGIN+STACKWIDTH,x
	jsr SYSTEM.STR_0732

; optimize FAIL (100, milf.pas), line = 367
	@printSTRING #CODEORIGIN+$00A0

; optimize OK (milf.pas), line = 368

	lda ERR
	jpl l_0B15

; optimize FAIL (100, milf.pas), line = 369
	@printSTRING #CODEORIGIN+$00AA
	@printSTRING TMPSTRING
	@printEOL
	jmp l_0B28
l_0B15

; optimize FAIL (100, milf.pas), line = 370
	@printSTRING #CODEORIGIN+$00B2
	@printEOL
l_0B28

; ------------------------------------------------------------

ERR	= DATAORIGIN+$04A3

@VarData	= ERR
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	WRITEMENU					; PROCEDURE

; optimize FAIL (100, milf.pas), line = 378
	@printEOL

; optimize FAIL ('SYSTEM.STR_0732', milf.pas), line = 380
	inx
	mva SOURCE_DRIVE :STACKORIGIN,x
	jsr @expandToCARD.BYTE
	inx
	mva TMPSTRING :STACKORIGIN,x
	mva TMPSTRING+1 :STACKORIGIN+STACKWIDTH,x
	jsr SYSTEM.STR_0732

; optimize FAIL (100, milf.pas), line = 381
	@printSTRING #CODEORIGIN+$00B6
	@printSTRING TMPSTRING
	@printEOL

; optimize FAIL ('READPERCOM', milf.pas), line = 382
	inx
	mva SOURCE_DRIVE :STACKORIGIN,x
	inx
	mva #$00 :STACKORIGIN,x
	jsr READPERCOM

; optimize FAIL (100, milf.pas), line = 383
	@printSTRING #CODEORIGIN+$00CF
	@printEOL

; optimize OK (milf.pas), line = 384

	lda DEST_DRIVE
	cmp #$FF
	jcs l_0B58

; optimize FAIL ('SYSTEM.STR_0732', milf.pas), line = 385
	inx
	mva DEST_DRIVE :STACKORIGIN,x
	jsr @expandToCARD.BYTE
	inx
	mva TMPSTRING2 :STACKORIGIN,x
	mva TMPSTRING2+1 :STACKORIGIN+STACKWIDTH,x
	jsr SYSTEM.STR_0732

; optimize FAIL (100, milf.pas), line = 386
	@printSTRING #CODEORIGIN+$00F6
	@printSTRING TMPSTRING2
	@printEOL

; optimize FAIL ('READPERCOM', milf.pas), line = 387
	inx
	mva DEST_DRIVE :STACKORIGIN,x
	inx
	mva #$00 :STACKORIGIN,x
	jsr READPERCOM
	jmp l_0B76
l_0B58

; optimize FAIL (100, milf.pas), line = 389
	@printSTRING #CODEORIGIN+$0114
	@printEOL
l_0B76

; optimize FAIL (100, milf.pas), line = 392
	@printEOL

; optimize FAIL (100, milf.pas), line = 393
	@printSTRING #CODEORIGIN+$012F
	@printEOL

; optimize FAIL (100, milf.pas), line = 394
	@printSTRING #CODEORIGIN+$014D
	@printEOL

; optimize FAIL (100, milf.pas), line = 395
	@printSTRING #CODEORIGIN+$016C
	@printEOL

; optimize FAIL (100, milf.pas), line = 396
	@printSTRING #CODEORIGIN+$017E
	@printEOL

; optimize FAIL (100, milf.pas), line = 397
	@printSTRING #CODEORIGIN+$01A2
	@printEOL

; optimize FAIL (100, milf.pas), line = 398
	@printSTRING #CODEORIGIN+$01C7
	@printEOL

; optimize FAIL (100, milf.pas), line = 399
	@printEOL

; optimize FAIL (100, milf.pas), line = 400
	@printSTRING #CODEORIGIN+$01D9
	@printEOL

; optimize FAIL (100, milf.pas), line = 401
	@printSTRING #CODEORIGIN+$01EA
	@printEOL

; optimize FAIL (100, milf.pas), line = 402
	@printEOL
@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	SWAPDRIVES					; PROCEDURE

; optimize OK (milf.pas), line = 411

	lda DEST_DRIVE
	cmp #$FF
	jeq l_0BB3x
	lda SOURCE_DRIVE
	cmp #$FF
	jne l_0BB3
l_0BB3x

; optimize FAIL (100, milf.pas), line = 413
	@printSTRING #CODEORIGIN+$01FA
	@printEOL

; optimize FAIL (100, milf.pas), line = 414
	@printSTRING #CODEORIGIN+$0215
	@printEOL
	jmp l_0BC3
l_0BB3

; optimize OK (milf.pas), line = 418

	mva SOURCE_DRIVE TMPBYTE

; optimize OK (milf.pas), line = 419

	mva DEST_DRIVE SOURCE_DRIVE

; optimize OK (milf.pas), line = 420

	mva TMPBYTE DEST_DRIVE

; optimize OK (milf.pas), line = 422

	mva SOURCE_DRIVE_NOT_CONFIGURABLE TMPBOOL

; optimize OK (milf.pas), line = 423

	mva DEST_DRIVE_NOT_CONFIGURABLE SOURCE_DRIVE_NOT_CONFIGURABLE

; optimize OK (milf.pas), line = 424

	mva TMPBOOL DEST_DRIVE_NOT_CONFIGURABLE

; optimize OK (milf.pas), line = 426

	mva BYTES_PER_SECTOR_SOURCE TMPWORD
	mva BYTES_PER_SECTOR_SOURCE+1 TMPWORD+1

; optimize OK (milf.pas), line = 427

	mva BYTES_PER_SECTOR_DEST BYTES_PER_SECTOR_SOURCE
	mva BYTES_PER_SECTOR_DEST+1 BYTES_PER_SECTOR_SOURCE+1

; optimize OK (milf.pas), line = 428

	mva TMPWORD BYTES_PER_SECTOR_DEST
	mva TMPWORD+1 BYTES_PER_SECTOR_DEST+1

; optimize FAIL (100, milf.pas), line = 430
	@printSTRING #CODEORIGIN+$0229
	@printEOL
l_0BC3

; optimize FAIL ('PRESSKEY', milf.pas), line = 434
	jsr PRESSKEY

; optimize FAIL ('WRITEMENU', milf.pas), line = 436
	jsr WRITEMENU
@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	FORMAT						; PROCEDURE

; optimize FAIL ('CLEARKEYS', milf.pas), line = 446
	jsr CLEARKEYS

; optimize FAIL ('CRT.DELAY', milf.pas), line = 448
	inx
	mva #$0A :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	jsr CRT.DELAY

; optimize FAIL (100, milf.pas), line = 451
	@printSTRING #CODEORIGIN+$023E
	@printEOL

; optimize FAIL (100, milf.pas), line = 452
	@printSTRING #CODEORIGIN+$0250
	@printEOL
FORMATSEL

; optimize FAIL ('CRT.KEYPRESSED', milf.pas), line = 455
	jsr CRT.KEYPRESSED
	dex
	lda :STACKORIGIN+1,x
	jeq l_0C12

; optimize FAIL ('CRT.READKEY', milf.pas), line = 455
	jsr CRT.READKEY
	mva :STACKORIGIN,x KEY
	dex
	jmp l_0C20
l_0C12
	jmp FORMATSEL
l_0C20

; ------------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx
	mva KEY :STACKORIGIN,x

; GenerateCaseProlog
	dex

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #83
	beq @+

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #115
	jne l_0C2E
@

; optimize OK (milf.pas), line = 458

	mva SOURCE_DRIVE TMPBYTE2

; optimize OK (milf.pas), line = 458

	mva BYTES_PER_SECTOR_SOURCE TMPWORD
	mva BYTES_PER_SECTOR_SOURCE+1 TMPWORD+1

; GenerateCaseStatementEpilog
	jmp a_0003
l_0C2E

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #68
	beq @+

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #100
	jne l_0C44
@

; optimize OK (milf.pas), line = 459

	mva DEST_DRIVE TMPBYTE2

; optimize OK (milf.pas), line = 459

	mva BYTES_PER_SECTOR_DEST TMPWORD
	mva BYTES_PER_SECTOR_DEST+1 TMPWORD+1

; GenerateCaseStatementEpilog
	jmp a_0003
l_0C44

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #27
	jne l_0C58
@
	jmp EXITFORMAT

; GenerateCaseStatementEpilog
	jmp a_0003
l_0C58
	jmp FORMATSEL

; GenerateCaseEpilog
a_0003

; optimize FAIL ('CLEARKEYS', milf.pas), line = 464
	jsr CLEARKEYS

; optimize FAIL ('CRT.DELAY', milf.pas), line = 465
	inx
	mva #$02 :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	jsr CRT.DELAY

; optimize OK (milf.pas), line = 467

	ldy #1
	lda TMPBYTE2
	cmp SOURCE_DRIVE
	beq @+
	dey
@
	tya
	and SOURCE_DRIVE_NOT_CONFIGURABLE
	sta :STACKORIGIN+9
	ldy #1
	lda TMPBYTE2
	cmp DEST_DRIVE
	beq @+
	dey
@
	tya
	and DEST_DRIVE_NOT_CONFIGURABLE
	ora :STACKORIGIN+9
	jeq l_0C90

; optimize FAIL (100, milf.pas), line = 469
	@printEOL

; optimize FAIL (100, milf.pas), line = 470
	@printSTRING #CODEORIGIN+$0267
	@printEOL

; optimize FAIL (100, milf.pas), line = 471
	@printSTRING #CODEORIGIN+$0287
	@printSTRING #CODEORIGIN+$028E
	@printSTRING #CODEORIGIN+$029B
	@printEOL

; optimize FAIL (100, milf.pas), line = 472
	@printSTRING #CODEORIGIN+$02A7
	@printEOL
NOTPERCOM

; optimize FAIL ('CRT.KEYPRESSED', milf.pas), line = 475
	jsr CRT.KEYPRESSED
	dex
	lda :STACKORIGIN+1,x
	jeq l_0CAA

; optimize FAIL ('CRT.READKEY', milf.pas), line = 475
	jsr CRT.READKEY
	mva :STACKORIGIN,x KEY
	dex
	jmp l_0CB8
l_0CAA
	jmp NOTPERCOM
l_0CB8

; ------------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx
	mva KEY :STACKORIGIN,x

; GenerateCaseProlog
	dex

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #83
	beq @+

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #115
	jne l_0CC6
@

; optimize FAIL (100, milf.pas), line = 478
	@printEOL

; optimize FAIL (100, milf.pas), line = 478
	@printSTRING #CODEORIGIN+$02C1
	@printEOL

; optimize FAIL ('EXEC_SIO', milf.pas), line = 478
	inx
	mva TMPBYTE2 :STACKORIGIN,x
	inx
	mva #$21 :STACKORIGIN,x
	inx
	mva #$40 :STACKORIGIN,x
	inx
	sta :STACKORIGIN,x
	inx
	mva #$00 :STACKORIGIN,x
	mva #$60 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$80 :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$01 :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	jsr EXEC_SIO

; GenerateCaseStatementEpilog
	jmp a_0004
l_0CC6

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #69
	beq @+

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #101
	jne l_0CDE
@

; optimize FAIL (100, milf.pas), line = 479
	@printEOL

; optimize FAIL (100, milf.pas), line = 479
	@printSTRING #CODEORIGIN+$02C1
	@printEOL

; optimize FAIL ('EXEC_SIO', milf.pas), line = 479
	inx
	mva TMPBYTE2 :STACKORIGIN,x
	inx
	mva #$22 :STACKORIGIN,x
	inx
	mva #$40 :STACKORIGIN,x
	inx
	sta :STACKORIGIN,x
	inx
	mva #$00 :STACKORIGIN,x
	mva #$60 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$80 :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$01 :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	jsr EXEC_SIO

; GenerateCaseStatementEpilog
	jmp a_0004
l_0CDE

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #27
	jne l_0CF4
@
	jmp EXITFORMAT

; GenerateCaseStatementEpilog
	jmp a_0004
l_0CF4
	jmp NOTPERCOM

; GenerateCaseEpilog
a_0004
	jmp l_0D04
l_0C90

; optimize FAIL (100, milf.pas), line = 485
	@printEOL

; optimize FAIL (100, milf.pas), line = 486
	@printSTRING #CODEORIGIN+$02C1
	@printEOL

; optimize FAIL ('EXEC_SIO', milf.pas), line = 487
	inx
	mva TMPBYTE2 :STACKORIGIN,x
	inx
	mva #$21 :STACKORIGIN,x
	inx
	mva #$40 :STACKORIGIN,x
	inx
	sta :STACKORIGIN,x
	inx
	mva #$00 :STACKORIGIN,x
	mva #$60 :STACKORIGIN+STACKWIDTH,x
	inx
	mva TMPWORD :STACKORIGIN,x
	mva TMPWORD+1 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$01 :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	jsr EXEC_SIO
l_0D04

; optimize FAIL ('ERRORMESSAGE', milf.pas), line = 490
	inx
	mva SIORESULT :STACKORIGIN,x
	jsr ERRORMESSAGE
EXITFORMAT

; optimize FAIL ('PRESSKEY', milf.pas), line = 494
	jsr PRESSKEY

; optimize FAIL ('WRITEMENU', milf.pas), line = 496
	jsr WRITEMENU
@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	CHANGEDRIVES					; PROCEDURE

; optimize FAIL ('CLEARKEYS', milf.pas), line = 510
	jsr CLEARKEYS

; optimize FAIL ('CRT.DELAY', milf.pas), line = 511
	inx
	mva #$02 :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	jsr CRT.DELAY

; optimize OK (milf.pas), line = 513

	mva #$00 TMPBYTE3

; --- WhileProlog
	jmp l_0D25
l_0D26

; optimize FAIL (100, milf.pas), line = 517
	@printEOL

; optimize FAIL (100, milf.pas), line = 518
	@printSTRING #CODEORIGIN+$02E8
	inx
	lda TMPBYTE3
	asl @
	tay
	mva adr.TMPARR,y :STACKORIGIN,x
	mva adr.TMPARR+1,y :STACKORIGIN+STACKWIDTH,x
	lda :STACKORIGIN,x
	ldy :STACKORIGIN+STACKWIDTH,x
	jsr @printSTRING
	dex
	@printSTRING #CODEORIGIN+$02F1
	@printEOL
DRIVESELECTIONSOURCE

; optimize FAIL ('CRT.KEYPRESSED', milf.pas), line = 522
	jsr CRT.KEYPRESSED
	dex
	lda :STACKORIGIN+1,x
	jeq l_0D3F

; optimize FAIL ('CRT.READKEY', milf.pas), line = 522
	jsr CRT.READKEY
	mva :STACKORIGIN,x KEY
	dex
	jmp l_0D4D
l_0D3F
	jmp DRIVESELECTIONSOURCE
l_0D4D

; optimize OK (milf.pas), line = 524

	lda KEY
	cmp #$1B
	jne l_0D5F

	jmp b_0D26					; break
l_0D5F

; optimize OK (milf.pas), line = 526

	lda KEY
	sub #$30
	sta SELECTED_DRIVE

; optimize OK (milf.pas), line = 528

	cmp #$01
	jcc l_0D8Ax
	cmp #$09
	jcc l_0D8A
l_0D8Ax

; optimize FAIL (100, milf.pas), line = 529
	@printEOL

; optimize FAIL (100, milf.pas), line = 530
	@printSTRING #CODEORIGIN+$02E8
	inx
	lda TMPBYTE3
	asl @
	tay
	mva adr.TMPARR,y :STACKORIGIN,x
	mva adr.TMPARR+1,y :STACKORIGIN+STACKWIDTH,x
	lda :STACKORIGIN,x
	ldy :STACKORIGIN+STACKWIDTH,x
	jsr @printSTRING
	dex
	@printSTRING #CODEORIGIN+$02F1
	@printEOL
	jmp DRIVESELECTIONSOURCE
l_0D8A

; optimize FAIL ('READPERCOM', milf.pas), line = 534
	inx
	mva SELECTED_DRIVE :STACKORIGIN,x
	inx
	mva #$01 :STACKORIGIN,x
	jsr READPERCOM

; optimize OK (milf.pas), line = 536

	lda SIORESULT
	jpl l_0DB3

; optimize FAIL (100, milf.pas), line = 537
	@printEOL

; optimize FAIL (100, milf.pas), line = 538
	@printSTRING #CODEORIGIN+$02E8
	inx
	lda TMPBYTE3
	asl @
	tay
	mva adr.TMPARR,y :STACKORIGIN,x
	mva adr.TMPARR+1,y :STACKORIGIN+STACKWIDTH,x
	lda :STACKORIGIN,x
	ldy :STACKORIGIN+STACKWIDTH,x
	jsr @printSTRING
	dex
	@printSTRING #CODEORIGIN+$02F1
	@printEOL
	jmp DRIVESELECTIONSOURCE
l_0DB3

; optimize OK (milf.pas), line = 542

	lda TMPBYTE3
	jne l_0DD7

; optimize OK (milf.pas), line = 543

	mva SELECTED_DRIVE SOURCE_DRIVE
	jmp l_0DE7
l_0DD7

; optimize OK (milf.pas), line = 545

	lda SELECTED_DRIVE
	cmp SOURCE_DRIVE
	jne l_0DFB

; optimize FAIL (100, milf.pas), line = 546
	@printEOL

; optimize FAIL (100, milf.pas), line = 547
	@printSTRING #CODEORIGIN+$0306
	@printEOL

; optimize FAIL (100, milf.pas), line = 548
	@printSTRING #CODEORIGIN+$0329
	@printEOL

; optimize FAIL (100, milf.pas), line = 549
	@printEOL

; optimize FAIL (100, milf.pas), line = 550
	@printSTRING #CODEORIGIN+$02E8
	inx
	lda TMPBYTE3
	asl @
	tay
	mva adr.TMPARR,y :STACKORIGIN,x
	mva adr.TMPARR+1,y :STACKORIGIN+STACKWIDTH,x
	lda :STACKORIGIN,x
	ldy :STACKORIGIN+STACKWIDTH,x
	jsr @printSTRING
	dex
	@printSTRING #CODEORIGIN+$02F1
	@printEOL
	jmp DRIVESELECTIONSOURCE
l_0DFB

; optimize OK (milf.pas), line = 553

	mva SELECTED_DRIVE DEST_DRIVE
l_0DE7

; optimize FAIL ('CLEARKEYS', milf.pas), line = 556
	jsr CLEARKEYS

; optimize FAIL ('CRT.DELAY', milf.pas), line = 557
	inx
	mva #$32 :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	jsr CRT.DELAY

; optimize FAIL (0, milf.pas), line = 559
	inc TMPBYTE3
l_0D25

; optimize OK (milf.pas), line = 515

	lda TMPBYTE3
	cmp #$02
	jcc l_0D26
b_0D26

; optimize FAIL ('WRITEMENU', milf.pas), line = 563
	jsr WRITEMENU

; ------------------------------------------------------------

adr.TMPARR	= CODEORIGIN+$071B
.var TMPARR	= adr.TMPARR .word
TMPBYTE3	= DATAORIGIN+$04A4

@VarData	= TMPBYTE3
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	WRITEPERCOM					; PROCEDURE

; optimize FAIL ('CLEARKEYS', milf.pas), line = 573
	jsr CLEARKEYS

; optimize FAIL ('CRT.DELAY', milf.pas), line = 575
	inx
	mva #$0A :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	jsr CRT.DELAY

; optimize FAIL (100, milf.pas), line = 577
	@printSTRING #CODEORIGIN+$023E
	@printEOL

; optimize FAIL (100, milf.pas), line = 578
	@printSTRING #CODEORIGIN+$0250
	@printEOL
WRITEPERCOMSELDRIVE

; optimize FAIL ('CRT.KEYPRESSED', milf.pas), line = 582
	jsr CRT.KEYPRESSED
	dex
	lda :STACKORIGIN+1,x
	jeq l_0E44

; optimize FAIL ('CRT.READKEY', milf.pas), line = 582
	jsr CRT.READKEY
	mva :STACKORIGIN,x KEY
	dex
	jmp l_0E52
l_0E44
	jmp WRITEPERCOMSELDRIVE
l_0E52

; ------------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx
	mva KEY :STACKORIGIN,x

; GenerateCaseProlog
	dex

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #83
	beq @+

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #115
	jne l_0E60
@

; optimize OK (milf.pas), line = 586

	mva SOURCE_DRIVE TMPBYTE2

; optimize OK (milf.pas), line = 587

	lda SOURCE_DRIVE_NOT_CONFIGURABLE
	jeq l_0E72

; optimize FAIL (100, milf.pas), line = 588
	@printSTRING #CODEORIGIN+$0348
	@printEOL

; optimize FAIL (100, milf.pas), line = 589
	@printSTRING #CODEORIGIN+$0369
	@printEOL

; --- RepeatUntilProlog
l_0E7A

; optimize FAIL ('CRT.KEYPRESSED', milf.pas), line = 590
	jsr CRT.KEYPRESSED
	dex
	lda :STACKORIGIN+1,x
	jeq l_0E7A
	jmp WRITEPERCOMABORT
l_0E72

; GenerateCaseStatementEpilog
	jmp a_0005
l_0E60

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #68
	beq @+

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #100
	jne l_0E8C
@

; optimize OK (milf.pas), line = 595

	mva DEST_DRIVE TMPBYTE2

; optimize OK (milf.pas), line = 596

	lda SOURCE_DRIVE_NOT_CONFIGURABLE
	jeq l_0E9E

; optimize FAIL (100, milf.pas), line = 597
	@printSTRING #CODEORIGIN+$0348
	@printEOL

; optimize FAIL (100, milf.pas), line = 598
	@printSTRING #CODEORIGIN+$0369
	@printEOL

; --- RepeatUntilProlog
l_0EA6

; optimize FAIL ('CRT.KEYPRESSED', milf.pas), line = 599
	jsr CRT.KEYPRESSED
	dex
	lda :STACKORIGIN+1,x
	jeq l_0EA6
	jmp WRITEPERCOMABORT
l_0E9E

; GenerateCaseStatementEpilog
	jmp a_0005
l_0E8C

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #27
	jne l_0EB6
@
	jmp WRITEPERCOMABORT

; GenerateCaseStatementEpilog
	jmp a_0005
l_0EB6
	jmp WRITEPERCOMSELDRIVE

; GenerateCaseEpilog
a_0005

; optimize FAIL ('CLEARKEYS', milf.pas), line = 607
	jsr CLEARKEYS

; optimize FAIL ('CRT.DELAY', milf.pas), line = 608
	inx
	mva #$0A :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	jsr CRT.DELAY

; optimize FAIL (100, milf.pas), line = 610
	@printEOL

; optimize FAIL (100, milf.pas), line = 611
	@printSTRING #CODEORIGIN+$0379
	@printEOL

; optimize FAIL (100, milf.pas), line = 612
	@printSTRING #CODEORIGIN+$0396
	@printEOL

; optimize FAIL (100, milf.pas), line = 613
	@printSTRING #CODEORIGIN+$03AA
	@printEOL

; optimize FAIL (100, milf.pas), line = 614
	@printSTRING #CODEORIGIN+$03BE
	@printEOL

; optimize FAIL (100, milf.pas), line = 615
	@printSTRING #CODEORIGIN+$03D2
	@printEOL

; optimize FAIL (100, milf.pas), line = 616
	@printSTRING #CODEORIGIN+$03E6
	@printEOL
PERCOMSEL

; optimize FAIL ('CRT.KEYPRESSED', milf.pas), line = 620
	jsr CRT.KEYPRESSED
	dex
	lda :STACKORIGIN+1,x
	jeq l_0EDC

; optimize FAIL ('CRT.READKEY', milf.pas), line = 620
	jsr CRT.READKEY
	mva :STACKORIGIN,x KEY
	dex
l_0EDC

; ------------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx
	mva KEY :STACKORIGIN,x

; GenerateCaseProlog
	dex

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #49
	jne l_0EEF
@
; --- For

; optimize OK (milf.pas), line = 624

	mva #$00 TMPBYTE

; optimize OK (milf.pas), line = 624

l_0EF8
; --- ForToDoCondition

; optimize OK (milf.pas), line = 624

	lda TMPBYTE
	cmp #$0C
	jcs l_0F06

; optimize OK (milf.pas), line = 625

	sta TMPWORD
	lda #$06
	sta TMPWORD+1

; optimize OK (milf.pas), line = 626

	ldy TMPBYTE
	lda adr.SSSD,y
	sta :STACKORIGIN+10
	lda TMPWORD+1
	sta :bp+1
	ldy TMPWORD
	lda :STACKORIGIN+10
	sta (:bp),y

; --- ForToDoEpilog
	inc TMPBYTE					; inc ptr byte [CounterAddress]
	jne l_0EF8
l_0F06

; optimize OK (milf.pas), line = 628

	mva #$80 REQUESTEDSECTORSIZE
	mva #$00 REQUESTEDSECTORSIZE+1

; optimize OK (milf.pas), line = 629

	mva #$D0 REQUESTEDSECTORS
	mva #$02 REQUESTEDSECTORS+1

; GenerateCaseStatementEpilog
	jmp a_0006
l_0EEF

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #50
	jne l_0F2F
@
; --- For

; optimize OK (milf.pas), line = 632

	mva #$00 TMPBYTE

; optimize OK (milf.pas), line = 632

l_0F38
; --- ForToDoCondition

; optimize OK (milf.pas), line = 632

	lda TMPBYTE
	cmp #$0C
	jcs l_0F46

; optimize OK (milf.pas), line = 633

	sta TMPWORD
	lda #$06
	sta TMPWORD+1

; optimize OK (milf.pas), line = 634

	ldy TMPBYTE
	lda adr.SSED,y
	sta :STACKORIGIN+10
	lda TMPWORD+1
	sta :bp+1
	ldy TMPWORD
	lda :STACKORIGIN+10
	sta (:bp),y

; --- ForToDoEpilog
	inc TMPBYTE					; inc ptr byte [CounterAddress]
	jne l_0F38
l_0F46

; optimize OK (milf.pas), line = 636

	mva #$80 REQUESTEDSECTORSIZE
	mva #$00 REQUESTEDSECTORSIZE+1

; optimize OK (milf.pas), line = 637

	mva #$10 REQUESTEDSECTORS
	mva #$04 REQUESTEDSECTORS+1

; GenerateCaseStatementEpilog
	jmp a_0006
l_0F2F

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #51
	jne l_0F6F
@
; --- For

; optimize OK (milf.pas), line = 640

	mva #$00 TMPBYTE

; optimize OK (milf.pas), line = 640

l_0F78
; --- ForToDoCondition

; optimize OK (milf.pas), line = 640

	lda TMPBYTE
	cmp #$0C
	jcs l_0F86

; optimize OK (milf.pas), line = 641

	sta TMPWORD
	lda #$06
	sta TMPWORD+1

; optimize OK (milf.pas), line = 642

	ldy TMPBYTE
	lda adr.SSDD,y
	sta :STACKORIGIN+10
	lda TMPWORD+1
	sta :bp+1
	ldy TMPWORD
	lda :STACKORIGIN+10
	sta (:bp),y

; --- ForToDoEpilog
	inc TMPBYTE					; inc ptr byte [CounterAddress]
	jne l_0F78
l_0F86

; optimize OK (milf.pas), line = 644

	mva #$00 REQUESTEDSECTORSIZE
	mva #$01 REQUESTEDSECTORSIZE+1

; optimize OK (milf.pas), line = 645

	mva #$D0 REQUESTEDSECTORS
	mva #$02 REQUESTEDSECTORS+1

; GenerateCaseStatementEpilog
	jmp a_0006
l_0F6F

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #52
	jne l_0FAF
@
; --- For

; optimize OK (milf.pas), line = 648

	mva #$00 TMPBYTE

; optimize OK (milf.pas), line = 648

l_0FB8
; --- ForToDoCondition

; optimize OK (milf.pas), line = 648

	lda TMPBYTE
	cmp #$0C
	jcs l_0FC6

; optimize OK (milf.pas), line = 649

	sta TMPWORD
	lda #$06
	sta TMPWORD+1

; optimize OK (milf.pas), line = 650

	ldy TMPBYTE
	lda adr.DSDD,y
	sta :STACKORIGIN+10
	lda TMPWORD+1
	sta :bp+1
	ldy TMPWORD
	lda :STACKORIGIN+10
	sta (:bp),y

; --- ForToDoEpilog
	inc TMPBYTE					; inc ptr byte [CounterAddress]
	jne l_0FB8
l_0FC6

; optimize OK (milf.pas), line = 652

	mva #$00 REQUESTEDSECTORSIZE
	mva #$01 REQUESTEDSECTORSIZE+1

; optimize OK (milf.pas), line = 653

	mva #$A0 REQUESTEDSECTORS
	mva #$05 REQUESTEDSECTORS+1

; GenerateCaseStatementEpilog
	jmp a_0006
l_0FAF

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #53
	jne l_0FEF
@
; --- For

; optimize OK (milf.pas), line = 656

	mva #$00 TMPBYTE

; optimize OK (milf.pas), line = 656

l_0FF8
; --- ForToDoCondition

; optimize OK (milf.pas), line = 656

	lda TMPBYTE
	cmp #$0C
	jcs l_1006

; optimize OK (milf.pas), line = 657

	sta TMPWORD
	lda #$06
	sta TMPWORD+1

; optimize OK (milf.pas), line = 658

	ldy TMPBYTE
	lda adr.DSQD,y
	sta :STACKORIGIN+10
	lda TMPWORD+1
	sta :bp+1
	ldy TMPWORD
	lda :STACKORIGIN+10
	sta (:bp),y

; --- ForToDoEpilog
	inc TMPBYTE					; inc ptr byte [CounterAddress]
	jne l_0FF8
l_1006

; optimize OK (milf.pas), line = 660

	mva #$00 REQUESTEDSECTORSIZE
	mva #$01 REQUESTEDSECTORSIZE+1

; optimize OK (milf.pas), line = 661

	mva #$40 REQUESTEDSECTORS
	mva #$0B REQUESTEDSECTORS+1

; GenerateCaseStatementEpilog
	jmp a_0006
l_0FEF

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #27
	jne l_102F
@
	jmp WRITEPERCOMABORT

; GenerateCaseStatementEpilog
	jmp a_0006
l_102F
	jmp PERCOMSEL

; GenerateCaseEpilog
a_0006

; optimize FAIL ('EXEC_SIO', milf.pas), line = 668
	inx
	mva TMPBYTE2 :STACKORIGIN,x
	inx
	mva #$4F :STACKORIGIN,x
	inx
	mva #$80 :STACKORIGIN,x
	inx
	mva #$07 :STACKORIGIN,x
	inx
	mva #$00 :STACKORIGIN,x
	mva #$06 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$0C :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$00 :STACKORIGIN,x
	sta :STACKORIGIN+STACKWIDTH,x
	jsr EXEC_SIO

; optimize FAIL (100, milf.pas), line = 670
	@printEOL

; optimize FAIL ('ERRORMESSAGE', milf.pas), line = 671
	inx
	mva SIORESULT :STACKORIGIN,x
	jsr ERRORMESSAGE

; optimize OK (milf.pas), line = 673

	lda SIORESULT
	cmp #$01
	jne l_1059

; optimize FAIL ('READPERCOM', milf.pas), line = 674
	inx
	mva TMPBYTE2 :STACKORIGIN,x
	inx
	mva #$01 :STACKORIGIN,x
	jsr READPERCOM

; optimize OK (milf.pas), line = 675

	lda REQUESTEDSECTORS+1
	cmp NUMBER_OF_SECTORS+1
	bne @+
	lda REQUESTEDSECTORS
	cmp NUMBER_OF_SECTORS
@
	jne l_107D
	lda REQUESTEDSECTORSIZE+1
	cmp BYTES_PER_SECTOR+1
	bne @+
	lda REQUESTEDSECTORSIZE
	cmp BYTES_PER_SECTOR
@
	jne l_107D

; optimize FAIL (100, milf.pas), line = 676
	@printSTRING #CODEORIGIN+$03FA
	@printEOL
	jmp l_108A
l_107D

; optimize FAIL (100, milf.pas), line = 678
	@printSTRING #CODEORIGIN+$0413
	@printEOL

; optimize FAIL (100, milf.pas), line = 679
	@printSTRING #CODEORIGIN+$0438
	@printEOL
l_108A
l_1059

; optimize FAIL ('PRESSKEY', milf.pas), line = 683
	jsr PRESSKEY
WRITEPERCOMABORT

; optimize FAIL ('WRITEMENU', milf.pas), line = 687
	jsr WRITEMENU

; ------------------------------------------------------------

@FORTMP_0EF5	= $0B
@FORTMP_0F35	= $0B
@FORTMP_0F75	= $0B
@FORTMP_0FB5	= $0B
@FORTMP_0FF5	= $0B
@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	COPYERROR					; FUNCTION

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x OPERATION
	dex

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x CURRENT_SECTOR
	mva :STACKORIGIN+STACKWIDTH,x CURRENT_SECTOR+1
	dex

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x SIORESULTC
	dex

; optimize OK (milf.pas), line = 697

	lda OPERATION
	cmp #$01
	jne l_10B3
	ldy #256-8
	mva:rne CODEORIGIN+$045E+8-256,y adr.C+8-256,y+
	jmp l_10BD
l_10B3
	ldy #256-8
	mva:rne CODEORIGIN+$0467+8-256,y adr.C+8-256,y+
l_10BD

; optimize FAIL (100, milf.pas), line = 700
	@printEOL

; optimize FAIL (100, milf.pas), line = 701
	@printEOL

; optimize FAIL (100, milf.pas), line = 702
	@printSTRING #CODEORIGIN+$0470
	lda SIORESULTC
	jsr @printBYTE._a
	@print #$20
	@printSTRING C
	@printSTRING #CODEORIGIN+$0478
	lda CURRENT_SECTOR
	ldy CURRENT_SECTOR+1
	jsr @printWORD._ay
	@print #$2E
	@printEOL

; optimize FAIL (100, milf.pas), line = 703
	@printSTRING #CODEORIGIN+$0482
	@printSTRING #CODEORIGIN+$048F
	@printSTRING #CODEORIGIN+$049C
	@printEOL

; optimize OK (milf.pas), line = 705

	lda OPERATION
	cmp #$01
	jne l_10F3

; optimize FAIL (100, milf.pas), line = 706
	@printSTRING #CODEORIGIN+$04A7
	@printEOL
l_10F3

; optimize FAIL (100, milf.pas), line = 709
	@printEOL

; optimize FAIL ('CLEARKEYS', milf.pas), line = 711
	jsr CLEARKEYS

; optimize FAIL ('CRT.DELAY', milf.pas), line = 712
	inx
	mva #$02 :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	jsr CRT.DELAY
COPYERRORKEY

; optimize FAIL ('CRT.KEYPRESSED', milf.pas), line = 716
	jsr CRT.KEYPRESSED
	dex
	lda :STACKORIGIN+1,x
	jeq l_1106

; optimize FAIL ('CRT.READKEY', milf.pas), line = 716
	jsr CRT.READKEY
	mva :STACKORIGIN,x KEY
	dex
	jmp l_1114
l_1106
	jmp COPYERRORKEY
l_1114

; ------------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx
	mva KEY :STACKORIGIN,x

; GenerateCaseProlog
	dex

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #65
	beq @+

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #97
	jne l_1122
@

; optimize OK (milf.pas), line = 719

	mva #$01 RESULT

; GenerateCaseStatementEpilog
	jmp a_0007
l_1122

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #82
	beq @+

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #114
	jne l_1131
@

; optimize OK (milf.pas), line = 720

	mva #$02 RESULT

; GenerateCaseStatementEpilog
	jmp a_0007
l_1131

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #83
	beq @+

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #115
	jne l_1140
@

; optimize OK (milf.pas), line = 721

	mva #$03 RESULT

; GenerateCaseStatementEpilog
	jmp a_0007
l_1140

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #87
	beq @+

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #119
	jne l_114F
@

; optimize OK (milf.pas), line = 722

	mva #$04 RESULT

; GenerateCaseStatementEpilog
	jmp a_0007
l_114F
	jmp COPYERRORKEY

; GenerateCaseEpilog
a_0007
@exit

; ------------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx
	mva RESULT :STACKORIGIN,x

	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif

; ------------------------------------------------------------

SIORESULTC	= DATAORIGIN+$04A5
CURRENT_SECTOR	= DATAORIGIN+$04A6
OPERATION	= DATAORIGIN+$04A8
RESULT	= DATAORIGIN+$04A9
adr.C	= DATAORIGIN+$04AA
.var C	= adr.C .word

@VarData	= SIORESULTC
@VarDataSize	= 261

	rts						; ret
.endl

.local	WRITELOG					; PROCEDURE

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	mva :STACKORIGIN,x LOGFILESIZE
	mva :STACKORIGIN+STACKWIDTH,x LOGFILESIZE+1
	dex

; optimize OK (milf.pas), line = 737

	mva #$00 LOGFILEBUFFER
	mva #$62 LOGFILEBUFFER+1

; optimize OK (milf.pas), line = 738

	lda #$07
	sta :ecx
	lda #$00
	sta :ecx+1
	lda LOGFILESIZE
	sta :eax
	lda LOGFILESIZE+1
	sta :eax+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX
	eif
	lda :eax
	sta LOGFILESIZE
	lda :eax+1
	sta LOGFILESIZE+1
WRITELOGDRIVEDIALOG

; optimize FAIL ('CLEARKEYS', milf.pas), line = 742
	jsr CLEARKEYS

; optimize FAIL ('CLEARBUFFER', milf.pas), line = 743
	jsr CLEARBUFFER

; optimize FAIL (100, milf.pas), line = 745
	@printEOL

; optimize FAIL (100, milf.pas), line = 746
	@printSTRING #CODEORIGIN+$04C7
	@printEOL

; optimize FAIL (100, milf.pas), line = 747
	@printSTRING #CODEORIGIN+$04EA
	@printEOL

; optimize FAIL ('GETSTRING', milf.pas), line = 749
	inx
	mva #$10 :STACKORIGIN,x
	jsr GETSTRING

; optimize FAIL ('BREAKPRESSED', milf.pas), line = 751
	jsr BREAKPRESSED
	dex
	lda :STACKORIGIN+1,x
	jeq l_1186

; optimize FAIL (100, milf.pas), line = 752
	@printSTRING #CODEORIGIN+$04FE
	@printEOL
	jmp WRITELOGEXIT
l_1186

; optimize FAIL ('PARSEINPUT', milf.pas), line = 756
	inx
	mva #$10 :STACKORIGIN,x
	jsr PARSEINPUT

; optimize OK (milf.pas), line = 758

	ldy #$02
	lda adr.TMPSTRING+$02
	cmp #$30
	jcc l_11AEx
	cmp #$3A
	jcc l_11AE
l_11AEx
	jmp WRITELOGDRIVEDIALOG
l_11AE
; AssignFile

; optimize OK (milf.pas), line = 760

	mwy F :bp2
	ldy #s@file.pfname
	lda TMPSTRING
	sta (:bp2),y
	iny
	lda TMPSTRING+1
	sta (:bp2),y

; optimize OK (milf.pas), line = 760

	ldy #s@file.status
	lda #$00
	sta (:bp2),y
; Rewrite

; optimize OK (milf.pas), line = 761

	ldy #s@file.record
	lda #$01
	sta (:bp2),y
	iny
	lda #$00
	sta (:bp2),y

	txa:pha
	clc
	@openfile F, #8
	pla:tax

; BlockWrite

; optimize OK (milf.pas), line = 762

	mwy F :bp2
	ldy #s@file.buffer
	lda LOGFILEBUFFER
	sta (:bp2),y
	iny
	lda LOGFILEBUFFER+1
	sta (:bp2),y

; optimize OK (milf.pas), line = 762

	ldy #s@file.nrecord
	lda LOGFILESIZE
	sta (:bp2),y
	iny
	lda LOGFILESIZE+1
	sta (:bp2),y

	txa:pha
	clc
	@readfile F, #11
	pla:tax

; optimize FAIL (100, milf.pas), line = 764
	@printEOL

; optimize OK (milf.pas), line = 766

	lda SYSTEM.IORESULT
	jpl l_11DA

; optimize FAIL (100, milf.pas), line = 767
	@printSTRING #CODEORIGIN+$0470
	lda SYSTEM.IORESULT
	jsr @printBYTE._a
	@printEOL
	jmp l_11EF
l_11DA

; optimize FAIL (100, milf.pas), line = 769
	@printSTRING #CODEORIGIN+$051B
	@printEOL
l_11EF
; CloseFile

	txa:pha
	clc
	@closefile F
	pla:tax

WRITELOGEXIT

; ------------------------------------------------------------

LOGFILESIZE	= DATAORIGIN+$05AA
LOGFILEBUFFER	= DATAORIGIN+$05AC

@VarData	= LOGFILESIZE
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	PUTTOLOG					; PROCEDURE

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	mva :STACKORIGIN,x INFO
	dex

; optimize OK (milf.pas), line = 788

	lda SECTORS_TO_READ+1
	cmp #$0B
	bne @+
	lda SECTORS_TO_READ
	cmp #$41
@
	jcs l_120A

; optimize FAIL ('SYSTEM.STR_0732', milf.pas), line = 789
	inx
	mva CURRENT_SECTOR :STACKORIGIN,x
	mva CURRENT_SECTOR+1 :STACKORIGIN+STACKWIDTH,x
	jsr @expandToCARD.WORD
	inx
	mva SECTOR_NUMBER :STACKORIGIN,x
	mva SECTOR_NUMBER+1 :STACKORIGIN+STACKWIDTH,x
	jsr SYSTEM.STR_0732

; optimize OK (milf.pas), line = 790

	lda #$04
	sub adr.SECTOR_NUMBER
	sta SPACE_NUMBER

; optimize FAIL ('SYSTEM.SPACE', milf.pas), line = 791
	inx
	mva SPACE_NUMBER :STACKORIGIN,x
	jsr SYSTEM.SPACE
	inx
	mva SECTOR_NUMBER :STACKORIGIN,x
	mva SECTOR_NUMBER+1 :STACKORIGIN+STACKWIDTH,x
	jsr SYSTEM.CONCAT_076E
	@moveSTRING SECTOR_DATA
	dex

; optimize FAIL ('SYSTEM.CONCAT_0777', milf.pas), line = 792
	inx
	mva SECTOR_DATA :STACKORIGIN,x
	mva SECTOR_DATA+1 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$3A :STACKORIGIN,x
	jsr SYSTEM.CONCAT_0777
	@moveSTRING SECTOR_DATA
	dex

; optimize FAIL ('SYSTEM.CONCAT_0777', milf.pas), line = 793
	inx
	mva SECTOR_DATA :STACKORIGIN,x
	mva SECTOR_DATA+1 :STACKORIGIN+STACKWIDTH,x
	inx
	mva INFO :STACKORIGIN,x
	jsr SYSTEM.CONCAT_0777
	@moveSTRING SECTOR_DATA
	dex

; optimize FAIL ('SYSTEM.CONCAT_0777', milf.pas), line = 794
	inx
	mva SECTOR_DATA :STACKORIGIN,x
	mva SECTOR_DATA+1 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$9B :STACKORIGIN,x
	jsr SYSTEM.CONCAT_0777
	@moveSTRING SECTOR_DATA
	dex

; optimize OK (milf.pas), line = 795

	lda <adr.SECTOR_DATA+$01
	sta :edx
	lda >adr.SECTOR_DATA+$01
	sta :edx+1
	lda SECTOR_INDEX
	sta :ecx
	lda #$62
	add SECTOR_INDEX+1
	sta :ecx+1
	lda #$07
	sta :eax
	lda #$00
	sta :eax+1
	jsr @move

; optimize OK (milf.pas), line = 796

	lda SECTOR_INDEX
	add #$07
	sta SECTOR_INDEX
	scc
	inc SECTOR_INDEX+1
l_120A

; ------------------------------------------------------------

INFO	= DATAORIGIN+$05AE
adr.SECTOR_NUMBER	= DATAORIGIN+$05AF
.var SECTOR_NUMBER	= adr.SECTOR_NUMBER .word
adr.SECTOR_DATA	= DATAORIGIN+$05B4
.var SECTOR_DATA	= adr.SECTOR_DATA .word
SPACE_NUMBER	= DATAORIGIN+$05BC

@VarData	= INFO
@VarDataSize	= 15

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl

.local	COPY						; PROCEDURE

; optimize OK (milf.pas), line = 810

	lda DEST_DRIVE
	cmp #$FF
	jne l_1256

; optimize FAIL (100, milf.pas), line = 811
	@printSTRING #CODEORIGIN+$0527
	@printEOL

; optimize FAIL ('PRESSKEY', milf.pas), line = 812
	jsr PRESSKEY
	jmp COPYEXIT
l_1256

; optimize OK (milf.pas), line = 816

	lda BYTES_PER_SECTOR_SOURCE+1
	cmp BYTES_PER_SECTOR_DEST+1
	bne @+
	lda BYTES_PER_SECTOR_SOURCE
	cmp BYTES_PER_SECTOR_DEST
@
	jeq l_126F

; optimize FAIL (100, milf.pas), line = 817
	@printSTRING #CODEORIGIN+$0543
	@printEOL

; optimize FAIL (100, milf.pas), line = 818
	@printSTRING #CODEORIGIN+$0569
	@printEOL

; optimize FAIL (100, milf.pas), line = 819
	@printSTRING #CODEORIGIN+$058B
	@printEOL

; optimize FAIL ('CLEARKEYS', milf.pas), line = 821
	jsr CLEARKEYS
SECTORSIZE

; optimize FAIL ('CRT.KEYPRESSED', milf.pas), line = 825
	jsr CRT.KEYPRESSED
	dex
	lda :STACKORIGIN+1,x
	jeq l_1284

; optimize FAIL ('CRT.READKEY', milf.pas), line = 825
	jsr CRT.READKEY
	mva :STACKORIGIN,x KEY
	dex
	jmp l_1292
l_1284
	jmp SECTORSIZE
l_1292

; ------------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx
	mva KEY :STACKORIGIN,x

; GenerateCaseProlog
	dex

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #89
	beq @+

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #121
	jne l_12A0
@
	jmp STARTSECTOR

; GenerateCaseStatementEpilog
	jmp a_0008
l_12A0

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #78
	beq @+

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #110
	jne l_12AB
@
	jmp COPYEXIT

; GenerateCaseStatementEpilog
	jmp a_0008
l_12AB
	jmp SECTORSIZE

; GenerateCaseEpilog
a_0008
l_126F
STARTSECTOR

; optimize FAIL ('CLEARKEYS', milf.pas), line = 837
	jsr CLEARKEYS

; optimize FAIL ('CLEARBUFFER', milf.pas), line = 838
	jsr CLEARBUFFER

; optimize FAIL (100, milf.pas), line = 840
	@printSTRING #CODEORIGIN+$05A7
	@printEOL

; optimize FAIL ('GETSTRING', milf.pas), line = 841
	inx
	mva #$06 :STACKORIGIN,x
	jsr GETSTRING

; optimize FAIL ('BREAKPRESSED', milf.pas), line = 843
	jsr BREAKPRESSED
	dex
	lda :STACKORIGIN+1,x
	jeq l_12C4

; optimize FAIL (100, milf.pas), line = 844
	@printSTRING #CODEORIGIN+$04FE
	@printEOL
	jmp COPYEXIT
l_12C4

; optimize FAIL ('PARSEINPUT', milf.pas), line = 848
	inx
	mva #$05 :STACKORIGIN,x
	jsr PARSEINPUT

; optimize FAIL ('SYSTEM.VAL_0712', milf.pas), line = 850
	inx
	mva TMPSTRING :STACKORIGIN,x
	mva TMPSTRING+1 :STACKORIGIN+STACKWIDTH,x
	inx
	mva <START_SECTOR :STACKORIGIN,x
	mva >START_SECTOR :STACKORIGIN+STACKWIDTH,x
	inx
	mva <CODE :STACKORIGIN,x
	mva >CODE :STACKORIGIN+STACKWIDTH,x
	jsr SYSTEM.VAL_0712

; optimize OK (milf.pas), line = 852

	lda CODE
	jeq l_12E3
	jmp STARTSECTOR
l_12E3

; optimize OK (milf.pas), line = 854

	.LOCAL
	lda START_SECTOR+3
	sub #$00
	bne L4
	lda START_SECTOR+2
	cmp #$00
	bne L1
	lda START_SECTOR+1
	cmp NUMBER_OF_SECTORS+1
	bne L1
	lda START_SECTOR
	cmp NUMBER_OF_SECTORS
L1	beq L5
	bcs L3
	lda #$FF
	bne L5
L3	lda #$01
	bne L5
L4	bvc L5
	eor #$FF
	ora #$01
L5
	.ENDL
	jmi l_12F7

; optimize FAIL (100, milf.pas), line = 855
	@printSTRING #CODEORIGIN+$05B6
	@printEOL

; optimize FAIL (100, milf.pas), line = 856
	@printSTRING #CODEORIGIN+$05DA
	@printEOL
	jmp STARTSECTOR
l_12F7

; optimize OK (milf.pas), line = 860

	.LOCAL
	lda START_SECTOR+3
	sub #$00
	bne L4
	lda START_SECTOR+2
	cmp #$00
	bne L1
	lda START_SECTOR+1
	cmp #$00
	bne L1
	lda START_SECTOR
	cmp #$01
L1	beq L5
	bcs L3
	lda #$FF
	bne L5
L3	lda #$01
	bne L5
L4	bvc L5
	eor #$FF
	ora #$01
L5
	.ENDL
	jpl l_1310

; optimize FAIL (100, milf.pas), line = 861
	@printSTRING #CODEORIGIN+$05EE
	@printEOL
	jmp STARTSECTOR
l_1310
ENDSECTOR

; optimize FAIL ('CLEARKEYS', milf.pas), line = 867
	jsr CLEARKEYS

; optimize FAIL ('CLEARBUFFER', milf.pas), line = 868
	jsr CLEARBUFFER

; optimize FAIL (100, milf.pas), line = 870
	@printSTRING #CODEORIGIN+$0609
	@printEOL

; optimize FAIL ('GETSTRING', milf.pas), line = 871
	inx
	mva #$06 :STACKORIGIN,x
	jsr GETSTRING

; optimize FAIL ('BREAKPRESSED', milf.pas), line = 873
	jsr BREAKPRESSED
	dex
	lda :STACKORIGIN+1,x
	jeq l_1327

; optimize FAIL (100, milf.pas), line = 874
	@printSTRING #CODEORIGIN+$04FE
	@printEOL
	jmp COPYEXIT
l_1327

; optimize FAIL ('PARSEINPUT', milf.pas), line = 878
	inx
	mva #$05 :STACKORIGIN,x
	jsr PARSEINPUT

; optimize FAIL ('SYSTEM.VAL_0712', milf.pas), line = 880
	inx
	mva TMPSTRING :STACKORIGIN,x
	mva TMPSTRING+1 :STACKORIGIN+STACKWIDTH,x
	inx
	mva <END_SECTOR :STACKORIGIN,x
	mva >END_SECTOR :STACKORIGIN+STACKWIDTH,x
	inx
	mva <CODE :STACKORIGIN,x
	mva >CODE :STACKORIGIN+STACKWIDTH,x
	jsr SYSTEM.VAL_0712

; optimize OK (milf.pas), line = 882

	lda CODE
	jeq l_1346
	jmp ENDSECTOR
l_1346

; optimize OK (milf.pas), line = 884

	.LOCAL
	lda END_SECTOR+3
	sub #$00
	bne L4
	lda END_SECTOR+2
	cmp #$00
	bne L1
	lda END_SECTOR+1
	cmp NUMBER_OF_SECTORS+1
	bne L1
	lda END_SECTOR
	cmp NUMBER_OF_SECTORS
L1	beq L5
	bcs L3
	lda #$FF
	bne L5
L3	lda #$01
	bne L5
L4	bvc L5
	eor #$FF
	ora #$01
L5
	.ENDL
	jmi l_135A
	jeq l_135A

; optimize FAIL (100, milf.pas), line = 885
	@printSTRING #CODEORIGIN+$0616
	@printEOL

; optimize FAIL (100, milf.pas), line = 886
	@printSTRING #CODEORIGIN+$05DA
	@printEOL
	jmp ENDSECTOR
l_135A

; optimize OK (milf.pas), line = 890

	.LOCAL
	lda END_SECTOR+3
	sub START_SECTOR+3
	bne L4
	lda END_SECTOR+2
	cmp START_SECTOR+2
	bne L1
	lda END_SECTOR+1
	cmp START_SECTOR+1
	bne L1
	lda END_SECTOR
	cmp START_SECTOR
L1	beq L5
	bcs L3
	lda #$FF
	bne L5
L3	lda #$01
	bne L5
L4	bvc L5
	eor #$FF
	ora #$01
L5
	.ENDL
	jpl l_1373

; optimize FAIL (100, milf.pas), line = 891
	@printSTRING #CODEORIGIN+$0639
	@printEOL

; optimize FAIL (100, milf.pas), line = 892
	@printSTRING #CODEORIGIN+$065A
	@printEOL
	jmp ENDSECTOR
l_1373

; optimize OK (milf.pas), line = 896

	lda END_SECTOR
	sub START_SECTOR
	sta :STACKORIGIN+9
	lda END_SECTOR+1
	sbc START_SECTOR+1
	sta SECTORS_TO_READ+1
	lda :STACKORIGIN+9
	add #$01
	sta SECTORS_TO_READ
	scc
	inc SECTORS_TO_READ+1

; optimize FAIL (100, milf.pas), line = 898
	@printSTRING #CODEORIGIN+$0663
	lda SECTORS_TO_READ
	ldy SECTORS_TO_READ+1
	jsr @printWORD._ay
	@printSTRING #CODEORIGIN+$066D
	@printEOL

; optimize FAIL ('CLEARBUFFER', milf.pas), line = 900
	jsr CLEARBUFFER

; optimize OK (milf.pas), line = 902

	mva START_SECTOR CURRENT_SECTOR
	mva START_SECTOR+1 CURRENT_SECTOR+1

; optimize OK (milf.pas), line = 903

	mva START_SECTOR CURRENT_SECTOR_WRITE
	mva START_SECTOR+1 CURRENT_SECTOR_WRITE+1

; optimize OK (milf.pas), line = 905

	mva #$00 DESTINATION
	mva #$60 DESTINATION+1

; optimize FAIL ('CRT.CURSOROFF', milf.pas), line = 907
	jsr CRT.CURSOROFF

; optimize FAIL ('CLEARLOGBUFFER', milf.pas), line = 908
	jsr CLEARLOGBUFFER

; optimize OK (milf.pas), line = 909

	mva #$00 SECTOR_INDEX
	sta SECTOR_INDEX+1

; optimize FAIL (100, milf.pas), line = 911
	@printEOL

; --- WhileProlog
	jmp l_13AA
l_13AB

; optimize FAIL ('CLEARBUFFER', milf.pas), line = 915
	jsr CLEARBUFFER

; optimize FAIL ('CRT.WHEREY', milf.pas), line = 917
	jsr CRT.WHEREY
	mva :STACKORIGIN,x CURSOR_Y
	dex

; optimize FAIL ('CRT.GOTOXY', milf.pas), line = 918
	inx
	mva #$03 :STACKORIGIN,x
	inx
	mva CURSOR_Y :STACKORIGIN,x
	jsr CRT.GOTOXY

; optimize FAIL (100, milf.pas), line = 919
	@printSTRING #CODEORIGIN+$0678
	lda CURRENT_SECTOR
	ldy CURRENT_SECTOR+1
	jsr @printWORD._ay

; optimize OK (milf.pas), line = 921

	lda CURRENT_SECTOR+1
	jne l_13D0
	lda CURRENT_SECTOR
	cmp #$04
	jcs l_13D0

; optimize FAIL ('EXEC_SIO', milf.pas), line = 922
	inx
	mva SOURCE_DRIVE :STACKORIGIN,x
	inx
	mva #$52 :STACKORIGIN,x
	inx
	mva #$40 :STACKORIGIN,x
	inx
	mva #$07 :STACKORIGIN,x
	inx
	mva DESTINATION :STACKORIGIN,x
	mva DESTINATION+1 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$80 :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	inx
	mva CURRENT_SECTOR :STACKORIGIN,x
	mva CURRENT_SECTOR+1 :STACKORIGIN+STACKWIDTH,x
	jsr EXEC_SIO

; optimize OK (milf.pas), line = 923

	lda SIORESULT
	jpl l_13EF

; optimize FAIL ('PUTTOLOG', milf.pas), line = 924
	inx
	mva #$72 :STACKORIGIN,x
	jsr PUTTOLOG

; ------------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx
	mva SIORESULT :STACKORIGIN,x

; ------------------------------------------------------------

; Push WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer

	inx
	mva CURRENT_SECTOR :STACKORIGIN,x
	mva CURRENT_SECTOR+1 :STACKORIGIN+STACKWIDTH,x

; ------------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Value $00000001 (1)

	inx
	mva #$01 :STACKORIGIN,x

	jsr COPYERROR					; call Entry

; GenerateCaseProlog
	dex

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #1
	jne l_1402
@

	jmp b_13AB					; break

; GenerateCaseStatementEpilog
	jmp a_0009
l_1402

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #2
	jne l_140B
@

	jmp c_13AB					; continue

; GenerateCaseStatementEpilog
	jmp a_0009
l_140B

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #3
	jne l_1414
@

; optimize FAIL (0, milf.pas), line = 928
	inc CURRENT_SECTOR
	sne
	inc CURRENT_SECTOR+1

; GenerateCaseStatementEpilog
	jmp a_0009
l_1414

; GenerateCaseEpilog
a_0009
	jmp l_1428
l_13EF

; optimize FAIL ('PUTTOLOG', milf.pas), line = 931
	inx
	mva #$6F :STACKORIGIN,x
	jsr PUTTOLOG
l_1428

; optimize FAIL ('EXEC_SIO', milf.pas), line = 933
	inx
	mva DEST_DRIVE :STACKORIGIN,x
	inx
	mva #$50 :STACKORIGIN,x
	inx
	mva #$80 :STACKORIGIN,x
	inx
	mva #$07 :STACKORIGIN,x
	inx
	mva DESTINATION :STACKORIGIN,x
	mva DESTINATION+1 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$80 :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	inx
	mva CURRENT_SECTOR :STACKORIGIN,x
	mva CURRENT_SECTOR+1 :STACKORIGIN+STACKWIDTH,x
	jsr EXEC_SIO

; optimize OK (milf.pas), line = 934

	lda SIORESULT
	jpl l_1448

; optimize FAIL ('PUTTOLOG', milf.pas), line = 935
	inx
	mva #$77 :STACKORIGIN,x
	jsr PUTTOLOG

; ------------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx
	mva SIORESULT :STACKORIGIN,x

; ------------------------------------------------------------

; Push WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer

	inx
	mva CURRENT_SECTOR :STACKORIGIN,x
	mva CURRENT_SECTOR+1 :STACKORIGIN+STACKWIDTH,x

; ------------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Value $00000002 (2)

	inx
	mva #$02 :STACKORIGIN,x

	jsr COPYERROR					; call Entry

; GenerateCaseProlog
	dex

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #1
	jne l_145B
@

	jmp b_13AB					; break

; GenerateCaseStatementEpilog
	jmp a_000A
l_145B

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #2
	jne l_1464
@

	jmp c_13AB					; continue

; GenerateCaseStatementEpilog
	jmp a_000A
l_1464

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #3
	jne l_146D
@

; optimize FAIL (0, milf.pas), line = 939
	inc CURRENT_SECTOR
	sne
	inc CURRENT_SECTOR+1

; GenerateCaseStatementEpilog
	jmp a_000A
l_146D

; GenerateCaseEpilog
a_000A
l_1448
	jmp l_1483
l_13D0

; optimize FAIL ('EXEC_SIO', milf.pas), line = 943
	inx
	mva SOURCE_DRIVE :STACKORIGIN,x
	inx
	mva #$52 :STACKORIGIN,x
	inx
	mva #$40 :STACKORIGIN,x
	inx
	mva #$07 :STACKORIGIN,x
	inx
	mva DESTINATION :STACKORIGIN,x
	mva DESTINATION+1 :STACKORIGIN+STACKWIDTH,x
	inx
	mva BYTES_PER_SECTOR :STACKORIGIN,x
	mva BYTES_PER_SECTOR+1 :STACKORIGIN+STACKWIDTH,x
	inx
	mva CURRENT_SECTOR :STACKORIGIN,x
	mva CURRENT_SECTOR+1 :STACKORIGIN+STACKWIDTH,x
	jsr EXEC_SIO

; optimize OK (milf.pas), line = 944

	lda SIORESULT
	jpl l_14A2

; optimize FAIL ('PUTTOLOG', milf.pas), line = 945
	inx
	mva #$72 :STACKORIGIN,x
	jsr PUTTOLOG

; ------------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx
	mva SIORESULT :STACKORIGIN,x

; ------------------------------------------------------------

; Push WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer

	inx
	mva CURRENT_SECTOR :STACKORIGIN,x
	mva CURRENT_SECTOR+1 :STACKORIGIN+STACKWIDTH,x

; ------------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Value $00000001 (1)

	inx
	mva #$01 :STACKORIGIN,x

	jsr COPYERROR					; call Entry

; GenerateCaseProlog
	dex

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #1
	jne l_14B5
@

	jmp b_13AB					; break

; GenerateCaseStatementEpilog
	jmp a_000B
l_14B5

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #2
	jne l_14BE
@

	jmp c_13AB					; continue

; GenerateCaseStatementEpilog
	jmp a_000B
l_14BE

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #3
	jne l_14C7
@

; optimize FAIL (0, milf.pas), line = 949
	inc CURRENT_SECTOR
	sne
	inc CURRENT_SECTOR+1

; GenerateCaseStatementEpilog
	jmp a_000B
l_14C7

; GenerateCaseEpilog
a_000B
	jmp l_14DB
l_14A2

; optimize FAIL ('PUTTOLOG', milf.pas), line = 952
	inx
	mva #$6F :STACKORIGIN,x
	jsr PUTTOLOG
l_14DB

; optimize FAIL ('EXEC_SIO', milf.pas), line = 954
	inx
	mva DEST_DRIVE :STACKORIGIN,x
	inx
	mva #$50 :STACKORIGIN,x
	inx
	mva #$80 :STACKORIGIN,x
	inx
	mva #$07 :STACKORIGIN,x
	inx
	mva DESTINATION :STACKORIGIN,x
	mva DESTINATION+1 :STACKORIGIN+STACKWIDTH,x
	inx
	mva BYTES_PER_SECTOR :STACKORIGIN,x
	mva BYTES_PER_SECTOR+1 :STACKORIGIN+STACKWIDTH,x
	inx
	mva CURRENT_SECTOR :STACKORIGIN,x
	mva CURRENT_SECTOR+1 :STACKORIGIN+STACKWIDTH,x
	jsr EXEC_SIO

; optimize OK (milf.pas), line = 955

	lda SIORESULT
	jpl l_14FC

; optimize FAIL ('PUTTOLOG', milf.pas), line = 956
	inx
	mva #$77 :STACKORIGIN,x
	jsr PUTTOLOG

; ------------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx
	mva SIORESULT :STACKORIGIN,x

; ------------------------------------------------------------

; Push WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer

	inx
	mva CURRENT_SECTOR :STACKORIGIN,x
	mva CURRENT_SECTOR+1 :STACKORIGIN+STACKWIDTH,x

; ------------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Value $00000002 (2)

	inx
	mva #$02 :STACKORIGIN,x

	jsr COPYERROR					; call Entry

; GenerateCaseProlog
	dex

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #1
	jne l_150F
@

	jmp b_13AB					; break

; GenerateCaseStatementEpilog
	jmp a_000C
l_150F

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #2
	jne l_1518
@

	jmp c_13AB					; continue

; GenerateCaseStatementEpilog
	jmp a_000C
l_1518

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #3
	jne l_1521
@

; optimize FAIL (0, milf.pas), line = 960
	inc CURRENT_SECTOR
	sne
	inc CURRENT_SECTOR+1

; GenerateCaseStatementEpilog
	jmp a_000C
l_1521

; GenerateCaseEpilog
a_000C
l_14FC
l_1483

; optimize FAIL (0, milf.pas), line = 965
	inc CURRENT_SECTOR
	sne
	inc CURRENT_SECTOR+1
c_13AB
l_13AA

; optimize OK (milf.pas), line = 913

	.LOCAL
	lda #$00
	sub END_SECTOR+3
	bne L4
	lda #$00
	cmp END_SECTOR+2
	bne L1
	lda CURRENT_SECTOR+1
	cmp END_SECTOR+1
	bne L1
	lda CURRENT_SECTOR
	cmp END_SECTOR
L1	beq L5
	bcs L3
	lda #$FF
	bne L5
L3	lda #$01
	bne L5
L4	bvc L5
	eor #$FF
	ora #$01
L5
	.ENDL
	jmi l_13AB
	jeq l_13AB
b_13AB

; optimize FAIL ('CRT.CURSORON', milf.pas), line = 969
	jsr CRT.CURSORON

; optimize FAIL (100, milf.pas), line = 971
	@printEOL

; optimize FAIL (100, milf.pas), line = 972
	@printEOL

; optimize FAIL (100, milf.pas), line = 973
	@printSTRING #CODEORIGIN+$0696
	@printEOL

; optimize OK (milf.pas), line = 975

	lda SECTORS_TO_READ+1
	cmp #$0B
	bne @+
	lda SECTORS_TO_READ
	cmp #$41
@
	jcs l_1552

; optimize FAIL (100, milf.pas), line = 977
	@printEOL

; optimize FAIL (100, milf.pas), line = 978
	@printSTRING #CODEORIGIN+$06A6
	@printEOL

; optimize FAIL ('CLEARKEYS', milf.pas), line = 980
	jsr CLEARKEYS
LOGFILEDIALOG

; optimize FAIL ('CRT.KEYPRESSED', milf.pas), line = 984
	jsr CRT.KEYPRESSED
	dex
	lda :STACKORIGIN+1,x
	jeq l_1561

; optimize FAIL ('CRT.READKEY', milf.pas), line = 984
	jsr CRT.READKEY
	mva :STACKORIGIN,x KEY
	dex
	jmp l_156F
l_1561
	jmp LOGFILEDIALOG
l_156F

; ------------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx
	mva KEY :STACKORIGIN,x

; GenerateCaseProlog
	dex

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #89
	beq @+

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #121
	jne l_157D
@

; optimize FAIL ('WRITELOG', milf.pas), line = 987
	inx
	mva SECTORS_TO_READ :STACKORIGIN,x
	mva SECTORS_TO_READ+1 :STACKORIGIN+STACKWIDTH,x
	jsr WRITELOG

; GenerateCaseStatementEpilog
	jmp a_000D
l_157D

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #78
	beq @+

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #110
	jne l_158B
@
	jmp COPYEXIT

; GenerateCaseStatementEpilog
	jmp a_000D
l_158B
	jmp LOGFILEDIALOG

; GenerateCaseEpilog
a_000D
l_1552

; optimize FAIL ('PRESSKEY', milf.pas), line = 993
	jsr PRESSKEY
COPYEXIT

; optimize FAIL ('WRITEMENU', milf.pas), line = 997
	jsr WRITEMENU

; ------------------------------------------------------------

CURRENT_SECTOR_WRITE	= DATAORIGIN+$05BD
DESTINATION	= DATAORIGIN+$05BF

@VarData	= CURRENT_SECTOR_WRITE
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif
	rts						; ret
.endl
l_06E6
START

; optimize OK (milf.pas), line = 1008

	mva #$01 SOURCE_DRIVE

; optimize OK (milf.pas), line = 1009

	mva #$FF DEST_DRIVE

; optimize OK (milf.pas), line = 1011

	mva #$01 SOURCE_DRIVE_NOT_CONFIGURABLE

; optimize OK (milf.pas), line = 1012

	sta DEST_DRIVE_NOT_CONFIGURABLE

; optimize FAIL ('CRT.CLRSCR', milf.pas), line = 1014
	jsr CRT.CLRSCR

; optimize FAIL ('CLEARPERCOMBUFFER', milf.pas), line = 1015
	jsr CLEARPERCOMBUFFER

; optimize FAIL (100, milf.pas), line = 1017
	@printSTRING #CODEORIGIN+$06C5
	@printEOL

; optimize FAIL (100, milf.pas), line = 1018
	@printEOL

; optimize FAIL ('WRITEMENU', milf.pas), line = 1020
	jsr WRITEMENU
MENU

; optimize FAIL ('CRT.KEYPRESSED', milf.pas), line = 1024
	jsr CRT.KEYPRESSED
	dex
	lda :STACKORIGIN+1,x
	jeq l_15B6

; optimize FAIL ('CRT.READKEY', milf.pas), line = 1024
	jsr CRT.READKEY
	mva :STACKORIGIN,x KEY
	dex
l_15B6

; ------------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx
	mva KEY :STACKORIGIN,x

; GenerateCaseProlog
	dex

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #82
	beq @+

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #114
	jne l_15CB
@

; optimize FAIL ('WRITEMENU', milf.pas), line = 1027
	jsr WRITEMENU

; GenerateCaseStatementEpilog
	jmp a_000E
l_15CB

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #87
	beq @+

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #119
	jne l_15D7
@

; optimize FAIL ('WRITEPERCOM', milf.pas), line = 1028
	jsr WRITEPERCOM

; GenerateCaseStatementEpilog
	jmp a_000E
l_15D7

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #70
	beq @+

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #102
	jne l_15E3
@

; optimize FAIL ('FORMAT', milf.pas), line = 1029
	jsr FORMAT

; GenerateCaseStatementEpilog
	jmp a_000E
l_15E3

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #68
	beq @+

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #100
	jne l_15EF
@

; optimize FAIL ('CHANGEDRIVES', milf.pas), line = 1030
	jsr CHANGEDRIVES

; GenerateCaseStatementEpilog
	jmp a_000E
l_15EF

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #67
	beq @+

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #99
	jne l_15FB
@

; optimize FAIL ('COPY', milf.pas), line = 1031
	jsr COPY

; GenerateCaseStatementEpilog
	jmp a_000E
l_15FB

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #88
	beq @+

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #120
	jne l_1607
@

; optimize FAIL ('SWAPDRIVES', milf.pas), line = 1032
	jsr SWAPDRIVES

; GenerateCaseStatementEpilog
	jmp a_000E
l_1607

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #81
	beq @+

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #113
	jne l_1613
@

; optimize FAIL ('EXITTODOS', milf.pas), line = 1033
	jsr EXITTODOS

; GenerateCaseStatementEpilog
	jmp a_000E
l_1613

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #66
	beq @+

; GenerateCaseEqualityCheck
	lda :STACKORIGIN+1,x
	cmp #98
	jne l_161F
@

; optimize FAIL ('COLDSTART', milf.pas), line = 1034
	jsr COLDSTART

; GenerateCaseStatementEpilog
	jmp a_000E
l_161F
	jmp MENU

; GenerateCaseEpilog
a_000E

; optimize FAIL ('CLEARKEYS', milf.pas), line = 1038
	jsr CLEARKEYS
	jmp MENU

; ------------------------------------------------------------

SIO_READ	= $40
SIO_WRITE	= $80
SIO_NONE	= $00
SIO_READ_WRITE	= $C0
FORMAT_DISK	= $21
FORMAT_SINGLE	= $21
FORMAT_ENHANCED	= $22
READ_PERCOM	= $4E
WRITE_PERCOM	= $4F
PUT_SECTOR	= $50
READ_SECTOR	= $52
READ_STATUS	= $53
PERCOM_BUFFER_MEM	= $0600
COPY_BUFFER_MEM	= $6000
LOG_BUFFER	= $6200
LOG_READ_ERROR	= $72
LOG_READ_SUCCESS	= $6F
LOG_WRITE_ERROR	= $77
EOL	= $9B
DDEVIC	= $0300
DUNIT	= $0301
DCOMND	= $0302
DSTATS	= $0303
DBUFLO	= $0304
DBUFHI	= $0305
DTIMLO	= $0306
DUNUSE	= $0307
DBYTLO	= $0308
DBYTHI	= $0309
DAUX1	= $030A
DAUX2	= $030B
adr.SSSD	= CODEORIGIN+$06DF
.var SSSD	= adr.SSSD .word
adr.SSED	= CODEORIGIN+$06EB
.var SSED	= adr.SSED .word
adr.SSDD	= CODEORIGIN+$06F7
.var SSDD	= adr.SSDD .word
adr.DSDD	= CODEORIGIN+$0703
.var DSDD	= adr.DSDD .word
adr.DSQD	= CODEORIGIN+$070F
.var DSQD	= adr.DSQD .word
adr.PERCOMBLOCK	= DATAORIGIN+$0426
.var PERCOMBLOCK	= adr.PERCOMBLOCK .word
CH	= $02FC
RESULT	= DATAORIGIN+$0432
SIORESULT	= DATAORIGIN+$0434
CIORESULT	= DATAORIGIN+$0435
TMPBOOL	= DATAORIGIN+$0436
TMPBYTE	= DATAORIGIN+$0437
TMPBYTE2	= DATAORIGIN+$0438
TMPWORD	= DATAORIGIN+$0439
adr.TMPSTRING	= DATAORIGIN+$043B
.var TMPSTRING	= adr.TMPSTRING .word
adr.TMPSTRING2	= DATAORIGIN+$044D
.var TMPSTRING2	= adr.TMPSTRING2 .word
KEY	= DATAORIGIN+$045F
.var F	= DATAORIGIN+$0460 .word
CODE	= DATAORIGIN+$046C
CURSOR_Y	= DATAORIGIN+$046D
REQUESTEDSECTORS	= DATAORIGIN+$046E
REQUESTEDSECTORSIZE	= DATAORIGIN+$0470
SOURCE_DRIVE	= DATAORIGIN+$0472
DEST_DRIVE	= DATAORIGIN+$0473
SELECTED_DRIVE	= DATAORIGIN+$0474
SOURCE_DRIVE_NOT_CONFIGURABLE	= DATAORIGIN+$0475
DEST_DRIVE_NOT_CONFIGURABLE	= DATAORIGIN+$0476
BYTES_PER_SECTOR_SOURCE	= DATAORIGIN+$0477
BYTES_PER_SECTOR_DEST	= DATAORIGIN+$0479
BYTES_PER_SECTOR	= DATAORIGIN+$047B
NUMBER_OF_SECTORS	= DATAORIGIN+$047D
CURRENT_SECTOR	= DATAORIGIN+$047F
SECTOR_INDEX	= DATAORIGIN+$0481
SECTORS_TO_READ	= DATAORIGIN+$0483
START_SECTOR	= DATAORIGIN+$0485
END_SECTOR	= DATAORIGIN+$0489
@exit

@halt	ldx #0
	txs
	.ifdef MAIN.@DEFINES.ROMOFF
	inc portb
	.endif

	rts

; ------------------------------------------------------------

IOCB@COPY	:16 brk

; ------------------------------------------------------------

.local	@DEFINES
ATARI
.endl

.endl							; MAIN

; ------------------------------------------------------------
; ------------------------------------------------------------

.macro	UNITINITIALIZATION

	.ifdef MAIN.SYSTEM.@UnitInit
	jsr MAIN.SYSTEM.@UnitInit
	eif

	.ifdef MAIN.ATARI.@UnitInit
	jsr MAIN.ATARI.@UnitInit
	eif

	.ifdef MAIN.CRT.@UnitInit
	jsr MAIN.CRT.@UnitInit
	eif
.endm

; ------------------------------------------------------------

	ift .SIZEOF(MAIN.SYSTEM) > 0
	.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
	eif

	ift .SIZEOF(MAIN.ATARI) > 0
	.print 'ATARI: ',MAIN.ATARI,'..',MAIN.ATARI+.SIZEOF(MAIN.ATARI)-1
	eif

	ift .SIZEOF(MAIN.CRT) > 0
	.print 'CRT: ',MAIN.CRT,'..',MAIN.CRT+.SIZEOF(MAIN.CRT)-1
	eif

	.print 'CODE: ',CODEORIGIN,'..',*-1

; ------------------------------------------------------------

DATAORIGIN
.by  $28 $00 $18 $00 $2D $0C

VARINITSIZE	= *-DATAORIGIN
VARDATASIZE	= 1473

PROGRAMSTACK	= DATAORIGIN+VARDATASIZE

	.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK

	run START

; ------------------------------------------------------------

.macro	STATICDATA
.by  $0C $50 $72 $65 $73 $73 $20 $6B  $65 $79 $2E $2E $2E $00 $00 $00  $17 $44 $72 $69 $76 $65 $20 $64
.by  $6F $65 $73 $20 $6E $6F $74 $20  $72 $65 $73 $70 $6F $6E $64 $2E  $00 $1E $44 $72 $69 $76 $65 $20
.by  $64 $6F $65 $73 $20 $6E $6F $74  $20 $73 $75 $70 $70 $6F $72 $74  $20 $50 $45 $52 $43 $4F $4D $2E
.by  $00 $21 $50 $72 $6F $62 $61 $62  $6C $79 $20 $41 $74 $61 $72 $69  $20 $38 $31 $30 $20 $6F $72 $20
.by  $41 $74 $61 $72 $69 $20 $31 $30  $35 $30 $2E $00 $1B $54 $72 $79  $69 $6E $67 $20 $74 $6F $20 $64
.by  $65 $74 $65 $63 $74 $20 $64 $65  $6E $73 $69 $74 $79 $2E $2E $2E  $00 $0C $20 $73 $65 $63 $74 $6F
.by  $72 $73 $20 $6F $66 $20 $00 $07  $20 $62 $79 $74 $65 $73 $2E $00  $08 $53 $74 $61 $74 $75 $73 $3A
.by  $20 $00 $06 $65 $72 $72 $6F $72  $20 $00 $02 $4F $4B $00 $17 $43  $75 $72 $72 $65 $6E $74 $20 $73
.by  $6F $75 $72 $63 $65 $20 $64 $72  $69 $76 $65 $3A $20 $44 $00 $25  $2D $2D $2D $2D $2D $2D $2D $2D
.by  $2D $2D $2D $2D $2D $2D $2D $2D  $2D $2D $2D $2D $2D $2D $2D $2D  $2D $2D $2D $2D $2D $2D $2D $2D
.by  $2D $2D $2D $2D $2D $00 $1C $43  $75 $72 $72 $65 $6E $74 $20 $64  $65 $73 $74 $69 $6E $61 $74 $69
.by  $6F $6E $20 $64 $72 $69 $76 $65  $3A $20 $44 $00 $19 $44 $65 $73  $74 $69 $6E $61 $74 $69 $6F $6E
.by  $20 $64 $72 $69 $76 $65 $20 $6E  $6F $74 $20 $73 $65 $74 $00 $1C  $D2 $20 $2D $20 $52 $65 $61 $64
.by  $20 $64 $72 $69 $76 $65 $20 $63  $6F $6E $66 $69 $67 $75 $72 $61  $74 $69 $6F $6E $00 $1D $D7 $20
.by  $2D $20 $57 $72 $69 $74 $65 $20  $64 $72 $69 $76 $65 $20 $63 $6F  $6E $66 $69 $67 $75 $72 $61 $74
.by  $69 $6F $6E $00 $10 $C6 $20 $2D  $20 $46 $6F $72 $6D $61 $74 $20  $64 $72 $69 $76 $65 $00 $22 $C4
.by  $20 $2D $20 $53 $65 $74 $20 $73  $6F $75 $72 $63 $65 $2C $20 $64  $65 $73 $74 $69 $6E $61 $74 $69
.by  $6F $6E $20 $64 $72 $69 $76 $65  $73 $00 $23 $D8 $20 $2D $20 $45  $78 $63 $68 $61 $6E $67 $65 $20
.by  $73 $6F $75 $72 $63 $65 $20 $61  $6E $64 $20 $64 $65 $73 $74 $69  $6E $61 $74 $69 $6F $6E $00 $10
.by  $C3 $20 $2D $20 $43 $6F $70 $79  $20 $73 $65 $63 $74 $6F $72 $73  $00 $0F $D1 $20 $2D $20 $45 $78
.by  $69 $74 $20 $74 $6F $20 $44 $4F  $53 $00 $0E $C2 $20 $2D $20 $43  $6F $6C $64 $20 $73 $74 $61 $72
.by  $74 $00 $19 $4F $6E $65 $20 $6F  $66 $20 $64 $72 $69 $76 $65 $73  $20 $69 $73 $20 $6E $6F $74 $20
.by  $73 $65 $74 $2E $00 $12 $43 $61  $6E $20 $6E $6F $74 $20 $65 $78  $63 $68 $61 $6E $67 $65 $2E $20
.by  $00 $13 $44 $72 $69 $76 $65 $20  $77 $65 $72 $65 $20 $73 $77 $61  $70 $70 $65 $64 $2E $00 $10 $53
.by  $20 $2D $20 $53 $6F $75 $72 $63  $65 $20 $64 $72 $69 $76 $65 $00  $15 $44 $20 $2D $20 $44 $65 $73
.by  $74 $69 $6E $61 $74 $69 $6F $6E  $20 $64 $72 $69 $76 $65 $00 $1E  $54 $68 $69 $73 $20 $64 $72 $69
.by  $76 $65 $20 $69 $73 $20 $6E $6F  $74 $20 $63 $6F $6E $66 $69 $67  $75 $72 $61 $62 $6C $65 $00 $05
.by  $4F $6E $6C $79 $20 $00 $0B $D3  $20 $2D $20 $39 $30 $20 $4B $42  $2C $20 $00 $0A $C5 $20 $2D $20
.by  $31 $33 $30 $20 $4B $42 $00 $18  $64 $65 $6E $73 $69 $74 $69 $65  $73 $20 $61 $72 $65 $20 $61 $76
.by  $61 $69 $6C $61 $62 $6C $65 $2E  $00 $10 $46 $6F $72 $6D $61 $74  $74 $69 $6E $67 $20 $64 $69 $73
.by  $6B $2E $00 $06 $73 $6F $75 $72  $63 $65 $00 $0B $64 $65 $73 $74  $69 $6E $61 $74 $69 $6F $6E $00
.by  $07 $53 $65 $6C $65 $63 $74 $20  $00 $13 $20 $64 $72 $69 $76 $65  $20 $6E $75 $6D $62 $65 $72 $20
.by  $28 $31 $2D $38 $29 $00 $21 $44  $65 $73 $74 $69 $6E $61 $74 $69  $6F $6E $20 $64 $72 $69 $76 $65
.by  $20 $6E $75 $6D $62 $65 $72 $20  $6D $75 $73 $74 $20 $62 $65 $20  $00 $1D $64 $69 $66 $66 $65 $72
.by  $65 $6E $74 $20 $74 $68 $61 $6E  $20 $73 $6F $75 $72 $63 $65 $20  $6E $75 $6D $62 $65 $72 $2E $00
.by  $1F $54 $68 $69 $73 $20 $64 $72  $69 $76 $65 $20 $69 $73 $20 $6E  $6F $74 $20 $63 $6F $6E $66 $69
.by  $67 $75 $72 $61 $62 $6C $65 $2E  $00 $0E $50 $72 $65 $73 $73 $20  $61 $6E $79 $20 $6B $65 $79 $2E
.by  $00 $1B $53 $65 $6C $65 $63 $74  $20 $64 $72 $69 $76 $65 $20 $63  $6F $6E $66 $69 $67 $75 $72 $61
.by  $74 $69 $6F $6E $3A $00 $12 $31  $20 $2D $20 $53 $53 $20 $53 $44  $20 $20 $28 $39 $30 $20 $4B $42
.by  $29 $00 $12 $32 $20 $2D $20 $53  $53 $20 $45 $44 $20 $28 $31 $33  $30 $20 $4B $42 $29 $00 $12 $33
.by  $20 $2D $20 $53 $53 $20 $44 $44  $20 $28 $31 $38 $30 $20 $4B $42  $29 $00 $12 $34 $20 $2D $20 $44
.by  $53 $20 $44 $44 $20 $28 $33 $36  $30 $20 $4B $42 $29 $00 $12 $35  $20 $2D $20 $44 $53 $20 $51 $44
.by  $20 $28 $37 $32 $30 $20 $4B $42  $29 $00 $17 $43 $6F $6E $66 $69  $67 $75 $72 $61 $74 $69 $6F $6E
.by  $20 $63 $6F $6E $66 $69 $72 $6D  $65 $64 $00 $23 $57 $61 $72 $6E  $69 $6E $67 $2E $20 $44 $72 $69
.by  $76 $65 $20 $6D $61 $79 $20 $6E  $6F $74 $20 $73 $75 $70 $70 $6F  $72 $74 $20 $74 $68 $61 $74 $00
.by  $24 $63 $6F $6E $66 $69 $67 $75  $72 $61 $74 $69 $6F $6E $2E $20  $50 $72 $6F $63 $65 $65 $64 $20
.by  $77 $69 $74 $68 $20 $63 $61 $75  $74 $69 $6F $6E $21 $00 $07 $72  $65 $61 $64 $69 $6E $67 $00 $07
.by  $77 $72 $69 $74 $69 $6E $67 $00  $06 $45 $72 $72 $6F $72 $20 $00  $08 $20 $73 $65 $63 $74 $6F $72
.by  $20 $00 $0B $C1 $20 $2D $20 $41  $62 $6F $72 $74 $2C $20 $00 $0B  $D2 $20 $2D $20 $52 $65 $74 $72
.by  $79 $2C $20 $00 $09 $D3 $20 $2D  $20 $53 $6B $69 $70 $2C $00 $1E  $D7 $20 $2D $20 $77 $72 $69 $74
.by  $65 $20 $62 $75 $66 $66 $65 $72  $20 $61 $6E $64 $20 $63 $6F $6E  $74 $69 $6E $75 $65 $2E $00 $21
.by  $45 $6E $74 $65 $72 $20 $66 $69  $6C $65 $6E $61 $6D $65 $20 $77  $69 $74 $68 $20 $64 $72 $69 $76
.by  $65 $20 $6E $75 $6D $62 $65 $72  $2E $00 $12 $45 $67 $2E $20 $44  $31 $3A $4C $4F $47 $46 $49 $4C
.by  $45 $2E $4C $4F $47 $00 $1B $42  $72 $65 $61 $6B $20 $6B $65 $79  $20 $70 $72 $65 $73 $73 $65 $64
.by  $2C $20 $61 $62 $6F $72 $74 $69  $6E $67 $00 $0A $46 $69 $6C $65  $20 $73 $61 $76 $65 $64 $00 $1A
.by  $44 $65 $73 $74 $69 $6E $61 $74  $69 $6F $6E $20 $64 $72 $69 $76  $65 $20 $6E $6F $74 $20 $73 $65
.by  $74 $2E $00 $24 $53 $65 $63 $74  $6F $72 $20 $73 $69 $7A $65 $20  $69 $6E $20 $64 $65 $73 $74 $69
.by  $6E $61 $74 $69 $6F $6E $20 $64  $72 $69 $76 $65 $20 $64 $6F $20  $00 $20 $6E $6F $74 $20 $6D $61
.by  $74 $63 $68 $20 $73 $65 $63 $74  $6F $72 $20 $73 $69 $7A $65 $20  $69 $6E $20 $73 $6F $75 $72 $63
.by  $65 $20 $00 $1A $64 $72 $69 $76  $65 $2E $20 $41 $72 $65 $20 $79  $6F $75 $20 $73 $75 $72 $65 $20
.by  $28 $59 $2F $4E $29 $3F $00 $0D  $53 $74 $61 $72 $74 $20 $73 $65  $63 $74 $6F $72 $3A $00 $22 $53
.by  $74 $61 $72 $74 $20 $73 $65 $63  $74 $6F $72 $20 $69 $73 $20 $67  $72 $65 $61 $74 $65 $72 $20 $74
.by  $68 $61 $6E $20 $74 $6F $74 $61  $6C $00 $12 $6E $75 $6D $62 $65  $72 $20 $6F $66 $20 $73 $65 $63
.by  $74 $6F $72 $73 $2E $00 $19 $4C  $6F $77 $65 $73 $74 $20 $73 $65  $63 $74 $6F $72 $20 $6E $75 $6D
.by  $62 $65 $72 $20 $69 $73 $20 $31  $00 $0B $45 $6E $64 $20 $73 $65  $63 $74 $6F $72 $3A $00 $21 $45
.by  $6E $64 $20 $73 $65 $63 $74 $6F  $72 $20 $69 $73 $20 $67 $72 $65  $61 $74 $65 $72 $20 $74 $68 $61
.by  $6E $20 $74 $6F $74 $61 $6C $20  $00 $1F $45 $6E $64 $20 $73 $65  $63 $74 $6F $72 $20 $69 $73 $20
.by  $6C $65 $73 $73 $65 $72 $20 $74  $68 $61 $6E $20 $73 $74 $61 $72  $74 $00 $07 $73 $65 $63 $74 $6F
.by  $72 $2E $00 $08 $43 $6F $70 $79  $69 $6E $67 $20 $00 $09 $20 $73  $65 $63 $74 $6F $72 $73 $2E $00
.by  $1C $52 $65 $61 $64 $69 $6E $67  $20 $61 $6E $64 $20 $77 $72 $69  $74 $69 $6E $67 $20 $73 $65 $63
.by  $74 $6F $72 $20 $23 $00 $0E $43  $6F $70 $79 $20 $66 $69 $6E $69  $73 $68 $65 $64 $2E $00 $1D $57
.by  $72 $69 $74 $65 $20 $6C $6F $67  $20 $66 $69 $6C $65 $20 $74 $6F  $20 $64 $69 $73 $6B $3F $20 $28
.by  $59 $2F $4E $29 $00 $18 $4D $49  $4C $46 $20 $30 $2E $37 $20 $2D  $20 $64 $65 $6C $79 $2F $62 $6A
.by  $62 $20 $32 $30 $32 $30 $00 $28  $02 $00 $12 $00 $00 $00 $80 $00  $00 $00 $00 $28 $02 $00 $1A $00
.by  $04 $00 $80 $00 $00 $00 $00 $28  $02 $00 $12 $00 $04 $01 $00 $00  $00 $00 $00 $28 $02 $00 $12 $01
.by  $04 $01 $00 $00 $00 $00 $00 $50  $02 $00 $12 $01 $04 $01 $00 $00  $00 $00 $00 $D3 $22 $DB $22
.endm

	end
