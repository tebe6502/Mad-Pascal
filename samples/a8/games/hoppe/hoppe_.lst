mads 2.0.9 build 7 (7 Apr 19)
  1116 					opt l+
    81
    82 2075				RCDATA 'hoppe_.fnt' CHARSET_TILE_ADDRESS 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCDATA [Source: res6502.asm]
     2 = 0109			len = .filesize('hoppe_.fnt')
    17 2075				org main.CHARSET_TILE_ADDRESS
    19 8400-8508> 18 F6 FF 34 + 	ins 'hoppe_.fnt'
Source: hoppe.a65
    83 8509				RCASM 'dlist.asm' DL_MEM 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCASM [Source: res6502.asm]
     2 8509				org RESORIGIN
     4 = 004C			len = .sizeof(_DL_MEM)
     6 				mcpy	ift main.DL_MEM+len >= $bc20
    11 2075-20E1> 20 41 20		jsr sys.off
    13 2078 A9 96 85 86 A9 20 +  MWA #DATA EDX
    13 2080 A9 00 85 8A A9 5A +  MWA #MAIN.DL_MEM ECX
    13 2088 A9 4C 85 82 A9 00 +  MWA #LEN EAX
    13 2090 20 00 20		 JSR RESOURCE.MEMCPY
    15 2093 4C 65 20			jmp sys.on
    16 2096			data
Source: dlist.asm
     1 = 0000			DL_BLANK1 = 0; // 1 blank line
     2 = 0010			DL_BLANK2 = %00010000; // 2 blank lines
     3 = 0020			DL_BLANK3 = %00100000; // 3 blank lines
     4 = 0030			DL_BLANK4 = %00110000; // 4 blank lines
     5 = 0040			DL_BLANK5 = %01000000; // 5 blank lines
     6 = 0050			DL_BLANK6 = %01010000; // 6 blank lines
     7 = 0060			DL_BLANK7 = %01100000; // 7 blank lines
     8 = 0070			DL_BLANK8 = %01110000; // 8 blank lines
    10 = 0080			DL_DLI = %10000000; // Order to run DLI
    11 = 0040			DL_LMS = %01000000; // Order to set new memory address
    12 = 0020			DL_VSCROLL = %00100000; // Turn on vertical scroll on this line
    13 = 0010			DL_HSCROLL = %00010000; // Turn on horizontal scroll on this line
    15 = 0002			DL_MODE_40x24T2 = 2; // Antic Modes
    16 = 0004			DL_MODE_40x24T5 = 4;
    17 = 0005			DL_MODE_40x12T5 = 5;
    18 = 0006			DL_MODE_20x24T5 = 6;
    19 = 0007			DL_MODE_20x12T5 = 7;
    20 = 0008			DL_MODE_40x24G4 = 8;
    21 = 0009			DL_MODE_80x48G2 = 9;
    22 = 000A			DL_MODE_80x48G4 = $A;
    23 = 000B			DL_MODE_160x96G2 = $B;
    24 = 000C			DL_MODE_160x192G2 = $C;
    25 = 000D			DL_MODE_160x96G4 = $D;
    26 = 000E			DL_MODE_160x192G4 = $E;
    27 = 000F			DL_MODE_320x192G2 = $F;
    29 = 0001			DL_JMP = %00000001; // Order to jump
    30 = 0041			DL_JVB = %01000001; // Jump to begining
Source: const.inc
     1 = 5A00			DL_MEM = $5a00;
     2 = 5B00			TXT_RAM = $5b00;
     3 = 6000			GFX_RAM = $6000; 
     4 = 7000			PMGBASE = $7000;
     5 = 8400			CHARSET_TILE_ADDRESS = $8400;
     6 = 8800			STRINGS = $8800;
     8 = 000A			MIN_JUMP_FORCE = 10;
     9 = 0046			MAX_JUMP_FORCE = 70;
    10 = 0060			SCREENLINEWIDTH = 96;
    12 = 00B2			BOTTOM_LVL = 178;
    13 = 00D0			ROAD_LVL = 208;
    14 = 006C			BONUS_LVL = 108;
    16 = 0004			PLANE_1_SPEED = 4;
    17 = 000C			PLANE_2_SPEED = 12;
    18 = 0030			PLANE_3_SPEED = 48;
    20 = 0009			PLANE_1_START = 9;
    21 = 0003			PLANE_2_START = 3;
    22 = 0000			PLANE_3_START = 0;
    23 = 000F			PLANE_4_START = 15;
    24 = 0012			PLANE_0_START = 18;
    26 = 0046			MAX_WALL_H = 70;
    28 = 0098			B_TOP = $98;
    29 = 0090			B_BOTTOM = $90;
    30 = 0092			B_SHADOW =$92;
    31 = 0094			B_BODY =$94;
    33 = 0007			DL_OFFSET = 7;
    34 5A00			dl_start
    35 5A00 F0			    dta DL_BLANK8 + DL_DLI 
    36 5A01 30			    dta DL_BLANK4                     
    37 5A02 42 00 5B		    dta DL_MODE_40x24T2 + DL_LMS, a(TXT_RAM)           
    38 5A05 30			    dta DL_BLANK4 
    39 5A06 54 00 60		    dta DL_MODE_40x24T5 + DL_LMS + DL_HSCROLL, a(GFX_RAM)      
    40 5A09 54 60 60		    dta DL_MODE_40x24T5 + DL_LMS + DL_HSCROLL, a(GFX_RAM + (SCREENLINEWIDTH * 1))  
    41 5A0C 54 C0 60		    dta DL_MODE_40x24T5 + DL_LMS + DL_HSCROLL, a(GFX_RAM + (SCREENLINEWIDTH * 2))  
    42 5A0F 54 20 61		    dta DL_MODE_40x24T5 + DL_LMS + DL_HSCROLL, a(GFX_RAM + (SCREENLINEWIDTH * 3))  
    43 5A12 54 80 61		    dta DL_MODE_40x24T5 + DL_LMS + DL_HSCROLL, a(GFX_RAM + (SCREENLINEWIDTH * 4))  
    44 5A15 54 E0 61		    dta DL_MODE_40x24T5 + DL_LMS + DL_HSCROLL, a(GFX_RAM + (SCREENLINEWIDTH * 5))  
    45 5A18 54 40 62		    dta DL_MODE_40x24T5 + DL_LMS + DL_HSCROLL, a(GFX_RAM + (SCREENLINEWIDTH * 6))  
    46 5A1B 54 A0 62		    dta DL_MODE_40x24T5 + DL_LMS + DL_HSCROLL, a(GFX_RAM + (SCREENLINEWIDTH * 7))  
    47 5A1E 54 00 63		    dta DL_MODE_40x24T5 + DL_LMS + DL_HSCROLL, a(GFX_RAM + (SCREENLINEWIDTH * 8))  
    48 5A21 54 60 63		    dta DL_MODE_40x24T5 + DL_LMS + DL_HSCROLL, a(GFX_RAM + (SCREENLINEWIDTH * 9))  
    49 5A24 54 C0 63		    dta DL_MODE_40x24T5 + DL_LMS + DL_HSCROLL, a(GFX_RAM + (SCREENLINEWIDTH * 10))  
    50 5A27 54 20 64		    dta DL_MODE_40x24T5 + DL_LMS + DL_HSCROLL, a(GFX_RAM + (SCREENLINEWIDTH * 11))  
    51 5A2A 54 80 64		    dta DL_MODE_40x24T5 + DL_LMS + DL_HSCROLL, a(GFX_RAM + (SCREENLINEWIDTH * 12))  
    52 5A2D 54 E0 64		    dta DL_MODE_40x24T5 + DL_LMS + DL_HSCROLL, a(GFX_RAM + (SCREENLINEWIDTH * 13))  
    53 5A30 54 40 65		    dta DL_MODE_40x24T5 + DL_LMS + DL_HSCROLL, a(GFX_RAM + (SCREENLINEWIDTH * 14))  
    54 5A33 54 A0 65		    dta DL_MODE_40x24T5 + DL_LMS + DL_HSCROLL, a(GFX_RAM + (SCREENLINEWIDTH * 15))  
    55 5A36 54 00 66		    dta DL_MODE_40x24T5 + DL_LMS + DL_HSCROLL, a(GFX_RAM + (SCREENLINEWIDTH * 16))
    56 5A39 54 60 66		    dta DL_MODE_40x24T5 + DL_LMS + DL_HSCROLL, a(GFX_RAM + (SCREENLINEWIDTH * 17)) 
    57 5A3C 54 C0 66		    dta DL_MODE_40x24T5 + DL_LMS + DL_HSCROLL, a(GFX_RAM + (SCREENLINEWIDTH * 18))  
    58 5A3F 54 20 67		    dta DL_MODE_40x24T5 + DL_LMS + DL_HSCROLL, a(GFX_RAM + (SCREENLINEWIDTH * 19))  
    59 5A42 70			    dta DL_BLANK8                                
    60 5A43 70			    dta DL_BLANK8                                
    61 5A44 70			    dta DL_BLANK8                                
    62 5A45 70			    dta DL_BLANK8                                
    63 5A46 42 30 5B		    dta DL_MODE_40x24T2 + DL_LMS, a(TXT_RAM+48)  
    64 5A49 41 00 5A		    dta DL_JVB, a(dl_start)
    24 02E2-02E3> 75 20			ini mcpy
Source: hoppe.a65
    84 20E2				RCASM 'strings.asm' STRINGS 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCASM [Source: res6502.asm]
     2 20E2				org RESORIGIN
     4 = 005D			len = .sizeof(_STRINGS)
     6 				mcpy	ift main.STRINGS+len >= $bc20
    11 2075-20F2> 20 41 20		jsr sys.off
    13 2078 A9 96 85 86 A9 20 +  MWA #DATA EDX
    13 2080 A9 00 85 8A A9 88 +  MWA #MAIN.STRINGS ECX
    13 2088 A9 5D 85 82 A9 00 +  MWA #LEN EAX
    13 2090 20 00 20		 JSR RESOURCE.MEMCPY
    15 2093 4C 65 20			jmp sys.on
    16 2096			data
Source: strings.asm
     1 8800 2D 29 33 34 25 32 +     dta d'MISTER HOPPE - code bocianu - gfx piesiu'
     2 8828 33 63 6F 72 65 1A +     dta d'Score: 000000         High Score: '
     3 884A 30 32 25 33 33 00 +     dta d'PRESS ',d'FIRE'*,d' TO START'
    24 02E2-02E3> 75 20			ini mcpy
Source: hoppe.a65
    85 				.endl
    86
    87 				; -----------------------------------------------------------
    88
    89 20F3				org CODEORIGIN
    90
    91 2000				STATICDATA
Macro: STATICDATA [Source: hoppe.a65]
     1 2000-3682> 0E 17 08 1E + .by  $0E $17 $08 $1E $14 $16 $12 $08  $0C $00 $11 $05 $07 $02 $80 $88  $98 $00 $24 $32 $70 $A0 $A3 $C3
     2 2018 81 80 00 00 00 00 + .by  $81 $80 $00 $00 $00 $00 $0F $16  $08 $1E $14 $16 $12 $08 $0C $00  $10 $00 $04 $04 $0C $18 $18 $18
     3 2030 04 04 04 2C 2C 08 + .by  $04 $04 $04 $2C $2C $08 $00 $40  $60 $30 $0E $17 $08 $1E $14 $16  $12 $08 $0C $11 $29 $21 $60 $64
     4 2048 40 40 58 08 04 04 + .by  $40 $40 $58 $08 $04 $04 $4E $94  $95 $83 $81 $00 $00 $00 $00 $00  $0F $16 $08 $1E $14 $16 $12 $08
     5 2060 0C 00 10 00 00 00 + .by  $0C $00 $10 $00 $00 $00 $08 $08  $08 $18 $0C $04 $14 $34 $30 $20  $48 $70 $60 $30 $0E $17 $08 $1E
     6 2078 14 16 12 08 0C 04 + .by  $14 $16 $12 $08 $0C $04 $08 $10  $00 $00 $20 $60 $58 $08 $00 $28  $28 $40 $C0 $E0 $60 $40 $40 $40
     7 2090 00 00 00 00 00 00 + .by  $00 $00 $00 $00 $00 $00 $18 $2C  $16 $3A $2C $38 $28 $10 $40 $80  $30 $10 $90 $E0 $70 $00 $48 $68
     8 20A8 20 00 60 60 40 40 + .by  $20 $00 $60 $60 $40 $40 $00 $08  $16 $06 $0A $0E $0E $04 $00 $18  $39 $39 $78 $78 $58 $90 $80 $18
     9 20C0 1C 0E 0E 42 40 00 + .by  $1C $0E $0E $42 $40 $00 $00 $00  $00 $00 $00 $00 $00 $08 $16 $06  $0A $0E $0E $04 $00 $18 $18 $38
    10 20D8 38 38 14 08 08 00 + .by  $38 $38 $14 $08 $08 $00 $18 $18  $18 $18 $18 $30 $30 $20 $00 $00  $00 $08 $16 $06 $0A $0E $0E $04
    11 20F0 00 09 19 1C 1F 1A + .by  $00 $09 $19 $1C $1F $1A $18 $58  $40 $10 $18 $18 $30 $72 $72 $20  $00 $00 $00 $00 $00 $00 $00 $08
    12 2108 16 06 0A 0E 0E 04 + .by  $16 $06 $0A $0E $0E $04 $00 $18  $18 $38 $38 $38 $30 $18 $18 $00  $10 $18 $0C $0C $0C $18 $30 $00
    13 2120 00 00 00 08 16 06 + .by  $00 $00 $00 $08 $16 $06 $0A $0E  $0E $04 $00 $08 $1C $1C $3C $3C  $1C $58 $40 $10 $18 $18 $18 $30
    14 2138 30 00 00 00 00 00 + .by  $30 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $10 $28 $0C  $14 $1C $18 $60 $E0 $E0 $D0 $F0
    15 2150 60 00 00 70 38 18 + .by  $60 $00 $00 $70 $38 $18 $18 $30  $10 $00 $00 $00 $7E $02 $02 $02  $02 $02 $02 $22 $22 $32 $3E $02
    16 2168 24 3C 24 24 24 24 + .by  $24 $3C $24 $24 $24 $24 $24 $24  $34 $34 $24 $3C $1C $10 $10 $10  $10 $10 $10 $10 $10 $10 $10 $14
    17 2180 20 3C 24 24 24 24 + .by  $20 $3C $24 $24 $24 $24 $24 $24  $24 $2C $24 $3C $7E $7E $42 $42  $42 $42 $42 $62 $62 $72 $7E $7E
    18 2198 1E 04 04 04 04 04 + .by  $1E $04 $04 $04 $04 $04 $04 $04  $04 $04 $1C $06 $18 $18 $18 $18  $18 $18 $18 $18 $18 $18 $18 $18
    19 21B0 3C 20 20 20 20 20 + .by  $3C $20 $20 $20 $20 $20 $20 $20  $20 $20 $38 $20 $00 $20 $1D $20  $3A $20 $57 $20 $74 $20 $91 $20
    20 21C8 AE 20 CB 20 E8 20 + .by  $AE $20 $CB $20 $E8 $20 $05 $21  $22 $21 $3F $21 $5C $21 $68 $21  $74 $21 $80 $21 $8C $21 $98 $21
    21 21E0 A4 21 B0 21		.by  $A4 $21 $B0 $21
Source: hoppe.a65
    92
    93 21E4			START
    94 21E4 BA				tsx
    95 21E5 8E 03 34			stx MAIN.@halt+1
    96
    97 					.ifdef fmulinit
    98 					fmulinit
    99 					eif
   100
   101 					ift DATAORIGIN+VARINITSIZE > $BFFF
   102 					ert 'Invalid memory address range ',DATAORIGIN+VARINITSIZE
   103 					els
   104 					@fill #DATAORIGIN+VARINITSIZE #VARDATASIZE-VARINITSIZE #0
   104 				 MWA #DATAORIGIN+VARINITSIZE @FILL.PTR1\ MWA #VARDATASIZE-VARINITSIZE @FILL.PTR3\ MVA #0 @FILL.PTR2\ JSR @FILL
   104 21E8 A9 83 85 86 A9 36 +  MWA #DATAORIGIN+VARINITSIZE @FILL.PTR1
   104 21F0 A9 49 85 8A A9 00 +  MWA #VARDATASIZE-VARINITSIZE @FILL.PTR3
   104 21F8 A9 00 85 82		 MVA #0 @FILL.PTR2
   104 21FC 20 EC 35		 JSR @FILL
   105 					eif
   106
   107 21FF A2 0F			ldx #$0f
   108 2201 BD 40 03 9D 06 34 + 	mva:rpl $340,x MAIN.IOCB@COPY,x-
   109
   110 220A E8				inx		; X = 0 !!!
   111 220B 86 8E			stx bp		; lo BP = 0
   112
   113 220D				UNITINITIALIZATION
Macro: UNITINITIALIZATION [Source: hoppe.a65]
Source: hoppe.a65
   114
   115 220D			.local	MAIN						; PROCEDURE
   116
   117 					ift l_0007-*>3
   118 220D 4C 8D 2D			jmp l_0007
   119 					eif
   120
   121 				; -----------------------------------------------------------
   122
   123 2210			.local	SYSTEM						; UNIT
   124
   125 2210			.local	PEEK						; FUNCTION | ASSEMBLER | REGISTER
   126
   127 				; -----------------------------------------------------------
   128
   129 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   130 				; as Pointer
   131 2210 B5 98 85 86			mva :STACKORIGIN,x A
   132 2214 B5 A8 85 87			mva :STACKORIGIN+STACKWIDTH,x A+1
   133 2218 CA				dex						; sub bx, 1
   134
   135
   136 				; ---------------------  ASM Block 004  ---------------------
   137
   138 2219 A0 00			ldy #0
   139 221B B1 86 8D 3F 36		mva (edx),y Result
   140
   141
   142 2220			@exit
   143
   144 				; -----------------------------------------------------------
   145
   146 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   147 				; as Pointer
   148
   149 2220 E8				inx						; add bx, 1
   150 2221 AD 3F 36 95 98		mva RESULT :STACKORIGIN,x
   151
   152 					.ifdef @new
   153 					@FreeMem #@VarData #@VarDataSize
   154 					eif
   155
   156 				; -----------------------------------------------------------
   157
   158 = 0086			A	= edx
   159 = 363F			RESULT	= DATAORIGIN+$000B
   160
   161 = 363F			@VarData	= RESULT
   162 = 0001			@VarDataSize	= 1
   163
   164 2226 60				rts						; ret
   165 				.endl
   166
   167 2227			.local	RANDOM_000E					; FUNCTION | ASSEMBLER | OVERLOAD
   168
   169 				; -----------------------------------------------------------
   170
   171 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   172 				; as Pointer
   173 2227 B5 98 8D 40 36		mva :STACKORIGIN,x RANGE
   174 222C CA				dex						; sub bx, 1
   175
   176
   177 				; ---------------------  ASM Block 009  ---------------------
   178
   179
   180 				;BYTE FUNC Rand(BYTE range)
   181 				; returns random number between 0 and
   182 				; range-1.  If range=0, then a random
   183 				; number between 0 and 255 is returned
   184
   185 222D AC 0A D2			ldy	$d20a		; RANDOM
   186
   187 2230 AD 40 36			lda	range
   188 2233 F0 08			beq	stop
   189
   190 2235 85 8A			sta	ecx
   191 2237 84 82			sty	eax
   192
   193 2239 20 D4 34			jsr	imulCL
   194 223C A8				tay
   195
   196 223D 8C 41 36		stop	sty	Result
   197
   198
   199 2240			@exit
   200
   201 				; -----------------------------------------------------------
   202
   203 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   204 				; as Pointer
   205
   206 2240 E8				inx						; add bx, 1
   207 2241 AD 41 36 95 98		mva RESULT :STACKORIGIN,x
   208
   209 					.ifdef @new
   210 					@FreeMem #@VarData #@VarDataSize
   211 					eif
   212
   213 				; -----------------------------------------------------------
   214
   215 = 3640			RANGE	= DATAORIGIN+$000C
   216 = 3641			RESULT	= DATAORIGIN+$000D
   217
   218 = 3640			@VarData	= RANGE
   219 = 0002			@VarDataSize	= 2
   220
   221 2246 60				rts						; ret
   222 				.endl
   223
   224 2247			.local	POKE						; PROCEDURE | ASSEMBLER | REGISTER
   225
   226 				; -----------------------------------------------------------
   227
   228 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   229 				; as Pointer
   230 2247 B5 98 85 8A			mva :STACKORIGIN,x VALUE
   231 224B CA				dex						; sub bx, 1
   232
   233 				; -----------------------------------------------------------
   234
   235 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   236 				; as Pointer
   237 224C B5 98 85 86			mva :STACKORIGIN,x A
   238 2250 B5 A8 85 87			mva :STACKORIGIN+STACKWIDTH,x A+1
   239 2254 CA				dex						; sub bx, 1
   240
   241
   242 				; ---------------------  ASM Block 021  ---------------------
   243
   244 2255 A0 00			ldy #0
   245 2257 A5 8A 91 86			mva value (edx),y
   246
   247
   248 				; -----------------------------------------------------------
   249
   250 = 0086			A	= edx
   251 = 008A			VALUE	= ecx
   252
   253 225B			@exit
   254 					.ifdef @new
   255 					@FreeMem #@VarData #@VarDataSize
   256 					eif
   257 225B 60				rts						; ret
   258 				.endl
   259
   260 225C			.local	DPOKE						; PROCEDURE | ASSEMBLER | REGISTER
   261
   262 				; -----------------------------------------------------------
   263
   264 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   265 				; as Pointer
   266 225C B5 98 85 8A			mva :STACKORIGIN,x VALUE
   267 2260 B5 A8 85 8B			mva :STACKORIGIN+STACKWIDTH,x VALUE+1
   268 2264 CA				dex						; sub bx, 1
   269
   270 				; -----------------------------------------------------------
   271
   272 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   273 				; as Pointer
   274 2265 B5 98 85 86			mva :STACKORIGIN,x A
   275 2269 B5 A8 85 87			mva :STACKORIGIN+STACKWIDTH,x A+1
   276 226D CA				dex						; sub bx, 1
   277
   278
   279 				; ---------------------  ASM Block 022  ---------------------
   280
   281 226E A0 00			ldy #0
   282 2270 A5 8A 91 86			mva value (edx),y
   283 2274 C8				iny
   284 2275 A5 8B 91 86			mva value+1 (edx),y
   285
   286
   287 				; -----------------------------------------------------------
   288
   289 = 0086			A	= edx
   290 = 008A			VALUE	= ecx
   291
   292 2279			@exit
   293 					.ifdef @new
   294 					@FreeMem #@VarData #@VarDataSize
   295 					eif
   296 2279 60				rts						; ret
   297 				.endl
   298
   299 227A			.local	FILLBYTE_003D					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER
   300
   301 				; -----------------------------------------------------------
   302
   303 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   304 				; as Pointer
   305 227A B5 98 85 82			mva :STACKORIGIN,x VALUE
   306 227E CA				dex						; sub bx, 1
   307
   308 				; -----------------------------------------------------------
   309
   310 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   311 				; as Pointer
   312 227F B5 98 85 8A			mva :STACKORIGIN,x COUNT
   313 2283 B5 A8 85 8B			mva :STACKORIGIN+STACKWIDTH,x COUNT+1
   314 2287 CA				dex						; sub bx, 1
   315
   316 				; -----------------------------------------------------------
   317
   318 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   319 				; as Pointer
   320 2288 B5 98 85 86			mva :STACKORIGIN,x A
   321 228C B5 A8 85 87			mva :STACKORIGIN+STACKWIDTH,x A+1
   322 2290 CA				dex						; sub bx, 1
   323
   324
   325 				; ---------------------  ASM Block 029  ---------------------
   326
   327 2291 20 EC 35			jsr @fill
   328
   329
   330 				; -----------------------------------------------------------
   331
   332 = 0086			A	= edx
   333 = 008A			COUNT	= ecx
   334 = 0082			VALUE	= eax
   335
   336 2294			@exit
   337 					.ifdef @new
   338 					@FreeMem #@VarData #@VarDataSize
   339 					eif
   340 2294 60				rts						; ret
   341 				.endl
   342
   343 2295			.local	MOVE_0047					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER
   344
   345 				; -----------------------------------------------------------
   346
   347 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   348 				; as Pointer
   349 2295 B5 98 85 82			mva :STACKORIGIN,x COUNT
   350 2299 B5 A8 85 83			mva :STACKORIGIN+STACKWIDTH,x COUNT+1
   351 229D CA				dex						; sub bx, 1
   352
   353 				; -----------------------------------------------------------
   354
   355 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   356 				; as Pointer
   357 229E B5 98 85 8A			mva :STACKORIGIN,x DEST
   358 22A2 B5 A8 85 8B			mva :STACKORIGIN+STACKWIDTH,x DEST+1
   359 22A6 CA				dex						; sub bx, 1
   360
   361 				; -----------------------------------------------------------
   362
   363 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   364 				; as Pointer
   365 22A7 B5 98 85 86			mva :STACKORIGIN,x SOURCE
   366 22AB B5 A8 85 87			mva :STACKORIGIN+STACKWIDTH,x SOURCE+1
   367 22AF CA				dex						; sub bx, 1
   368
   369
   370 				; ---------------------  ASM Block 031  ---------------------
   371
   372 22B0 20 97 35			jsr @move
   373
   374
   375 				; -----------------------------------------------------------
   376
   377 = 0086			SOURCE	= edx
   378 = 008A			DEST	= ecx
   379 = 0082			COUNT	= eax
   380
   381 22B3			@exit
   382 					.ifdef @new
   383 					@FreeMem #@VarData #@VarDataSize
   384 					eif
   385 22B3 60				rts						; ret
   386 				.endl
   387
   388 22B4			.local	MOVE_0051					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER
   389
   390 				; -----------------------------------------------------------
   391
   392 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   393 				; as Pointer
   394 22B4 B5 98 85 82			mva :STACKORIGIN,x COUNT
   395 22B8 B5 A8 85 83			mva :STACKORIGIN+STACKWIDTH,x COUNT+1
   396 22BC CA				dex						; sub bx, 1
   397
   398 				; -----------------------------------------------------------
   399
   400 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   401 				; as Pointer
   402 22BD B5 98 85 8A			mva :STACKORIGIN,x DEST
   403 22C1 B5 A8 85 8B			mva :STACKORIGIN+STACKWIDTH,x DEST+1
   404 22C5 CA				dex						; sub bx, 1
   405
   406 				; -----------------------------------------------------------
   407
   408 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   409 				; as Pointer
   410 22C6 B5 98 85 86			mva :STACKORIGIN,x SOURCE
   411 22CA B5 A8 85 87			mva :STACKORIGIN+STACKWIDTH,x SOURCE+1
   412 22CE CA				dex						; sub bx, 1
   413
   414
   415 				; ---------------------  ASM Block 033  ---------------------
   416
   417 22CF 20 97 35			jsr @move
   418
   419
   420 				; -----------------------------------------------------------
   421
   422 = 0086			SOURCE	= edx
   423 = 008A			DEST	= ecx
   424 = 0082			COUNT	= eax
   425
   426 22D2			@exit
   427 					.ifdef @new
   428 					@FreeMem #@VarData #@VarDataSize
   429 					eif
   430 22D2 60				rts						; ret
   431 				.endl
   432
   433 22D3			.local	PAUSE_0067					; PROCEDURE | ASSEMBLER | OVERLOAD
   434
   435
   436 				; ---------------------  ASM Block 039  ---------------------
   437
   438 22D3 A5 14 C5 14 F0 FC		lda:cmp:req :rtclok+2
   439
   440
   441 22D9			@exit
   442 					.ifdef @new
   443 					@FreeMem #@VarData #@VarDataSize
   444 					eif
   445 22D9 60				rts						; ret
   446 				.endl
   447
   448 				; -----------------------------------------------------------
   449
   450 = 0648			M_PI_2	= $0648
   451 = 0192			D_PI_2	= $0192
   452 = 0004			D_PI_180	= $0004
   453 = 0000			MGTIA	= $0000
   454 = 0080			MVBXE	= $0080
   455 = 0010			WINDOW	= $0010
   456 = 0020			NARROW	= $0020
   457 = 0000			VBXE_XDLADR	= $0000
   458 = 0100			VBXE_BCBADR	= $0100
   459 = 1000			VBXE_MAPADR	= $1000
   460 = 5000			VBXE_OVRADR	= $5000
   461 = B000			VBXE_WINDOW	= $B000
   462 = 0000			IDLI	= $0000
   463 = 0001			IVBL	= $0001
   464 = 00FE			CH_DELCHR	= $00FE
   465 = 009B			CH_ENTER	= $009B
   466 = 001B			CH_ESC	= $001B
   467 = 001C			CH_CURS_UP	= $001C
   468 = 001D			CH_CURS_DOWN	= $001D
   469 = 001E			CH_CURS_LEFT	= $001E
   470 = 001F			CH_CURS_RIGHT	= $001F
   471 = 007F			CH_TAB	= $007F
   472 = 009B			CH_EOL	= $009B
   473 = 007D			CH_CLR	= $007D
   474 = 00FD			CH_BELL	= $00FD
   475 = 007E			CH_DEL	= $007E
   476 = 009C			CH_DELLINE	= $009C
   477 = 009D			CH_INSLINE	= $009D
   478 = 0000			COLOR_BLACK	= $0000
   479 = 000E			COLOR_WHITE	= $000E
   480 = 0032			COLOR_RED	= $0032
   481 = 0096			COLOR_CYAN	= $0096
   482 = 0068			COLOR_VIOLET	= $0068
   483 = 00C4			COLOR_GREEN	= $00C4
   484 = 0074			COLOR_BLUE	= $0074
   485 = 00EE			COLOR_YELLOW	= $00EE
   486 = 004A			COLOR_ORANGE	= $004A
   487 = 00E4			COLOR_BROWN	= $00E4
   488 = 003C			COLOR_LIGHTRED	= $003C
   489 = 0004			COLOR_GRAY1	= $0004
   490 = 0006			COLOR_GRAY2	= $0006
   491 = 000A			COLOR_GRAY3	= $000A
   492 = 00CC			COLOR_LIGHTGREEN	= $00CC
   493 = 007C			COLOR_LIGHTBLUE	= $007C
   494 = 0004			FMOPENREAD	= $0004
   495 = 0008			FMOPENWRITE	= $0008
   496 = 0009			FMOPENAPPEND	= $0009
   497 = 000C			FMOPENREADWRITE	= $000C
   498 = 3634			SCREENWIDTH	= DATAORIGIN+$0000
   499 = 3636			SCREENHEIGHT	= DATAORIGIN+$0002
   500 = 3638			DATESEPARATOR	= DATAORIGIN+$0004
   501 = 3639			FILEMODE	= DATAORIGIN+$0005
   502 = 363A			SCREENMODE	= DATAORIGIN+$0006
   503 = 363B			IORESULT	= DATAORIGIN+$0007
   504 = 363C			EOLN	= DATAORIGIN+$0008
   505 = 363D			RNDSEED	= DATAORIGIN+$0009
   506
   507 				.endl							; UNIT SYSTEM
   508
   509 				; -----------------------------------------------------------
   510
   511 22DA			.local	ATARI						; UNIT
   512
   513 				; -----------------------------------------------------------
   514
   515 = 0012			RTCLOK	= $0012
   516 = 004D			ATRACT	= $004D
   517 = 0052			LMARGIN	= $0052
   518 = 0053			RMARGIN	= $0053
   519 = 0054			ROWCRS	= $0054
   520 = 0055			COLCRS	= $0055
   521 = 0057			DINDEX	= $0057
   522 = 0058			SAVMSC	= $0058
   523 = 0200			VDSLST	= $0200
   524 = 0230			SDLSTL	= $0230
   525 = 0290			TXTROW	= $0290
   526 = 0291			TXTCOL	= $0291
   527 = 0293			TINDEX	= $0293
   528 = 0294			TXTMSC	= $0294
   529 = 022F			SDMCTL	= $022F
   530 = 026F			GPRIOR	= $026F
   531 = 02F0			CRSINH	= $02F0
   532 = 02F3			CHACT	= $02F3
   533 = 02F4			CHBAS	= $02F4
   534 = 02FC			CH	= $02FC
   535 = 02C0			PCOLR0	= $02C0
   536 = 02C1			PCOLR1	= $02C1
   537 = 02C2			PCOLR2	= $02C2
   538 = 02C3			PCOLR3	= $02C3
   539 = 02C4			COLOR0	= $02C4
   540 = 02C5			COLOR1	= $02C5
   541 = 02C6			COLOR2	= $02C6
   542 = 02C7			COLOR3	= $02C7
   543 = 02C8			COLOR4	= $02C8
   544 = 02C8			COLBAKS	= $02C8
   545 = D000			HPOSP0	= $D000
   546 = D001			HPOSP1	= $D001
   547 = D002			HPOSP2	= $D002
   548 = D003			HPOSP3	= $D003
   549 = D004			HPOSM0	= $D004
   550 = D005			HPOSM1	= $D005
   551 = D006			HPOSM2	= $D006
   552 = D007			HPOSM3	= $D007
   553 = D008			SIZEP0	= $D008
   554 = D009			SIZEP1	= $D009
   555 = D00A			SIZEP2	= $D00A
   556 = D00B			SIZEP3	= $D00B
   557 = D00C			SIZEM	= $D00C
   558 = D00D			GRAFP0	= $D00D
   559 = D00E			GRAFP1	= $D00E
   560 = D00F			GRAFP2	= $D00F
   561 = D010			GRAFP3	= $D010
   562 = D011			GRAFM	= $D011
   563 = D004			P0PF	= $D004
   564 = D014			PAL	= $D014
   565 = D012			COLPM0	= $D012
   566 = D013			COLPM1	= $D013
   567 = D014			COLPM2	= $D014
   568 = D015			COLPM3	= $D015
   569 = D016			COLPF0	= $D016
   570 = D017			COLPF1	= $D017
   571 = D018			COLPF2	= $D018
   572 = D019			COLPF3	= $D019
   573 = D01A			COLBK	= $D01A
   574 = D01B			PRIOR	= $D01B
   575 = D01D			GRACTL	= $D01D
   576 = D01E			HITCLR	= $D01E
   577 = D200			AUDF1	= $D200
   578 = D201			AUDC1	= $D201
   579 = D202			AUDF2	= $D202
   580 = D203			AUDC2	= $D203
   581 = D204			AUDF3	= $D204
   582 = D205			AUDC3	= $D205
   583 = D206			AUDF4	= $D206
   584 = D207			AUDC4	= $D207
   585 = D208			AUDCTL	= $D208
   586 = D20F			SKSTAT	= $D20F
   587 = D301			PORTB	= $D301
   588 = D400			DMACTL	= $D400
   589 = D401			CHACTL	= $D401
   590 = D402			DLISTL	= $D402
   591 = D404			HSCROL	= $D404
   592 = D405			VSCROL	= $D405
   593 = D407			PMBASE	= $D407
   594 = D409			CHBASE	= $D409
   595 = D40A			WSYNC	= $D40A
   596 = D40B			VCOUNT	= $D40B
   597 = D40C			PENH	= $D40C
   598 = D40D			PENV	= $D40D
   599 = D40E			NMIEN	= $D40E
   600
   601 				.endl							; UNIT ATARI
   602
   603 				; -----------------------------------------------------------
   604
   605 22DA			.local	CRT						; UNIT
   606
   607 				; -----------------------------------------------------------
   608
   609 = 3642			TEXTATTR	= DATAORIGIN+$000E
   610 = D01F			CONSOL	= $D01F
   611 = 0000			CN_START_SELECT_OPTION	= $0000
   612 = 0001			CN_SELECT_OPTION	= $0001
   613 = 0002			CN_START_OPTION	= $0002
   614 = 0003			CN_OPTION	= $0003
   615 = 0004			CN_START_SELECT	= $0004
   616 = 0005			CN_SELECT	= $0005
   617 = 0006			CN_START	= $0006
   618 = 0007			CN_NONE	= $0007
   619 = 0000			BW40	= $0000
   620 = 0001			CO40	= $0001
   621 = 0002			BW80	= $0002
   622 = 0003			CO80	= $0003
   623 = 0007			MONO	= $0007
   624 = 0001			C40	= $0001
   625 = 0003			C80	= $0003
   626 = 0000			BLACK	= $0000
   627 = 0001			BLUE	= $0001
   628 = 0002			GREEN	= $0002
   629 = 0003			CYAN	= $0003
   630 = 0004			RED	= $0004
   631 = 0005			MAGENTA	= $0005
   632 = 0006			BROWN	= $0006
   633 = 0007			LIGHTGRAY	= $0007
   634 = 0008			DARKGRAY	= $0008
   635 = 0009			LIGHTBLUE	= $0009
   636 = 000A			LIGHTGREEN	= $000A
   637 = 000B			LIGHTCYAN	= $000B
   638 = 000C			LIGHTRED	= $000C
   639 = 000D			LIGHTMAGENTA	= $000D
   640 = 000E			YELLOW	= $000E
   641 = 000F			WHITE	= $000F
   642 = 0080			BLINK	= $0080
   643
   644 				.endl							; UNIT CRT
   645
   646 				; -----------------------------------------------------------
   647
   648 22DA			.local	B_PMG						; UNIT
   649
   650 22DA			.local	PMG_INIT_0068					; PROCEDURE | OVERLOAD
   651
   652 				; -----------------------------------------------------------
   653
   654 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   655 				; as Pointer
   656 22DA B5 98 8D 4A 36		mva :STACKORIGIN,x GRACTL
   657 22DF CA				dex						; sub bx, 1
   658
   659 				; -----------------------------------------------------------
   660
   661 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   662 				; as Pointer
   663 22E0 B5 98 8D 49 36		mva :STACKORIGIN,x SDMCTL
   664 22E5 CA				dex						; sub bx, 1
   665
   666 				; -----------------------------------------------------------
   667
   668 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   669 				; as Pointer
   670 22E6 B5 98 8D 48 36		mva :STACKORIGIN,x BASE
   671 22EB CA				dex						; sub bx, 1
   672
   673 					ift l_0074-*>3
   674 					jmp l_0074
   675 					eif
   676
   677 				; IfThenEpilog
   678 22EC			l_0074
   679
   680 				; optimize OK (B_PMG), line = 159
   681
   682 22EC AD 48 36 8D 07 D4		mva BASE PMG_PMBASE
   683
   684 				; optimize OK (B_PMG), line = 160
   685
   686 22F2 A9 00			lda #$00
   687 22F4 8D 44 36			sta PMG_BASE
   688 22F7 AD 48 36			lda BASE
   689 22FA 8D 45 36			sta PMG_BASE+1
   690
   691 				; optimize OK (B_PMG), line = 161
   692
   693 22FD AD 4A 36 8D 1D D0		mva GRACTL PMG_GRACTL
   694
   695 				; optimize OK (B_PMG), line = 162
   696
   697 2303 AD 2F 02			lda PMG_SDMCTL_S
   698 2306 29 E0			and #$E0
   699 2308 0D 49 36			ora SDMCTL
   700 230B 8D 4B 36			sta SDMCTL_FLAGS
   701
   702 				; optimize OK (B_PMG), line = 163
   703
   704 230E AD 4B 36 8D 00 D4		mva SDMCTL_FLAGS PMG_SDMCTL
   705
   706 				; optimize OK (B_PMG), line = 164
   707
   708 2314 AD 4B 36 8D 2F 02		mva SDMCTL_FLAGS PMG_SDMCTL_S
   709
   710 				; optimize OK (B_PMG), line = 165
   711
   712 231A AD 49 36			lda SDMCTL
   713 231D A0 01			ldy #1
   714 231F 29 10			and #$10
   715 2321 D0 01			bne @+
   716 2323 88				dey
   717 2324			@
   718 					.ifdef IFTMP_25
   719 2324 8C 4C 36			sty IFTMP_25
   720 					eif
   721 2327 98				tya
   722 2328 D0 03			bne *+5
   723 232A 4C 3C 23			jmp l_00BC
   724
   725 				; optimize OK (B_PMG), line = 166
   726
   727 232D A9 01 8D 43 36		mva #$01 PMG_ONELINE
   728
   729 				; optimize OK (B_PMG), line = 167
   730
   731 2332 A9 00 8D 46 36		mva #$00 PMG_SIZE
   732 2337 A9 08 8D 47 36		mva #$08 PMG_SIZE+1
   733
   734 				; IfThenEpilog
   735 233C			l_00BC
   736
   737 				; Restore conditional expression
   738 233C AD 4C 36			lda IFTMP_25
   739
   740 				; else condition
   741 233F F0 03			beq *+5						; je
   742 2341 4C 51 23			jmp l_00CE
   743
   744 				; optimize OK (B_PMG), line = 169
   745
   746 2344 A9 00 8D 43 36		mva #$00 PMG_ONELINE
   747
   748 				; optimize OK (B_PMG), line = 170
   749
   750 2349 8D 46 36			sta PMG_SIZE
   751 234C A9 04 8D 47 36		mva #$04 PMG_SIZE+1
   752
   753 				; IfThenEpilog
   754 2351			l_00CE
   755
   756 				; -----------------------------------------------------------
   757
   758 = 3648			BASE	= DATAORIGIN+$0014
   759 = 3649			SDMCTL	= DATAORIGIN+$0015
   760 = 364A			GRACTL	= DATAORIGIN+$0016
   761 = 364B			SDMCTL_FLAGS	= DATAORIGIN+$0017
   762 = 364C			IFTMP_25	= DATAORIGIN+$0018
   763
   764 = 3648			@VarData	= BASE
   765 = 0005			@VarDataSize	= 5
   766
   767
   768 2351			@exit
   769 					.ifdef @new
   770 					@FreeMem #@VarData #@VarDataSize
   771 					eif
   772 2351 60				rts						; ret
   773 				.endl
   774
   775 2352			.local	PMG_INIT_00D7					; PROCEDURE | OVERLOAD
   776
   777 				; -----------------------------------------------------------
   778
   779 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   780 				; as Pointer
   781 2352 B5 98 8D 4E 36		mva :STACKORIGIN,x SDMCTL
   782 2357 CA				dex						; sub bx, 1
   783
   784 				; -----------------------------------------------------------
   785
   786 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   787 				; as Pointer
   788 2358 B5 98 8D 4D 36		mva :STACKORIGIN,x BASE
   789 235D CA				dex						; sub bx, 1
   790
   791 					ift l_00E0-*>3
   792 					jmp l_00E0
   793 					eif
   794
   795 				; IfThenEpilog
   796 235E			l_00E0
   797
   798 				; optimize FAIL ('PMG_INIT_0068', B_PMG), line = 177
   799 235E E8				inx
   800 235F AD 4D 36 95 98		mva BASE :STACKORIGIN,x
   801 2364 E8				inx
   802 2365 AD 4E 36 95 98		mva SDMCTL :STACKORIGIN,x
   803 236A E8				inx
   804 236B AD 4F 36 95 98		mva GRACTL :STACKORIGIN,x
   805 2370 20 DA 22			jsr PMG_INIT_0068
   806
   807 				; -----------------------------------------------------------
   808
   809 = 364D			BASE	= DATAORIGIN+$0019
   810 = 364E			SDMCTL	= DATAORIGIN+$001A
   811 = 364F			GRACTL	= DATAORIGIN+$001B
   812
   813 = 364D			@VarData	= BASE
   814 = 0003			@VarDataSize	= 3
   815
   816
   817 2373			@exit
   818 					.ifdef @new
   819 					@FreeMem #@VarData #@VarDataSize
   820 					eif
   821 2373 60				rts						; ret
   822 				.endl
   823
   824 				; -----------------------------------------------------------
   825
   826 = 0001			PMG_VDELAY_M0	= $0001
   827 = 0002			PMG_VDELAY_M1	= $0002
   828 = 0004			PMG_VDELAY_M2	= $0004
   829 = 0008			PMG_VDELAY_M3	= $0008
   830 = 0010			PMG_VDELAY_P0	= $0010
   831 = 0020			PMG_VDELAY_P1	= $0020
   832 = 0040			PMG_VDELAY_P2	= $0040
   833 = 0080			PMG_VDELAY_P3	= $0080
   834 = 0000			PMG_SIZE_NORMAL	= $0000
   835 = 0001			PMG_SIZE_X2	= $0001
   836 = 0003			PMG_SIZE_X4	= $0003
   837 = 0001			PMG_MSIZE0_X2	= $0001
   838 = 0003			PMG_MSIZE0_X4	= $0003
   839 = 0004			PMG_MSIZE1_X2	= $0004
   840 = 000C			PMG_MSIZE1_X4	= $000C
   841 = 0010			PMG_MSIZE2_X2	= $0010
   842 = 0030			PMG_MSIZE2_X4	= $0030
   843 = 0040			PMG_MSIZE3_X2	= $0040
   844 = 00C0			PMG_MSIZE4_X4	= $00C0
   845 = 0001			PMG_GRACTL_MISSILES	= $0001
   846 = 0002			PMG_GRACTL_PLAYERS	= $0002
   847 = 0004			PMG_GRACTL_LATCH	= $0004
   848 = 0003			PMG_GRACTL_DEFAULT	= $0003
   849 = 0004			PMG_SDMCTL_DMA_MISSILE	= $0004
   850 = 0008			PMG_SDMCTL_DMA_PLAYER	= $0008
   851 = 000C			PMG_SDMCTL_DMA_BOTH	= $000C
   852 = 0010			PMG_SDMCTL_ONELINE	= $0010
   853 = 0000			PMG_SDMCTL_SCREEN_DISABLED	= $0000
   854 = 0001			PMG_SDMCTL_SCREEN_NARROW	= $0001
   855 = 0002			PMG_SDMCTL_SCREEN_NORMAL	= $0002
   856 = 0003			PMG_SDMCTL_SCREEN_WIDE	= $0003
   857 = 000E			PMG_SDMCTL_DEFAULT	= $000E
   858 = 0010			PMG_5PLAYER	= $0010
   859 = 0020			PMG_OVERLAP	= $0020
   860 = D400			PMG_SDMCTL	= $D400
   861 = 022F			PMG_SDMCTL_S	= $022F
   862 = D01B			PMG_GPRIOR	= $D01B
   863 = 026F			PMG_GPRIOR_S	= $026F
   864 = D012			PMG_PCOLR0	= $D012
   865 = D013			PMG_PCOLR1	= $D013
   866 = D014			PMG_PCOLR2	= $D014
   867 = D015			PMG_PCOLR3	= $D015
   868 = 02C0			PMG_PCOLR0_S	= $02C0
   869 = 02C1			PMG_PCOLR1_S	= $02C1
   870 = 02C2			PMG_PCOLR2_S	= $02C2
   871 = 02C3			PMG_PCOLR3_S	= $02C3
   872 = D000			PMG_HPOS0	= $D000
   873 = D001			PMG_HPOS1	= $D001
   874 = D002			PMG_HPOS2	= $D002
   875 = D003			PMG_HPOS3	= $D003
   876 = D004			PMG_HPOSM0	= $D004
   877 = D005			PMG_HPOSM1	= $D005
   878 = D006			PMG_HPOSM2	= $D006
   879 = D007			PMG_HPOSM3	= $D007
   880 = D008			PMG_SIZEP0	= $D008
   881 = D009			PMG_SIZEP1	= $D009
   882 = D00A			PMG_SIZEP2	= $D00A
   883 = D00B			PMG_SIZEP3	= $D00B
   884 = D00C			PMG_SIZEM	= $D00C
   885 = D00D			PMG_GRAFP0	= $D00D
   886 = D00E			PMG_GRAFP1	= $D00E
   887 = D00F			PMG_GRAFP2	= $D00F
   888 = D010			PMG_GRAFP3	= $D010
   889 = D011			PMG_GRAFM	= $D011
   890 = D00C			PMG_P0PL	= $D00C
   891 = D00D			PMG_P1PL	= $D00D
   892 = D00E			PMG_P2PL	= $D00E
   893 = D00F			PMG_P3PL	= $D00F
   894 = D01C			PMG_VDELAY	= $D01C
   895 = D01D			PMG_GRACTL	= $D01D
   896 = D01E			PMG_HITCLR	= $D01E
   897 = D407			PMG_PMBASE	= $D407
   898 = 3643			PMG_ONELINE	= DATAORIGIN+$000F
   899 = 3644			PMG_BASE	= DATAORIGIN+$0010
   900 = 3646			PMG_SIZE	= DATAORIGIN+$0012
   901
   902 				.endl							; UNIT B_PMG
   903
   904 				; -----------------------------------------------------------
   905
   906 2374			.local	JOYSTICK					; UNIT
   907
   908 				; -----------------------------------------------------------
   909
   910 = 0278			JOY_1	= $0278
   911 = 0279			JOY_2	= $0279
   912 = 0278			adr.STICK	= $0278
   913 2374			.var STICK	= adr.STICK .word
   914 = 0278			STICK0	= $0278
   915 = 0279			STICK1	= $0279
   916 = 0284			adr.STRIG	= $0284
   917 2374			.var STRIG	= adr.STRIG .word
   918 = 0284			STRIG0	= $0284
   919 = 0285			STRIG1	= $0285
   920 = 0270			adr.PADDL	= $0270
   921 2374			.var PADDL	= adr.PADDL .word
   922 = 0270			PADDL0	= $0270
   923 = 0271			PADDL1	= $0271
   924 = 0272			PADDL2	= $0272
   925 = 0273			PADDL3	= $0273
   926 = 0274			PADDL4	= $0274
   927 = 0275			PADDL5	= $0275
   928 = 0276			PADDL6	= $0276
   929 = 0277			PADDL7	= $0277
   930 = 027C			adr.PTRIG	= $027C
   931 2374			.var PTRIG	= adr.PTRIG .word
   932 = 027C			PTRIG0	= $027C
   933 = 027D			PTRIG1	= $027D
   934 = 027E			PTRIG2	= $027E
   935 = 027F			PTRIG3	= $027F
   936 = 0280			PTRIG4	= $0280
   937 = 0281			PTRIG5	= $0281
   938 = 0282			PTRIG6	= $0282
   939 = 0283			PTRIG7	= $0283
   940 = 000F			JOY_NONE	= $000F
   941 = 000E			JOY_UP	= $000E
   942 = 000D			JOY_DOWN	= $000D
   943 = 000B			JOY_LEFT	= $000B
   944 = 000A			JOY_LEFT_UP	= $000A
   945 = 0009			JOY_LEFT_DOWN	= $0009
   946 = 0007			JOY_RIGHT	= $0007
   947 = 0006			JOY_RIGHT_UP	= $0006
   948 = 0005			JOY_RIGHT_DOWN	= $0005
   949
   950 = 2374 78 02		STICK
   950 = 2376 84 02		STRIG
   950 = 2378 70 02		PADDL
   950 = 237A 7C 02		PTRIG
   950 				.endl							; UNIT JOYSTICK
   951
   952 237C			.local	DLI						; PROCEDURE | ASSEMBLER | INTERRUPT
   953
   954
   955 				; ---------------------  ASM Block 057  ---------------------
   956
   957
   958 237C 48 8A 48 98 48	    phr
   959 				    
   960 2381 AD 56 34 85 FE AD +     mwa planesH $fe
   961
   962 238B			plane_sky
   963 238B A0 03		    ldy #3
   964 238D A2 88		    ldx #$88
   965 238F B1 FE		    lda ($fe),y
   966 2391 8D 0A D4		    sta wsync
   967 				    ;nop:nop:nop
   968 2394 8D 04 D4		    sta atari.hscrol
   969 2397 8E 1A D0		    stx atari.colbk
   970 239A A9 0A		    lda #$0a
   971 239C 8D 16 D0		    sta atari.colpf0
   972 239F A9 04		    lda #$04
   973 23A1 8D 17 D0		    sta atari.colpf1
   974 23A4 A9 88		    lda #$88
   975 23A6 8D 18 D0		    sta atari.colpf2
   976 23A9 A9 98		    lda #B_TOP
   977 23AB 8D 19 D0		    sta atari.colpf3
   978 23AE A2 0F		    ldx #$0f
   979 23B0 A9 0E		    lda #14
   980 23B2 20 55 25		    jsr waitforline
   981 23B5 A9 0C		    lda #$0c
   982 23B7 8D 0A D4		    sta wsync
   983 23BA 8D 18 D0		    sta atari.colpf2
   984 23BD 8E 17 D0		    stx atari.colpf1
   985
   986 23C0			plane_houses
   987 23C0 A9 18		    lda #24
   988 23C2 20 55 25		    jsr waitforline
   989 23C5 A0 02		    ldy #2
   990 23C7 A2 86		    ldx #$86
   991 23C9 B1 FE		    lda ($fe),y
   992 23CB 8D 0A D4		    sta wsync
   993 23CE EA EA EA		    nop:nop:nop
   994 23D1 8D 04 D4		    sta atari.hscrol
   995 23D4 8E 1A D0		    stx atari.colbk
   996 23D7 A9 18		    lda #$18
   997 23D9 8D 16 D0		    sta atari.colpf0
   998 23DC A9 1C		    lda #$1c
   999 23DE 8D 17 D0		    sta atari.colpf1
  1000 23E1 A9 91		    lda #$91
  1001 23E3 8D 18 D0		    sta atari.colpf2
  1002
  1003 23E6 A2 84		    ldx #$84
  1004 23E8 A9 26		    lda #38
  1005 23EA 20 55 25		    jsr waitforline
  1006 23ED 8D 0A D4		    sta wsync
  1007 23F0 8D 0A D4		    sta wsync
  1008 23F3 8E 1A D0		    stx atari.colbk
  1009
  1010 23F6 A9 2E		    lda #46
  1011 23F8 20 55 25		    jsr waitforline
  1012 23FB A9 B2		    lda #$b2
  1013 23FD 8D 0A D4		    sta wsync
  1014 2400 8D 16 D0		    sta atari.colpf0
  1015 2403 A9 70		    lda #$70
  1016 2405 A2 B0		    ldx #$b0
  1017 2407 8D 0A D4		    sta wsync
  1018 240A 8D 1A D0		    sta atari.colbk
  1019 240D 8E 18 D0		    stx atari.colpf2
  1020 2410 A9 98		    lda #$98
  1021 2412 8D 17 D0		    sta atari.colpf1
  1022
  1023 2415			plane_water
  1024 2415 A9 33		    lda #51
  1025 2417 20 55 25		    jsr waitforline
  1026 241A A9 74		    lda #$74
  1027 241C 8D 16 D0		    sta atari.colpf0
  1028 241F A9 7C		    lda #$7c
  1029 2421 8D 17 D0		    sta atari.colpf1
  1030 2424 A9 76		    lda #$76
  1031 2426 8D 18 D0		    sta atari.colpf2
  1032 2429 A0 01		    ldy #1
  1033 242B B1 FE		    lda ($fe),y
  1034 242D 8D 0A D4		    sta wsync
  1035 2430 EA EA EA		    nop:nop:nop
  1036 2433 8D 04 D4		    sta atari.hscrol
  1037 				    ;sta atari.colbk
  1038
  1039
  1040 2436			plane_barrel3
  1041 2436 A9 44		    lda #68
  1042 2438 20 55 25		    jsr waitforline
  1043 243B A9 92		    lda #B_SHADOW
  1044 243D 8D 0A D4		    sta wsync
  1045 2440 8D 19 D0		    sta atari.colpf3
  1046 2443 A9 94		    lda #B_BODY
  1047 2445 8D 0A D4		    sta wsync
  1048 2448 8D 19 D0		    sta atari.colpf3
  1049
  1050
  1051 244B			plane_boat
  1052 244B A9 4A		    lda #74
  1053 244D 20 55 25		    jsr waitforline
  1054 2450 A0 04		    ldy #4
  1055 2452 B1 FE		    lda ($fe),y
  1056 2454 8D 0A D4		    sta wsync
  1057 2457 EA EA EA		    :3 nop
  1058 245A 8D 04 D4		    sta atari.hscrol
  1059 				    ;sta atari.colbk
  1060 245D A9 86		    lda #$86
  1061 245F 8D 16 D0		    sta atari.colpf0
  1062 2462 A9 26		    lda #$26
  1063 2464 8D 18 D0		    sta atari.colpf2
  1064 2467 A9 4E		    lda #78
  1065 2469 20 55 25		    jsr waitforline
  1066 246C A9 92		    lda #B_SHADOW
  1067 246E 8D 0A D4		    sta wsync
  1068 2471 8D 0A D4		    sta wsync
  1069 2474 8D 19 D0		    sta atari.colpf3
  1070 2477 A9 90		    lda #B_BOTTOM
  1071 2479 8D 0A D4		    sta wsync
  1072 247C 8D 19 D0		    sta atari.colpf3
  1073 247F A9 98		    lda #B_TOP
  1074 2481 8D 0A D4		    sta wsync
  1075 2484 8D 19 D0		    sta atari.colpf3
  1076 2487 A9 92		    lda #B_SHADOW
  1077 2489 8D 0A D4		    sta wsync
  1078 248C 8D 19 D0		    sta atari.colpf3
  1079 248F A9 94		    lda #B_BODY
  1080 2491 8D 0A D4		    sta wsync
  1081 2494 8D 19 D0		    sta atari.colpf3
  1082
  1083
  1084 2497			plane_fences
  1085 2497 A9 56		    lda #86
  1086 2499 20 55 25		    jsr waitforline
  1087 249C A2 18		    ldx #$18
  1088 249E 8E 17 D0		    stx atari.colpf1
  1089 24A1 A2 24		    ldx #$24
  1090 24A3 8E 16 D0		    stx atari.colpf0
  1091 24A6 A2 10		    ldx #$10
  1092 24A8 8E 18 D0		    stx atari.colpf2
  1093 24AB A0 00		    ldy #0
  1094 24AD B1 FE		    lda ($fe),y
  1095 24AF 8D 0A D4		    sta wsync
  1096 24B2 EA EA EA		    :3 nop
  1097 24B5 8D 04 D4		    sta atari.hscrol
  1098 				    ;sta atari.colbk
  1099
  1100
  1101 				    ; barrel 2
  1102 24B8 A9 5A		    lda #90
  1103 24BA 20 55 25		    jsr waitforline
  1104 24BD A9 92		    lda #B_SHADOW
  1105 24BF 8D 0A D4		    sta wsync
  1106 24C2 8D 0A D4		    sta wsync
  1107 24C5 8D 19 D0		    sta atari.colpf3
  1108 24C8 A9 90		    lda #B_BOTTOM
  1109 24CA 8D 0A D4		    sta wsync
  1110 24CD 8D 19 D0		    sta atari.colpf3
  1111 24D0 A9 98		    lda #B_TOP
  1112 24D2 8D 0A D4		    sta wsync
  1113 24D5 8D 19 D0		    sta atari.colpf3
  1114 24D8 A9 92		    lda #B_SHADOW
  1115 24DA 8D 0A D4		    sta wsync
  1116 24DD 8D 19 D0		    sta atari.colpf3
  1117 24E0 A9 94		    lda #B_BODY
  1118 24E2 8D 0A D4		    sta wsync
  1119 24E5 8D 19 D0		    sta atari.colpf3
  1120
  1121 24E8			plane_road    
  1122 24E8 A9 5E		    lda #94
  1123 24EA 20 55 25		    jsr waitforline
  1124 24ED A9 10		    lda #$10
  1125 24EF 8D 0A D4		    sta wsync
  1126 24F2 8D 0A D4		    sta wsync
  1127 24F5 8D 1A D0		    sta atari.colbk
  1128 24F8 8D 18 D0		    sta atari.colpf2
  1129 24FB A9 00		    lda #$00
  1130 24FD 8D 0A D4		    sta wsync
  1131 2500 8D 0A D4		    sta wsync
  1132 2503 8D 1A D0		    sta atari.colbk
  1133 2506 8D 18 D0		    sta atari.colpf2
  1134 2509 A9 02		    lda #$02
  1135 250B 8D 0A D4		    sta wsync
  1136 250E 8D 1A D0		    sta atari.colbk
  1137 2511 8D 18 D0		    sta atari.colpf2
  1138
  1139 				    ; barrel 3
  1140 2514 A9 66		    lda #102
  1141 2516 20 55 25		    jsr waitforline
  1142 2519 A9 92		    lda #B_SHADOW
  1143 251B 8D 0A D4		    sta wsync
  1144 251E 8D 0A D4		    sta wsync
  1145 2521 8D 19 D0		    sta atari.colpf3
  1146 2524 A9 90		    lda #B_BOTTOM
  1147 2526 8D 0A D4		    sta wsync
  1148 2529 8D 19 D0		    sta atari.colpf3
  1149 				    
  1150 252C A9 6C		    lda #108
  1151 252E 20 55 25		    jsr waitforline
  1152 2531 A9 D2		    lda #$d2
  1153 2533 8D 0A D4		    sta wsync
  1154 2536 8D 1A D0		    sta atari.colbk
  1155 2539 8D 18 D0		    sta atari.colpf2
  1156 253C A9 D4		    lda #$d4
  1157 253E A2 0D		    ldx #$0d
  1158 2540 8D 0A D4 8D 0A D4	    :2 sta wsync
  1159 2546 8D 1A D0		    sta atari.colbk
  1160 2549 8D 18 D0		    sta atari.colpf2
  1161 254C 8E 17 D0		    stx atari.colpf1
  1162 254F 68 A8 68 AA 68	    plr
  1163 				    
  1164 2554 40			    rti
  1165 				    
  1166 2555			waitforline
  1167 2555 CD 0B D4		    cmp vcount
  1168 2558 10 FB		    bpl waitforline
  1169 255A 60			    rts
  1170
  1171 = 255B			.def :putnum
  1172 255B 29 0F		    and #%1111
  1173 255D 09 10		    ora #16
  1174 255F 99 00 5B		    sta TXT_RAM,y;
  1175 2562 88			    dey
  1176 2563 60			    rts
  1177
  1178 = 2564			.def :printScore
  1179 2564 A2 00		    ldx #0
  1180 2566			@              
  1181 2566 BD AE 36		    lda score,x 
  1182 2569 48			    pha
  1183 256A 20 5B 25		    jsr putnum
  1184 256D 68			    pla
  1185 256E 4A 4A 4A 4A		    :4 lsr 
  1186 2572 20 5B 25		    jsr putnum
  1187 2575 E8			    inx
  1188 2576 E0 03		    cpx #3
  1189 2578 D0 EC		    bne @-
  1190 257A 60			    rts
  1191 				    
  1192 = 257B			.def :addScore
  1193 257B 8A			    txa
  1194 257C 48			    pha
  1195 257D F8			    sed
  1196 257E 18			    clc
  1197 257F AD AE 36		    lda score
  1198 2582 6D A1 36		    adc count
  1199 2585 8D AE 36		    sta score
  1200 2588 A2 01		    ldx #1
  1201 258A			@             
  1202 258A BD AE 36		    lda score,x
  1203 258D 69 00		    adc #0
  1204 258F 9D AE 36		    sta score,x
  1205 2592 E8			    inx 
  1206 2593 E0 04		    cpx #4
  1207 2595 D0 F3		    bne @-
  1208 2597 D8			    cld
  1209
  1210 2598 A0 10		    ldy #16
  1211 259A 20 64 25		    jsr printScore
  1212 259D 68			    pla
  1213 259E AA			    tax
  1214 259F 60			    rts
  1215
  1216 25A0 40				rti						; ret
  1217 				.endl
  1218
  1219 25A1			.local	PUTCLOUD					; PROCEDURE
  1220
  1221 				; -----------------------------------------------------------
  1222
  1223 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
  1224 				; as Pointer
  1225 25A1 B5 98 8D BC 36		mva :STACKORIGIN,x CLOUD
  1226 25A6 B5 A8 8D BD 36		mva :STACKORIGIN+STACKWIDTH,x CLOUD+1
  1227 25AB CA				dex						; sub bx, 1
  1228
  1229 					ift l_00F2-*>3
  1230 					jmp l_00F2
  1231 					eif
  1232
  1233 				; IfThenEpilog
  1234 25AC			l_00F2
  1235
  1236 				; --- RepeatUntilProlog
  1237 25AC			l_00F3
  1238
  1239 				; optimize OK (hoppe.pas), line = 48
  1240
  1241 25AC AD 0A D2			lda RND
  1242 25AF 29 1D			and #$1D
  1243 25B1 18 6D A2 36			add VRAM
  1244 25B5 85 8A			sta :ecx
  1245 25B7 AD A3 36			lda VRAM+1
  1246 25BA 69 00			adc #$00
  1247 25BC 85 8B			sta :ecx+1
  1248 25BE AD BC 36			lda CLOUD
  1249 25C1 85 86			sta :edx
  1250 25C3 AD BD 36			lda CLOUD+1
  1251 25C6 85 87			sta :edx+1
  1252 25C8 A9 0A			lda #$0A
  1253 25CA 85 82			sta :eax
  1254 25CC A9 00			lda #$00
  1255 25CE 85 83			sta :eax+1
  1256 25D0 20 97 35			jsr @move
  1257
  1258 				; optimize FAIL (0, hoppe.pas), line = 49
  1259 25D3 CE A1 36			dec COUNT
  1260
  1261 				; optimize OK (hoppe.pas), line = 50
  1262
  1263 25D6 A0 01			ldy #1
  1264 25D8 AD A1 36			lda COUNT
  1265 25DB F0 01			beq @+
  1266 25DD 88				dey
  1267 25DE			@
  1268 25DE 98				tya
  1269 25DF D0 03			bne *+5
  1270 25E1			c_00F3
  1271 25E1 4C AC 25			jmp l_00F3
  1272 25E4			b_00F3
  1273
  1274 				; -----------------------------------------------------------
  1275
  1276 = 36BC			CLOUD	= DATAORIGIN+$0088
  1277
  1278 = 36BC			@VarData	= CLOUD
  1279 = 0002			@VarDataSize	= 2
  1280
  1281
  1282 25E4			@exit
  1283 					.ifdef @new
  1284 					@FreeMem #@VarData #@VarDataSize
  1285 					eif
  1286 25E4 60				rts						; ret
  1287 				.endl
  1288
  1289 25E5			.local	DRAWBACKGROUND					; PROCEDURE
  1290
  1291 					ift l_0118-*>3
  1292 					jmp l_0118
  1293 					eif
  1294
  1295 				; IfThenEpilog
  1296 25E5			l_0118
  1297
  1298 				; optimize OK (hoppe.pas), line = 57
  1299
  1300 25E5 A9 00 8D A1 36		mva #$00 COUNT
  1301
  1302 				; optimize OK (hoppe.pas), line = 58
  1303
  1304 25EA A9 C0 8D A2 36		mva #$C0 VRAM
  1305 25EF A9 66 8D A3 36		mva #$66 VRAM+1
  1306
  1307 				; --- RepeatUntilProlog
  1308 25F4			l_0121
  1309
  1310 				; optimize OK (hoppe.pas), line = 60
  1311
  1312 25F4 AD 46 34			lda TILE_FENCE
  1313 25F7 85 86			sta :edx
  1314 25F9 AD 47 34			lda TILE_FENCE+1
  1315 25FC 85 87			sta :edx+1
  1316 25FE AD A2 36			lda VRAM
  1317 2601 18 6D A1 36			add COUNT
  1318 2605 85 8A			sta :ecx
  1319 2607 AD A3 36			lda VRAM+1
  1320 260A 69 00			adc #$00
  1321 260C 85 8B			sta :ecx+1
  1322 260E A9 04			lda #$04
  1323 2610 85 82			sta :eax
  1324 2612 A9 00			lda #$00
  1325 2614 85 83			sta :eax+1
  1326 2616 20 97 35			jsr @move
  1327
  1328 				; optimize OK (hoppe.pas), line = 61
  1329
  1330 2619 AD 46 34			lda TILE_FENCE
  1331 261C 18 69 04			add #$04
  1332 261F 85 86			sta :edx
  1333 2621 AD 47 34			lda TILE_FENCE+1
  1334 2624 69 00			adc #$00
  1335 2626 85 87			sta :edx+1
  1336 2628 AD A2 36			lda VRAM
  1337 262B 18 69 60			add #$60
  1338 262E 85 A2			sta :STACKORIGIN+10
  1339 2630 AD A3 36			lda VRAM+1
  1340 2633 69 00			adc #$00
  1341 2635 85 B2			sta :STACKORIGIN+STACKWIDTH+10
  1342 2637 A5 A2			lda :STACKORIGIN+10
  1343 2639 18 6D A1 36			add COUNT
  1344 263D 85 8A			sta :ecx
  1345 263F A5 B2			lda :STACKORIGIN+STACKWIDTH+10
  1346 2641 69 00			adc #$00
  1347 2643 85 8B			sta :ecx+1
  1348 2645 A9 04			lda #$04
  1349 2647 85 82			sta :eax
  1350 2649 A9 00			lda #$00
  1351 264B 85 83			sta :eax+1
  1352 264D 20 97 35			jsr @move
  1353
  1354 				; optimize OK (hoppe.pas), line = 62
  1355
  1356 2650 AD A1 36			lda COUNT
  1357 2653 18 69 04			add #$04
  1358 2656 8D A1 36			sta COUNT
  1359
  1360 				; optimize OK (hoppe.pas), line = 63
  1361
  1362 2659 A0 01			ldy #1
  1363 265B AD A1 36			lda COUNT
  1364 265E C9 60			cmp #$60
  1365 2660 B0 01			bcs @+
  1366 2662 88				dey
  1367 2663			@
  1368 2663 98				tya
  1369 2664 D0 03			bne *+5
  1370 2666			c_0121
  1371 2666 4C F4 25			jmp l_0121
  1372 2669			b_0121
  1373
  1374 				; optimize OK (hoppe.pas), line = 65
  1375
  1376 2669 A9 00 8D 9E 36		mva #$00 LINE
  1377
  1378 				; optimize OK (hoppe.pas), line = 65
  1379
  1380 				; To
  1381 266E			l_015B
  1382
  1383 				; ForToDoCondition
  1384
  1385 				; optimize OK (hoppe.pas), line = 65
  1386
  1387 266E AD 9E 36			lda LINE
  1388 2671 C9 05			cmp #$05
  1389 2673 90 05			bcc *+7
  1390 2675 F0 03			beq *+5
  1391
  1392 				; ForToDoProlog
  1393 2677 4C 27 27			jmp l_0169
  1394
  1395 				; optimize OK (hoppe.pas), line = 66
  1396
  1397 267A A9 00 8D A1 36		mva #$00 COUNT
  1398
  1399 				; --- RepeatUntilProlog
  1400 267F			l_016E
  1401
  1402 				; optimize FAIL ('SYSTEM.RANDOM_000E', hoppe.pas), line = 68
  1403 267F E8				inx
  1404 2680 A9 00 95 98			mva #$00 :STACKORIGIN,x
  1405 2684 A9 60 95 A8			mva #$60 :STACKORIGIN+STACKWIDTH,x
  1406 2688 E8				inx
  1407 2689 A9 60 95 98			mva #$60 :STACKORIGIN,x
  1408 268D E8				inx
  1409 268E AD 9E 36 95 98		mva LINE :STACKORIGIN,x
  1410 2693 E8				inx
  1411 2694 A9 09 95 98			mva #$09 :STACKORIGIN,x
  1412 2698 A9 00 95 A7			mva #$00 :STACKORIGIN-1+STACKWIDTH,x
  1413 269C A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  1414 26A0 20 82 34			jsr addAX_CX
  1415 26A3 CA				dex
  1416 26A4 20 B3 34			jsr @expandToCARD1.BYTE
  1417 26A7 20 62 35			jsr imulCARD
  1418 26AA 20 5E 34			jsr movaBX_EAX
  1419 26AD CA				dex
  1420 26AE 20 B3 34			jsr @expandToCARD1.WORD
  1421 26B1 20 99 34			jsr addEAX_ECX
  1422 26B4 A9 30 95 98			mva #$30 :STACKORIGIN,x
  1423 26B8 20 27 22			jsr SYSTEM.RANDOM_000E
  1424 26BB 20 B3 34			jsr @expandToCARD.BYTE
  1425 26BE 20 99 34			jsr addEAX_ECX
  1426 26C1 CA				dex
  1427 26C2 B5 98 8D A2 36		mva :STACKORIGIN,x VRAM
  1428 26C7 B5 A8 8D A3 36		mva :STACKORIGIN+STACKWIDTH,x VRAM+1
  1429 26CC CA				dex
  1430
  1431 				; optimize OK (hoppe.pas), line = 69
  1432
  1433 26CD AD A1 36			lda COUNT
  1434 26D0 29 03			and #$03
  1435 26D2 18 69 4F			add #$4F
  1436 26D5 85 A2			sta :STACKORIGIN+10
  1437 26D7 AD A3 36			lda VRAM+1
  1438 26DA 85 8F			sta :bp+1
  1439 26DC AC A2 36			ldy VRAM
  1440 26DF A5 A2			lda :STACKORIGIN+10
  1441 26E1 91 8E			sta (:bp),y
  1442
  1443 				; optimize FAIL (0, hoppe.pas), line = 70
  1444 26E3 EE A1 36			inc COUNT
  1445
  1446 				; optimize OK (hoppe.pas), line = 71
  1447
  1448 26E6 A9 00			lda #$00
  1449 26E8 85 83			sta :eax+1
  1450 26EA AD 9E 36			lda LINE
  1451 26ED 0A				asl @
  1452 26EE 26 83			rol :eax+1
  1453 26F0 18 6D 9E 36			add LINE
  1454 26F4 85 82			sta :eax
  1455 26F6 A5 83			lda :eax+1
  1456 26F8 69 00			adc #$00
  1457 26FA 85 83			sta :eax+1
  1458 26FC A9 0F			lda #$0F
  1459 26FE 38 E5 82			sub :eax
  1460 2701 85 A2			sta :STACKORIGIN+10
  1461 2703 A9 00			lda #$00
  1462 2705 E5 83			sbc :eax+1
  1463 2707 85 B2			sta :STACKORIGIN+STACKWIDTH+10
  1464 2709 A0 01			ldy #1
  1465 270B A5 B2			lda :STACKORIGIN+STACKWIDTH+10
  1466 270D D0 05			bne @+
  1467 270F AD A1 36			lda COUNT
  1468 2712 C5 A2			cmp :STACKORIGIN+10
  1469 2714			@
  1470 2714 F0 02			seq
  1471 2716 B0 01			bcs @+
  1472 2718 88				dey
  1473 2719			@
  1474 2719 98				tya
  1475 271A D0 03			bne *+5
  1476 271C			c_016E
  1477 271C 4C 7F 26			jmp l_016E
  1478 271F			b_016E
  1479 271F			c_015B
  1480 271F EE 9E 36			inc LINE
  1481 2722 F0 03			seq
  1482 2724 4C 6E 26			jmp l_015B
  1483 2727			l_0169
  1484 2727			b_015B
  1485
  1486 				; optimize OK (hoppe.pas), line = 74
  1487
  1488 2727 A9 A0 8D A2 36		mva #$A0 VRAM
  1489 272C A9 65 8D A3 36		mva #$65 VRAM+1
  1490
  1491 				; optimize OK (hoppe.pas), line = 75
  1492
  1493 2731 AD 4C 34			lda BOAT
  1494 2734 85 86			sta :edx
  1495 2736 AD 4D 34			lda BOAT+1
  1496 2739 85 87			sta :edx+1
  1497 273B AD A2 36			lda VRAM
  1498 273E 85 8A			sta :ecx
  1499 2740 AD A3 36			lda VRAM+1
  1500 2743 85 8B			sta :ecx+1
  1501 2745 A9 03			lda #$03
  1502 2747 85 82			sta :eax
  1503 2749 A9 00			lda #$00
  1504 274B 85 83			sta :eax+1
  1505 274D 20 97 35			jsr @move
  1506
  1507 				; optimize OK (hoppe.pas), line = 76
  1508
  1509 2750 AD 4C 34			lda BOAT
  1510 2753 18 69 03			add #$03
  1511 2756 85 86			sta :edx
  1512 2758 AD 4D 34			lda BOAT+1
  1513 275B 69 00			adc #$00
  1514 275D 85 87			sta :edx+1
  1515 275F AD A2 36			lda VRAM
  1516 2762 18 69 5F			add #$5F
  1517 2765 85 8A			sta :ecx
  1518 2767 AD A3 36			lda VRAM+1
  1519 276A 69 00			adc #$00
  1520 276C 85 8B			sta :ecx+1
  1521 276E A9 05			lda #$05
  1522 2770 85 82			sta :eax
  1523 2772 A9 00			lda #$00
  1524 2774 85 83			sta :eax+1
  1525 2776 20 97 35			jsr @move
  1526
  1527 				; optimize OK (hoppe.pas), line = 78
  1528
  1529 2779 A9 00 8D BF 36		mva #$00 LH
  1530
  1531 				; optimize OK (hoppe.pas), line = 79
  1532
  1533 277E 8D A2 36			sta VRAM
  1534 2781 A9 63 8D A3 36		mva #$63 VRAM+1
  1535 				; For
  1536
  1537 				; optimize OK (hoppe.pas), line = 80
  1538
  1539 2786 A9 00 8D 9F 36		mva #$00 X
  1540
  1541 				; optimize OK (hoppe.pas), line = 80
  1542
  1543 				; To
  1544 278B			l_01DA
  1545
  1546 				; ForToDoCondition
  1547
  1548 				; optimize OK (hoppe.pas), line = 80
  1549
  1550 278B AD 9F 36			lda X
  1551 278E C9 5F			cmp #$5F
  1552 2790 90 05			bcc *+7
  1553 2792 F0 03			beq *+5
  1554
  1555 				; ForToDoProlog
  1556 2794 4C ED 27			jmp l_01E8
  1557
  1558 				; optimize OK (hoppe.pas), line = 81
  1559
  1560 2797 A9 59 8D A0 36		mva #$59 B
  1561
  1562 				; optimize OK (hoppe.pas), line = 82
  1563
  1564 279C AD 9F 36			lda X
  1565 279F A0 01			ldy #1
  1566 27A1 29 07			and #$07
  1567 27A3 F0 01			beq @+
  1568 27A5 88				dey
  1569 27A6			@
  1570 					.ifdef IFTMP_26
  1571 					sty IFTMP_26
  1572 					eif
  1573 27A6 98				tya
  1574 27A7 D0 03			bne *+5
  1575 27A9 4C B1 27			jmp l_0202
  1576
  1577 				; optimize OK (hoppe.pas), line = 82
  1578
  1579 27AC A9 60 8D A0 36		mva #$60 B
  1580
  1581 				; IfThenEpilog
  1582 27B1			l_0202
  1583
  1584 				; optimize OK (hoppe.pas), line = 83
  1585
  1586 27B1 AD A2 36			lda VRAM
  1587 27B4 18 6D 9F 36			add X
  1588 27B8 A8				tay
  1589 27B9 AD A3 36			lda VRAM+1
  1590 27BC 69 00			adc #$00
  1591 27BE 85 8F			sta :bp+1
  1592 27C0 AD A0 36			lda B
  1593 27C3 91 8E			sta (:bp),y
  1594
  1595 				; optimize OK (hoppe.pas), line = 84
  1596
  1597 27C5 AD A2 36			lda VRAM
  1598 27C8 18 6D 9F 36			add X
  1599 27CC 85 A1			sta :STACKORIGIN+9
  1600 27CE AD A3 36			lda VRAM+1
  1601 27D1 69 00			adc #$00
  1602 27D3 85 B1			sta :STACKORIGIN+STACKWIDTH+9
  1603 27D5 A5 A1			lda :STACKORIGIN+9
  1604 27D7 38 E9 60			sub #$60
  1605 27DA A8				tay
  1606 27DB A5 B1			lda :STACKORIGIN+STACKWIDTH+9
  1607 27DD E9 00			sbc #$00
  1608 27DF 85 8F			sta :bp+1
  1609 27E1 A9 56			lda #$56
  1610 27E3 91 8E			sta (:bp),y
  1611
  1612 				; ForToDoEpilog
  1613 27E5			c_01DA
  1614 27E5 EE 9F 36			inc X						; inc ptr byte [CounterAddress]
  1615
  1616 27E8 F0 03			seq
  1617
  1618 				; WhileDoEpilog
  1619 27EA 4C 8B 27			jmp l_01DA
  1620 27ED			l_01E8
  1621 27ED			b_01DA
  1622 				; For
  1623
  1624 				; optimize OK (hoppe.pas), line = 86
  1625
  1626 27ED A9 00 8D 9F 36		mva #$00 X
  1627
  1628 				; optimize OK (hoppe.pas), line = 86
  1629
  1630 				; To
  1631 27F2			l_0231
  1632
  1633 				; ForToDoCondition
  1634
  1635 				; optimize OK (hoppe.pas), line = 86
  1636
  1637 27F2 AD 9F 36			lda X
  1638 27F5 C9 2E			cmp #$2E
  1639 27F7 90 05			bcc *+7
  1640 27F9 F0 03			beq *+5
  1641
  1642 				; ForToDoProlog
  1643 27FB 4C B9 28			jmp l_023F
  1644
  1645 				; optimize OK (hoppe.pas), line = 87
  1646
  1647 27FE A9 40			lda #$40
  1648 2800 18 6D 9F 36			add X
  1649 2804 8D A2 36			sta VRAM
  1650 2807 A9 62			lda #$62
  1651 2809 69 00			adc #$00
  1652 280B 8D A3 36			sta VRAM+1
  1653
  1654 				; optimize FAIL ('SYSTEM.RANDOM_000E', hoppe.pas), line = 88
  1655 280E E8				inx
  1656 280F A9 03 95 98			mva #$03 :STACKORIGIN,x
  1657 2813 20 27 22			jsr SYSTEM.RANDOM_000E
  1658 2816 E8				inx
  1659 2817 A9 01 95 98			mva #$01 :STACKORIGIN,x
  1660 281B 20 6F 34			jsr addAL_CL
  1661 281E CA				dex
  1662 281F B5 98 8D 9E 36		mva :STACKORIGIN,x LINE
  1663 2824 CA				dex
  1664
  1665 				; optimize OK (hoppe.pas), line = 89
  1666
  1667 2825 AD 9E 36 8D BE 36		mva LINE SH
  1668
  1669 				; --- RepeatUntilProlog
  1670 282B			l_025D
  1671
  1672 				; optimize OK (hoppe.pas), line = 91
  1673
  1674 282B AD 0A D2			lda RND
  1675 282E 29 03			and #$03
  1676 2830 18 69 53			add #$53
  1677 2833 85 A2			sta :STACKORIGIN+10
  1678 2835 AD A3 36			lda VRAM+1
  1679 2838 85 8F			sta :bp+1
  1680 283A AC A2 36			ldy VRAM
  1681 283D A5 A2			lda :STACKORIGIN+10
  1682 283F 91 8E			sta (:bp),y
  1683
  1684 				; optimize OK (hoppe.pas), line = 92
  1685
  1686 2841 AD A2 36			lda VRAM
  1687 2844 18 69 01			add #$01
  1688 2847 A8				tay
  1689 2848 AD A3 36			lda VRAM+1
  1690 284B 69 00			adc #$00
  1691 284D 85 8F			sta :bp+1
  1692 284F A9 5B			lda #$5B
  1693 2851 91 8E			sta (:bp),y
  1694
  1695 				; optimize FAIL (0, hoppe.pas), line = 93
  1696 2853 CE 9E 36			dec LINE
  1697
  1698 				; optimize OK (hoppe.pas), line = 94
  1699
  1700 2856 AD A2 36			lda VRAM
  1701 2859 38 E9 60			sub #$60
  1702 285C 8D A2 36			sta VRAM
  1703 285F B0 03			scs
  1704 2861 CE A3 36			dec VRAM+1
  1705
  1706 				; optimize OK (hoppe.pas), line = 95
  1707
  1708 2864 A0 01			ldy #1
  1709 2866 AD 9E 36			lda LINE
  1710 2869 F0 01			beq @+
  1711 286B 88				dey
  1712 286C			@
  1713 286C 98				tya
  1714 286D D0 03			bne *+5
  1715 286F			c_025D
  1716 286F 4C 2B 28			jmp l_025D
  1717 2872			b_025D
  1718
  1719 				; optimize OK (hoppe.pas), line = 97
  1720
  1721 2872 A0 01			ldy #1
  1722 2874 AD BE 36			lda SH
  1723 2877 CD BF 36			cmp LH
  1724 287A B0 01			bcs @+
  1725 287C 88				dey
  1726 287D			@
  1727 					.ifdef IFTMP_27
  1728 					sty IFTMP_27
  1729 					eif
  1730 287D 98				tya
  1731 287E D0 03			bne *+5
  1732 2880 4C AB 28			jmp l_0299
  1733
  1734 				; optimize OK (hoppe.pas), line = 98
  1735
  1736 2883 AD 0A D2			lda RND
  1737 2886 29 01			and #$01
  1738 2888 18 69 57			add #$57
  1739 288B 85 A2			sta :STACKORIGIN+10
  1740 288D AD A3 36			lda VRAM+1
  1741 2890 85 8F			sta :bp+1
  1742 2892 AC A2 36			ldy VRAM
  1743 2895 A5 A2			lda :STACKORIGIN+10
  1744 2897 91 8E			sta (:bp),y
  1745
  1746 				; optimize OK (hoppe.pas), line = 99
  1747
  1748 2899 AD A2 36			lda VRAM
  1749 289C 18 69 01			add #$01
  1750 289F A8				tay
  1751 28A0 AD A3 36			lda VRAM+1
  1752 28A3 69 00			adc #$00
  1753 28A5 85 8F			sta :bp+1
  1754 28A7 A9 5A			lda #$5A
  1755 28A9 91 8E			sta (:bp),y
  1756
  1757 				; IfThenEpilog
  1758 28AB			l_0299
  1759
  1760 				; optimize OK (hoppe.pas), line = 101
  1761
  1762 28AB AD BE 36 8D BF 36		mva SH LH
  1763
  1764 				; ForToDoEpilog
  1765 28B1			c_0231
  1766 28B1 EE 9F 36			inc X						; inc ptr byte [CounterAddress]
  1767
  1768 28B4 F0 03			seq
  1769
  1770 				; WhileDoEpilog
  1771 28B6 4C F2 27			jmp l_0231
  1772 28B9			l_023F
  1773 28B9			b_0231
  1774
  1775 				; optimize OK (hoppe.pas), line = 104
  1776
  1777 28B9 A9 00 8D A2 36		mva #$00 VRAM
  1778 28BE A9 60 8D A3 36		mva #$60 VRAM+1
  1779
  1780 				; optimize OK (hoppe.pas), line = 105
  1781
  1782 28C3 A9 05 8D A1 36		mva #$05 COUNT
  1783
  1784 				; optimize FAIL ('PUTCLOUD', hoppe.pas), line = 106
  1785 28C8 E8				inx
  1786 28C9 AD 48 34 95 98		mva CLOUD1 :STACKORIGIN,x
  1787 28CE AD 49 34 95 A8		mva CLOUD1+1 :STACKORIGIN+STACKWIDTH,x
  1788 28D3 20 A1 25			jsr PUTCLOUD
  1789
  1790 				; optimize OK (hoppe.pas), line = 107
  1791
  1792 28D6 A9 60 8D A2 36		mva #$60 VRAM
  1793 28DB 8D A3 36			sta VRAM+1
  1794
  1795 				; optimize OK (hoppe.pas), line = 108
  1796
  1797 28DE A9 02 8D A1 36		mva #$02 COUNT
  1798
  1799 				; optimize FAIL ('PUTCLOUD', hoppe.pas), line = 109
  1800 28E3 E8				inx
  1801 28E4 AD 4A 34 95 98		mva CLOUD2 :STACKORIGIN,x
  1802 28E9 AD 4B 34 95 A8		mva CLOUD2+1 :STACKORIGIN+STACKWIDTH,x
  1803 28EE 20 A1 25			jsr PUTCLOUD
  1804
  1805 				; optimize OK (hoppe.pas), line = 111
  1806
  1807 28F1 A9 00 8D A2 36		mva #$00 VRAM
  1808 28F6 A9 60 8D A3 36		mva #$60 VRAM+1
  1809 				; For
  1810
  1811 				; optimize OK (hoppe.pas), line = 112
  1812
  1813 28FB A9 00 8D 9E 36		mva #$00 LINE
  1814
  1815 				; optimize OK (hoppe.pas), line = 112
  1816
  1817 				; To
  1818 2900			l_02E0
  1819
  1820 				; ForToDoCondition
  1821
  1822 				; optimize OK (hoppe.pas), line = 112
  1823
  1824 2900 AD 9E 36			lda LINE
  1825 2903 C9 10			cmp #$10
  1826 2905 90 05			bcc *+7
  1827 2907 F0 03			beq *+5
  1828
  1829 				; ForToDoProlog
  1830 2909 4C 46 29			jmp l_02EE
  1831
  1832 				; optimize OK (hoppe.pas), line = 113
  1833
  1834 290C AD A2 36			lda VRAM
  1835 290F 18 69 30			add #$30
  1836 2912 85 8A			sta :ecx
  1837 2914 AD A3 36			lda VRAM+1
  1838 2917 69 00			adc #$00
  1839 2919 85 8B			sta :ecx+1
  1840 291B AD A2 36			lda VRAM
  1841 291E 85 86			sta :edx
  1842 2920 AD A3 36			lda VRAM+1
  1843 2923 85 87			sta :edx+1
  1844 2925 A9 30			lda #$30
  1845 2927 85 82			sta :eax
  1846 2929 A9 00			lda #$00
  1847 292B 85 83			sta :eax+1
  1848 292D 20 97 35			jsr @move
  1849
  1850 				; optimize OK (hoppe.pas), line = 114
  1851
  1852 2930 AD A2 36			lda VRAM
  1853 2933 18 69 60			add #$60
  1854 2936 8D A2 36			sta VRAM
  1855 2939 90 03			scc
  1856 293B EE A3 36			inc VRAM+1
  1857
  1858 				; ForToDoEpilog
  1859 293E			c_02E0
  1860 293E EE 9E 36			inc LINE					; inc ptr byte [CounterAddress]
  1861
  1862 2941 F0 03			seq
  1863
  1864 				; WhileDoEpilog
  1865 2943 4C 00 29			jmp l_02E0
  1866 2946			l_02EE
  1867 2946			b_02E0
  1868
  1869 				; -----------------------------------------------------------
  1870
  1871 = 36BE			SH	= DATAORIGIN+$008A
  1872 = 36BF			LH	= DATAORIGIN+$008B
  1873 = 0005			@FORTMP_344	= $0005
  1874 = 005F			@FORTMP_471	= $005F
  1875 = 002E			@FORTMP_558	= $002E
  1876 = 0010			@FORTMP_733	= $0010
  1877
  1878 = 36BE			@VarData	= SH
  1879 = 0002			@VarDataSize	= 2
  1880
  1881
  1882 2946			@exit
  1883 					.ifdef @new
  1884 					@FreeMem #@VarData #@VarDataSize
  1885 					eif
  1886 2946 60				rts						; ret
  1887 				.endl
  1888
  1889 2947			.local	MOVEPLANE					; PROCEDURE
  1890
  1891 					ift l_0306-*>3
  1892 					jmp l_0306
  1893 					eif
  1894
  1895 				; IfThenEpilog
  1896 2947			l_0306
  1897
  1898 				; optimize OK (hoppe.pas), line = 122
  1899
  1900 2947 AC 92 36			ldy PLANE
  1901 294A B9 83 36			lda adr.PLANESX,y
  1902 294D 18 69 02			add #$02
  1903 2950 99 83 36			sta adr.PLANESX,y
  1904
  1905 				; optimize OK (hoppe.pas), line = 123
  1906
  1907 2953 A0 01			ldy #1
  1908 2955 AD 92 36			lda PLANE
  1909 2958 C9 04			cmp #$04
  1910 295A F0 01			beq @+
  1911 295C 88				dey
  1912 295D			@
  1913 					.ifdef IFTMP_28
  1914 					sty IFTMP_28
  1915 					eif
  1916 295D 98				tya
  1917 295E D0 03			bne *+5
  1918 2960 4C 6F 29			jmp l_031C
  1919
  1920 				; optimize OK (hoppe.pas), line = 123
  1921
  1922 2963 AC 92 36			ldy PLANE
  1923 2966 B9 83 36			lda adr.PLANESX,y
  1924 2969 38 E9 04			sub #$04
  1925 296C 99 83 36			sta adr.PLANESX,y
  1926
  1927 				; IfThenEpilog
  1928 296F			l_031C
  1929
  1930 				; optimize OK (hoppe.pas), line = 124
  1931
  1932 296F AC 92 36			ldy PLANE
  1933 2972 B9 83 36			lda adr.PLANESX,y
  1934 2975 85 A1			sta :STACKORIGIN+9
  1935 2977 A0 01			ldy #1
  1936 2979				.LOCAL
  1937 2979 A5 A1			lda :STACKORIGIN+9
  1938 297B B8 38			clv:sec
  1939 297D D0 0E			bne L4
  1940 297F F0 04		L1	beq L2
  1941 2981 B0 05			bcs L3
  1942 2983 A9 FF			lda #$FF
  1943 2985 4C 93 29		L2	jmp L5
  1944 2988 A9 01		L3	lda #$01
  1945 298A 4C 93 29			jmp L5
  1946 298D 50 04		L4	bvc L5
  1947 298F 49 FF			eor #$FF
  1948 2991 09 01			ora #$01
  1949 2993			L5
  1950 					.ENDL
  1951 2993 30 03			bmi @+
  1952 2995 F0 01			beq @+
  1953 2997 88				dey
  1954 2998			@
  1955 					.ifdef IFTMP_29
  1956 					sty IFTMP_29
  1957 					eif
  1958 2998 98				tya
  1959 2999 D0 03			bne *+5
  1960 299B 4C AA 29			jmp l_0338
  1961
  1962 				; optimize OK (hoppe.pas), line = 124
  1963
  1964 299E AC 92 36			ldy PLANE
  1965 29A1 A9 30			lda #$30
  1966 29A3 18 79 83 36			add adr.PLANESX,y
  1967 29A7 99 83 36			sta adr.PLANESX,y
  1968
  1969 				; IfThenEpilog
  1970 29AA			l_0338
  1971
  1972 				; optimize OK (hoppe.pas), line = 125
  1973
  1974 29AA AC 92 36			ldy PLANE
  1975 29AD B9 83 36			lda adr.PLANESX,y
  1976 29B0 85 A1			sta :STACKORIGIN+9
  1977 29B2 A9 30			lda #$30
  1978 29B4 85 A2			sta :STACKORIGIN+10
  1979 29B6 A0 01			ldy #1
  1980 29B8				.LOCAL
  1981 29B8 A5 A1			lda :STACKORIGIN+9
  1982 29BA 38 E5 A2			sub :STACKORIGIN+10
  1983 29BD D0 0E			bne L4
  1984 29BF F0 04		L1	beq L2
  1985 29C1 B0 05			bcs L3
  1986 29C3 A9 FF			lda #$FF
  1987 29C5 4C D3 29		L2	jmp L5
  1988 29C8 A9 01		L3	lda #$01
  1989 29CA 4C D3 29			jmp L5
  1990 29CD 50 04		L4	bvc L5
  1991 29CF 49 FF			eor #$FF
  1992 29D1 09 01			ora #$01
  1993 29D3			L5
  1994 					.ENDL
  1995 29D3 10 01			bpl @+
  1996 29D5 88				dey
  1997 29D6			@
  1998 					.ifdef IFTMP_30
  1999 					sty IFTMP_30
  2000 					eif
  2001 29D6 98				tya
  2002 29D7 D0 03			bne *+5
  2003 29D9 4C E4 29			jmp l_0364
  2004
  2005 				; optimize OK (hoppe.pas), line = 125
  2006
  2007 29DC AC 92 36			ldy PLANE
  2008 29DF A9 00 99 83 36		mva #$00 adr.PLANESX,y
  2009
  2010 				; IfThenEpilog
  2011 29E4			l_0364
  2012
  2013 				; optimize OK (hoppe.pas), line = 126
  2014
  2015 29E4 AC 92 36			ldy PLANE
  2016 29E7 B9 83 36			lda adr.PLANESX,y
  2017 29EA 85 A2			sta :STACKORIGIN+10
  2018 29EC A0 00			ldy #$00
  2019 29EE A5 A2			lda :STACKORIGIN+10
  2020 29F0 10 01			spl
  2021 29F2 88				dey
  2022 29F3 84 B2			sty :STACKORIGIN+STACKWIDTH+10
  2023 29F5 85 A1			sta :STACKORIGIN+9
  2024 29F7 A9 60			lda #$60
  2025 29F9 18 65 B2			add :STACKORIGIN+STACKWIDTH+10
  2026 29FC 85 B1			sta :STACKORIGIN+STACKWIDTH+9
  2027 29FE AC 92 36			ldy PLANE
  2028 2A01 B9 7E 36			lda adr.PLANESSTARTS,y
  2029 2A04 85 8A			sta :ecx
  2030 2A06 A9 60			lda #$60
  2031 2A08 85 82			sta :eax
  2032 					.ifdef fmulinit
  2033 					fmulu_8
  2034 					els
  2035 2A0A 20 D4 34			imulCL
  2036 					eif
  2037 2A0D A5 A1			lda :STACKORIGIN+9
  2038 2A0F 18 65 82			add :eax
  2039 2A12 8D C2 36			sta PLANESTART
  2040 2A15 A5 B1			lda :STACKORIGIN+STACKWIDTH+9
  2041 2A17 65 83			adc :eax+1
  2042 2A19 8D C3 36			sta PLANESTART+1
  2043
  2044 				; optimize OK (hoppe.pas), line = 127
  2045
  2046 2A1C A9 00			lda #$00
  2047 2A1E 85 83			sta :eax+1
  2048 2A20 AC 92 36			ldy PLANE
  2049 2A23 B9 7E 36			lda adr.PLANESSTARTS,y
  2050 2A26 0A				asl @
  2051 2A27 26 83			rol :eax+1
  2052 2A29 18 79 7E 36			add adr.PLANESSTARTS,y
  2053 2A2D 85 82			sta :eax
  2054 2A2F A9 07			lda #$07
  2055 2A31 18 65 82			add :eax
  2056 2A34 8D C1 36			sta PLANEOFFSET
  2057 				; For
  2058
  2059 				; optimize OK (hoppe.pas), line = 128
  2060
  2061 2A37 A9 00 8D C0 36		mva #$00 P
  2062
  2063 				; optimize OK (hoppe.pas), line = 128
  2064
  2065 2A3C AC 92 36			ldy PLANE
  2066 2A3F B9 79 36			lda adr.PLANESLENGTHS,y
  2067 2A42 8D C4 36			sta @FORTMP_932
  2068 				; To
  2069 2A45			l_03A7
  2070
  2071 				; ForToDoCondition
  2072
  2073 				; optimize OK (hoppe.pas), line = 128
  2074
  2075 2A45 AD C0 36			lda P
  2076 2A48 CD C4 36			cmp @FORTMP_932
  2077 2A4B 90 05			bcc *+7
  2078 2A4D F0 03			beq *+5
  2079
  2080 				; ForToDoProlog
  2081 2A4F 4C 87 2A			jmp l_03B5
  2082
  2083 				; optimize OK (hoppe.pas), line = 129
  2084
  2085 2A52 AD C1 36			lda PLANEOFFSET
  2086 2A55 85 90			sta :bp2
  2087 2A57 A9 5A			lda #$5A
  2088 2A59 85 91			sta :bp2+1
  2089 2A5B A0 00			ldy #$00
  2090 2A5D AD C2 36			lda PLANESTART
  2091 2A60 91 90			sta (:bp2),y
  2092 2A62 C8				iny
  2093 2A63 AD C3 36			lda PLANESTART+1
  2094 2A66 91 90			sta (:bp2),y
  2095
  2096 				; optimize OK (hoppe.pas), line = 130
  2097
  2098 2A68 AD C1 36			lda PLANEOFFSET
  2099 2A6B 18 69 03			add #$03
  2100 2A6E 8D C1 36			sta PLANEOFFSET
  2101
  2102 				; optimize OK (hoppe.pas), line = 131
  2103
  2104 2A71 AD C2 36			lda PLANESTART
  2105 2A74 18 69 60			add #$60
  2106 2A77 8D C2 36			sta PLANESTART
  2107 2A7A 90 03			scc
  2108 2A7C EE C3 36			inc PLANESTART+1
  2109
  2110 				; ForToDoEpilog
  2111 2A7F			c_03A7
  2112 2A7F EE C0 36			inc P						; inc ptr byte [CounterAddress]
  2113
  2114 2A82 F0 03			seq
  2115
  2116 				; WhileDoEpilog
  2117 2A84 4C 45 2A			jmp l_03A7
  2118 2A87			l_03B5
  2119 2A87			b_03A7
  2120
  2121 				; -----------------------------------------------------------
  2122
  2123 = 36C0			P	= DATAORIGIN+$008C
  2124 = 36C1			PLANEOFFSET	= DATAORIGIN+$008D
  2125 = 36C2			PLANESTART	= DATAORIGIN+$008E
  2126 = 36C4			@FORTMP_932	= DATAORIGIN+$0090
  2127
  2128 = 36C0			@VarData	= P
  2129 = 0005			@VarDataSize	= 5
  2130
  2131
  2132 2A87			@exit
  2133 					.ifdef @new
  2134 					@FreeMem #@VarData #@VarDataSize
  2135 					eif
  2136 2A87 60				rts						; ret
  2137 				.endl
  2138
  2139 2A88			.local	SETWALLH					; PROCEDURE
  2140
  2141 				; -----------------------------------------------------------
  2142
  2143 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
  2144 				; as Pointer
  2145 2A88 B5 98 8D C6 36		mva :STACKORIGIN,x HEIGHT
  2146 2A8D CA				dex						; sub bx, 1
  2147
  2148 				; -----------------------------------------------------------
  2149
  2150 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
  2151 				; as Pointer
  2152 2A8E B5 98 8D C5 36		mva :STACKORIGIN,x WALL
  2153 2A93 CA				dex						; sub bx, 1
  2154
  2155 					ift l_03D0-*>3
  2156 					jmp l_03D0
  2157 					eif
  2158
  2159 				; IfThenEpilog
  2160 2A94			l_03D0
  2161
  2162 				; optimize FAIL (50, hoppe.pas), line = 138
  2163 2A94 E8				inx
  2164 2A95 A9 03 95 98			mva #$03 :STACKORIGIN,x
  2165 2A99 E8				inx
  2166 2A9A AD C5 36 95 98		mva WALL :STACKORIGIN,x
  2167 2A9F E8				inx
  2168 2AA0 A9 02 95 98			mva #$02 :STACKORIGIN,x
  2169 2AA4 20 E7 34			jsr imulBYTE
  2170 2AA7 20 5E 34			jsr movaBX_EAX
  2171 2AAA CA				dex
  2172 2AAB 20 6F 34			jsr shlEAX_CL.BYTE
  2173 2AAE CA				dex
  2174 2AAF B5 98 8D C8 36		mva :STACKORIGIN,x MASK
  2175 2AB4 CA				dex
  2176 				; For
  2177
  2178 				; optimize OK (hoppe.pas), line = 139
  2179
  2180 2AB5 A9 00 8D C7 36		mva #$00 Y
  2181
  2182 				; optimize OK (hoppe.pas), line = 139
  2183
  2184 				; To
  2185 2ABA			l_03E7
  2186
  2187 				; ForToDoCondition
  2188
  2189 				; optimize OK (hoppe.pas), line = 139
  2190
  2191 2ABA AD C7 36			lda Y
  2192 2ABD C9 46			cmp #$46
  2193 2ABF 90 05			bcc *+7
  2194 2AC1 F0 03			beq *+5
  2195
  2196 				; ForToDoProlog
  2197 2AC3 4C 30 2B			jmp l_03F5
  2198
  2199 				; optimize OK (hoppe.pas), line = 140
  2200
  2201 2AC6 A9 D0			lda #$D0
  2202 2AC8 38 ED C7 36			sub Y
  2203 2ACC 8D A2 36			sta VRAM
  2204 2ACF A9 73			lda #$73
  2205 2AD1 E9 00			sbc #$00
  2206 2AD3 8D A3 36			sta VRAM+1
  2207
  2208 				; optimize OK (hoppe.pas), line = 141
  2209
  2210 2AD6 A0 01			ldy #1
  2211 2AD8 AD C7 36			lda Y
  2212 2ADB CD C6 36			cmp HEIGHT
  2213 2ADE 90 01			bcc @+
  2214 2AE0 88				dey
  2215 2AE1			@
  2216 					.ifdef IFTMP_31
  2217 2AE1 8C C9 36			sty IFTMP_31
  2218 					eif
  2219 2AE4 98				tya
  2220 2AE5 D0 03			bne *+5
  2221 2AE7 4C 02 2B			jmp l_041B
  2222
  2223 				; optimize OK (hoppe.pas), line = 141
  2224
  2225 2AEA AD A3 36			lda VRAM+1
  2226 2AED 85 8F			sta :bp+1
  2227 2AEF AC A2 36			ldy VRAM
  2228 2AF2 B1 8E			lda (:bp),y
  2229 2AF4 0D C8 36			ora MASK
  2230 2AF7 85 A2			sta :STACKORIGIN+10
  2231 2AF9 AD A3 36			lda VRAM+1
  2232 2AFC 85 8F			sta :bp+1
  2233 2AFE A5 A2			lda :STACKORIGIN+10
  2234 2B00 91 8E			sta (:bp),y
  2235
  2236 				; IfThenEpilog
  2237 2B02			l_041B
  2238
  2239 				; Restore conditional expression
  2240 2B02 AD C9 36			lda IFTMP_31
  2241
  2242 				; else condition
  2243 2B05 F0 03			beq *+5						; je
  2244 2B07 4C 28 2B			jmp l_0431
  2245
  2246 				; optimize OK (hoppe.pas), line = 142
  2247
  2248 2B0A AD A3 36			lda VRAM+1
  2249 2B0D 85 8F			sta :bp+1
  2250 2B0F AC A2 36			ldy VRAM
  2251 2B12 B1 8E			lda (:bp),y
  2252 2B14 85 A2			sta :STACKORIGIN+10
  2253 2B16 AD C8 36			lda MASK
  2254 2B19 49 FF			eor #$ff
  2255 2B1B 25 A2			and :STACKORIGIN+10
  2256 2B1D 85 A2			sta :STACKORIGIN+10
  2257 2B1F AD A3 36			lda VRAM+1
  2258 2B22 85 8F			sta :bp+1
  2259 2B24 A5 A2			lda :STACKORIGIN+10
  2260 2B26 91 8E			sta (:bp),y
  2261
  2262 				; IfThenEpilog
  2263 2B28			l_0431
  2264
  2265 				; ForToDoEpilog
  2266 2B28			c_03E7
  2267 2B28 EE C7 36			inc Y						; inc ptr byte [CounterAddress]
  2268
  2269 2B2B F0 03			seq
  2270
  2271 				; WhileDoEpilog
  2272 2B2D 4C BA 2A			jmp l_03E7
  2273 2B30			l_03F5
  2274 2B30			b_03E7
  2275
  2276 				; -----------------------------------------------------------
  2277
  2278 = 36C5			WALL	= DATAORIGIN+$0091
  2279 = 36C6			HEIGHT	= DATAORIGIN+$0092
  2280 = 36C7			Y	= DATAORIGIN+$0093
  2281 = 36C8			MASK	= DATAORIGIN+$0094
  2282 = 0046			@FORTMP_996	= $0046
  2283 = 36C9			IFTMP_31	= DATAORIGIN+$0095
  2284
  2285 = 36C5			@VarData	= WALL
  2286 = 0005			@VarDataSize	= 5
  2287
  2288
  2289 2B30			@exit
  2290 					.ifdef @new
  2291 					@FreeMem #@VarData #@VarDataSize
  2292 					eif
  2293 2B30 60				rts						; ret
  2294 				.endl
  2295
  2296 2B31			.local	MOVEPLANES					; PROCEDURE
  2297
  2298 					ift l_0449-*>3
  2299 					jmp l_0449
  2300 					eif
  2301
  2302 				; IfThenEpilog
  2303 2B31			l_0449
  2304 				; For
  2305
  2306 				; optimize OK (hoppe.pas), line = 148
  2307
  2308 2B31 A9 00 8D 92 36		mva #$00 PLANE
  2309
  2310 				; optimize OK (hoppe.pas), line = 148
  2311
  2312 				; To
  2313 2B36			l_0452
  2314
  2315 				; ForToDoCondition
  2316
  2317 				; optimize OK (hoppe.pas), line = 148
  2318
  2319 2B36 AD 92 36			lda PLANE
  2320 2B39 C9 03			cmp #$03
  2321 2B3B 90 05			bcc *+7
  2322 2B3D F0 03			beq *+5
  2323
  2324 				; ForToDoProlog
  2325 2B3F 4C 97 2B			jmp l_0460
  2326
  2327 				; optimize OK (hoppe.pas), line = 149
  2328
  2329 2B42 AC 92 36			ldy PLANE
  2330 2B45 B9 8D 36			lda adr.PLANESC,y
  2331 2B48 18 69 01			add #$01
  2332 2B4B 99 8D 36			sta adr.PLANESC,y
  2333
  2334 				; optimize OK (hoppe.pas), line = 150
  2335
  2336 2B4E B9 8D 36			lda adr.PLANESC,y
  2337 2B51 85 A1			sta :STACKORIGIN+9
  2338 2B53 B9 74 36			lda adr.PLANESSPEEDS,y
  2339 2B56 A0 01			ldy #1
  2340 2B58 C5 A1			cmp :STACKORIGIN+9
  2341 2B5A F0 01			beq @+
  2342 2B5C 88				dey
  2343 2B5D			@
  2344 					.ifdef IFTMP_32
  2345 					sty IFTMP_32
  2346 					eif
  2347 2B5D 98				tya
  2348 2B5E D0 03			bne *+5
  2349 2B60 4C 8F 2B			jmp l_047E
  2350
  2351 				; optimize OK (hoppe.pas), line = 151
  2352
  2353 2B63 AC 92 36			ldy PLANE
  2354 2B66 A9 00 99 8D 36		mva #$00 adr.PLANESC,y
  2355
  2356 				; optimize OK (hoppe.pas), line = 152
  2357
  2358 2B6B B9 88 36			lda adr.PLANESH,y
  2359 2B6E 38 E9 01			sub #$01
  2360 2B71 99 88 36			sta adr.PLANESH,y
  2361
  2362 				; optimize OK (hoppe.pas), line = 153
  2363
  2364 2B74 B9 88 36			lda adr.PLANESH,y
  2365 2B77 29 07			and #$07
  2366 2B79 99 88 36			sta adr.PLANESH,y
  2367
  2368 				; optimize OK (hoppe.pas), line = 154
  2369
  2370 2B7C B9 88 36			lda adr.PLANESH,y
  2371 2B7F A0 01			ldy #1
  2372 2B81 C9 07			cmp #$07
  2373 2B83 F0 01			beq @+
  2374 2B85 88				dey
  2375 2B86			@
  2376 					.ifdef IFTMP_33
  2377 					sty IFTMP_33
  2378 					eif
  2379 2B86 98				tya
  2380 2B87 D0 03			bne *+5
  2381 2B89 4C 8F 2B			jmp l_04AF
  2382
  2383 				; optimize FAIL ('MOVEPLANE', hoppe.pas), line = 154
  2384 2B8C 20 47 29			jsr MOVEPLANE
  2385
  2386 				; IfThenEpilog
  2387 2B8F			l_04AF
  2388
  2389 				; IfThenEpilog
  2390 2B8F			l_047E
  2391
  2392 				; ForToDoEpilog
  2393 2B8F			c_0452
  2394 2B8F EE 92 36			inc PLANE					; inc ptr byte [CounterAddress]
  2395
  2396 2B92 F0 03			seq
  2397
  2398 				; WhileDoEpilog
  2399 2B94 4C 36 2B			jmp l_0452
  2400 2B97			l_0460
  2401 2B97			b_0452
  2402
  2403 				; optimize OK (hoppe.pas), line = 158
  2404
  2405 2B97 EE 8C 36			inc adr.PLANESH+$04
  2406
  2407 				; optimize OK (hoppe.pas), line = 159
  2408
  2409 2B9A AD 8C 36			lda adr.PLANESH+$04
  2410 2B9D 29 07			and #$07
  2411 2B9F 8D 8C 36			sta adr.PLANESH+$04
  2412
  2413 				; optimize OK (hoppe.pas), line = 160
  2414
  2415 2BA2 A0 01			ldy #1
  2416 2BA4 AD 8C 36			lda adr.PLANESH+$04
  2417 2BA7 F0 01			beq @+
  2418 2BA9 88				dey
  2419 2BAA			@
  2420 					.ifdef IFTMP_34
  2421 					sty IFTMP_34
  2422 					eif
  2423 2BAA 98				tya
  2424 2BAB D0 03			bne *+5
  2425 2BAD 4C B8 2B			jmp l_04DB
  2426
  2427 				; optimize OK (hoppe.pas), line = 161
  2428
  2429 2BB0 A9 04 8D 92 36		mva #$04 PLANE
  2430
  2431 				; optimize FAIL ('MOVEPLANE', hoppe.pas), line = 162
  2432 2BB5 20 47 29			jsr MOVEPLANE
  2433
  2434 				; IfThenEpilog
  2435 2BB8			l_04DB
  2436 				; For
  2437
  2438 				; optimize OK (hoppe.pas), line = 166
  2439
  2440 2BB8 A9 00 8D 92 36		mva #$00 PLANE
  2441
  2442 				; optimize OK (hoppe.pas), line = 166
  2443
  2444 				; To
  2445 2BBD			l_04EC
  2446
  2447 				; ForToDoCondition
  2448
  2449 				; optimize OK (hoppe.pas), line = 166
  2450
  2451 2BBD AD 92 36			lda PLANE
  2452 2BC0 C9 03			cmp #$03
  2453 2BC2 90 05			bcc *+7
  2454 2BC4 F0 03			beq *+5
  2455
  2456 				; ForToDoProlog
  2457 2BC6 4C AC 2C			jmp l_04FA
  2458
  2459 				; optimize OK (hoppe.pas), line = 167
  2460
  2461 2BC9 AC 92 36			ldy PLANE
  2462 2BCC B9 A8 36			lda adr.WALLWAIT,y
  2463 2BCF A0 01			ldy #1
  2464 2BD1 C9 00			cmp #$00
  2465 2BD3 F0 01			beq @+
  2466 2BD5 88				dey
  2467 2BD6			@
  2468 					.ifdef IFTMP_35
  2469 2BD6 8C CA 36			sty IFTMP_35
  2470 					eif
  2471 2BD9 98				tya
  2472 2BDA D0 03			bne *+5
  2473 2BDC 4C 90 2C			jmp l_050F
  2474
  2475 				; optimize OK (hoppe.pas), line = 168
  2476
  2477 2BDF AC 92 36			ldy PLANE
  2478 2BE2 B9 A4 36			lda adr.WALLPOSX,y
  2479 2BE5 38 E9 01			sub #$01
  2480 2BE8 99 A4 36			sta adr.WALLPOSX,y
  2481
  2482 				; optimize OK (hoppe.pas), line = 169
  2483
  2484 2BEB B9 A4 36			lda adr.WALLPOSX,y
  2485 2BEE A0 01			ldy #1
  2486 2BF0 C9 00			cmp #$00
  2487 2BF2 F0 01			beq @+
  2488 2BF4 88				dey
  2489 2BF5			@
  2490 2BF5 84 A1			sty :STACKORIGIN+9
  2491 2BF7 AD 9B 36			lda GAMEOVER
  2492 2BFA D0 04			bne @+
  2493 2BFC A9 01			lda #true
  2494 2BFE D0 02			sne
  2495 2C00 A9 00		@	lda #false
  2496 2C02 25 A1			and :STACKORIGIN+9
  2497 					.ifdef IFTMP_36
  2498 					sta IFTMP_36
  2499 					eif
  2500 2C04 D0 03			bne *+5
  2501 2C06 4C 90 2C			jmp l_0532
  2502
  2503 				; optimize OK (hoppe.pas), line = 170
  2504
  2505 2C09 AC 92 36			ldy PLANE
  2506 2C0C A9 FF 99 A4 36		mva #$FF adr.WALLPOSX,y
  2507
  2508 				; optimize FAIL ('SYSTEM.RANDOM_000E', hoppe.pas), line = 171
  2509 2C11 E8				inx
  2510 2C12 AD 92 36 95 98		mva PLANE :STACKORIGIN,x
  2511 2C17 E8				inx
  2512 2C18 AD B7 36 95 98		mva LASTWALL :STACKORIGIN,x
  2513 2C1D E8				inx
  2514 2C1E A9 09 95 98			mva #$09 :STACKORIGIN,x
  2515 2C22 20 6F 34			jsr addAL_CL
  2516 2C25 A9 0C 95 98			mva #$0C :STACKORIGIN,x
  2517 2C29 E8				inx
  2518 2C2A AD B8 36 95 98		mva DIFFICULTY :STACKORIGIN,x
  2519 2C2F 20 6F 34			jsr addAL_CL
  2520 2C32 CA				dex
  2521 2C33 20 27 22			jsr SYSTEM.RANDOM_000E
  2522 2C36 A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  2523 2C3A 20 82 34			jsr addAX_CX
  2524 2C3D CA				dex
  2525 2C3E B4 97			ldy :STACKORIGIN-1,x
  2526 2C40 B5 98 99 A8 36		mva :STACKORIGIN,x adr.WALLWAIT,y
  2527 2C45 CA				dex
  2528 2C46 CA				dex
  2529
  2530 				; optimize OK (hoppe.pas), line = 172
  2531
  2532 2C47 AC 92 36			ldy PLANE
  2533 2C4A B9 A8 36			lda adr.WALLWAIT,y
  2534 2C4D 8D B7 36			sta LASTWALL
  2535
  2536 				; optimize FAIL ('SYSTEM.RANDOM_000E', hoppe.pas), line = 173
  2537 2C50 E8				inx
  2538 2C51 AD 92 36 95 98		mva PLANE :STACKORIGIN,x
  2539 2C56 E8				inx
  2540 2C57 A9 03 95 98			mva #$03 :STACKORIGIN,x
  2541 2C5B 20 27 22			jsr SYSTEM.RANDOM_000E
  2542 2C5E E8				inx
  2543 2C5F A9 01 95 98			mva #$01 :STACKORIGIN,x
  2544 2C63 20 6F 34			jsr addAL_CL
  2545 2C66 A9 18 95 98			mva #$18 :STACKORIGIN,x
  2546 2C6A A9 00 95 A8			mva #$00 :STACKORIGIN+STACKWIDTH,x
  2547 2C6E 20 19 35			jsr imulWORD
  2548 2C71 20 5E 34			jsr movaBX_EAX
  2549 2C74 CA				dex
  2550 2C75 20 88 2A			jsr SETWALLH
  2551
  2552 				; optimize OK (hoppe.pas), line = 174
  2553
  2554 2C78 A0 01			ldy #1
  2555 2C7A AD 92 36			lda PLANE
  2556 2C7D C9 03			cmp #$03
  2557 2C7F F0 01			beq @+
  2558 2C81 88				dey
  2559 2C82			@
  2560 					.ifdef IFTMP_37
  2561 					sty IFTMP_37
  2562 					eif
  2563 2C82 98				tya
  2564 2C83 D0 03			bne *+5
  2565 2C85 4C 90 2C			jmp l_057B
  2566
  2567 				; optimize OK (hoppe.pas), line = 174
  2568
  2569 2C88 AD 0A D2			lda RND
  2570 2C8B 29 07			and #$07
  2571 2C8D 8D AD 36			sta BONUSW
  2572
  2573 				; IfThenEpilog
  2574 2C90			l_057B
  2575
  2576 				; IfThenEpilog
  2577 2C90			l_0532
  2578
  2579 				; IfThenEpilog
  2580 2C90			l_050F
  2581
  2582 				; Restore conditional expression
  2583 2C90 AD CA 36			lda IFTMP_35
  2584
  2585 				; else condition
  2586 2C93 F0 03			beq *+5						; je
  2587 2C95 4C A4 2C			jmp l_0593
  2588
  2589 				; optimize OK (hoppe.pas), line = 176
  2590
  2591 2C98 AC 92 36			ldy PLANE
  2592 2C9B B9 A8 36			lda adr.WALLWAIT,y
  2593 2C9E 38 E9 01			sub #$01
  2594 2CA1 99 A8 36			sta adr.WALLWAIT,y
  2595
  2596 				; IfThenEpilog
  2597 2CA4			l_0593
  2598
  2599 				; ForToDoEpilog
  2600 2CA4			c_04EC
  2601 2CA4 EE 92 36			inc PLANE					; inc ptr byte [CounterAddress]
  2602
  2603 2CA7 F0 03			seq
  2604
  2605 				; WhileDoEpilog
  2606 2CA9 4C BD 2B			jmp l_04EC
  2607 2CAC			l_04FA
  2608 2CAC			b_04EC
  2609
  2610 				; optimize OK (hoppe.pas), line = 178
  2611
  2612 2CAC AD 5A 34			lda WALLPOSX
  2613 2CAF 85 86			sta :edx
  2614 2CB1 AD 5B 34			lda WALLPOSX+1
  2615 2CB4 85 87			sta :edx+1
  2616 2CB6 A9 04			lda #$04
  2617 2CB8 85 8A			sta :ecx
  2618 2CBA A9 D0			lda #$D0
  2619 2CBC 85 8B			sta :ecx+1
  2620 2CBE A9 04			lda #$04
  2621 2CC0 85 82			sta :eax
  2622 2CC2 A9 00			lda #$00
  2623 2CC4 85 83			sta :eax+1
  2624 2CC6 20 97 35			jsr @move
  2625
  2626 				; optimize OK (hoppe.pas), line = 179
  2627
  2628 2CC9 A0 01			ldy #1
  2629 2CCB AD B7 36			lda LASTWALL
  2630 2CCE C9 00			cmp #$00
  2631 2CD0 F0 02			seq
  2632 2CD2 B0 01			bcs @+
  2633 2CD4 88				dey
  2634 2CD5			@
  2635 					.ifdef IFTMP_38
  2636 					sty IFTMP_38
  2637 					eif
  2638 2CD5 98				tya
  2639 2CD6 D0 03			bne *+5
  2640 2CD8 4C DE 2C			jmp l_05B3
  2641
  2642 				; optimize FAIL (0, hoppe.pas), line = 179
  2643 2CDB CE B7 36			dec LASTWALL
  2644
  2645 				; IfThenEpilog
  2646 2CDE			l_05B3
  2647
  2648 				; optimize OK (hoppe.pas), line = 182
  2649
  2650 2CDE A5 14			lda $0014
  2651 2CE0 29 01			and #$01
  2652 2CE2 85 82			sta :eax
  2653 2CE4 A9 49			lda #$49
  2654 2CE6 85 8A			sta :ecx
  2655 					.ifdef fmulinit
  2656 					fmulu_8
  2657 					els
  2658 2CE8 20 D4 34			imulCL
  2659 					eif
  2660 2CEB A5 82			lda :eax
  2661 2CED 8D 2F 66			sta $662F
  2662
  2663 				; optimize OK (hoppe.pas), line = 185
  2664
  2665 2CF0 A5 14			lda $0014
  2666 2CF2 4A				lsr @
  2667 2CF3 4A				lsr @
  2668 2CF4 4A				lsr @
  2669 2CF5 29 03			and #$03
  2670 2CF7 8D 92 36			sta PLANE
  2671
  2672 				; optimize OK (hoppe.pas), line = 186
  2673
  2674 2CFA AD 92 36			lda PLANE
  2675 2CFD 0A				asl @
  2676 2CFE A8				tay
  2677 2CFF B9 D4 21			lda adr.B0FRAMES,y
  2678 2D02 85 86			sta :edx
  2679 2D04 B9 D5 21			lda adr.B0FRAMES+1,y
  2680 2D07 85 87			sta :edx+1
  2681 2D09 A9 6C			lda #$6C
  2682 2D0B 85 8A			sta :ecx
  2683 2D0D A9 76			lda #$76
  2684 2D0F 85 8B			sta :ecx+1
  2685 2D11 A9 0C			lda #$0C
  2686 2D13 85 82			sta :eax
  2687 2D15 A9 00			lda #$00
  2688 2D17 85 83			sta :eax+1
  2689 2D19 20 97 35			jsr @move
  2690
  2691 				; optimize OK (hoppe.pas), line = 187
  2692
  2693 2D1C AD 92 36			lda PLANE
  2694 2D1F 0A				asl @
  2695 2D20 A8				tay
  2696 2D21 B9 DC 21			lda adr.B1FRAMES,y
  2697 2D24 85 86			sta :edx
  2698 2D26 B9 DD 21			lda adr.B1FRAMES+1,y
  2699 2D29 85 87			sta :edx+1
  2700 2D2B A9 6C			lda #$6C
  2701 2D2D 85 8A			sta :ecx
  2702 2D2F A9 77			lda #$77
  2703 2D31 85 8B			sta :ecx+1
  2704 2D33 A9 0C			lda #$0C
  2705 2D35 85 82			sta :eax
  2706 2D37 A9 00			lda #$00
  2707 2D39 85 83			sta :eax+1
  2708 2D3B 20 97 35			jsr @move
  2709
  2710 				; optimize OK (hoppe.pas), line = 190
  2711
  2712 2D3E A9 00 8D AC 36		mva #$00 BONUSX
  2713
  2714 				; optimize OK (hoppe.pas), line = 191
  2715
  2716 2D43 A0 01			ldy #1
  2717 2D45 AD AD 36			lda BONUSW
  2718 2D48 C9 04			cmp #$04
  2719 2D4A 90 01			bcc @+
  2720 2D4C 88				dey
  2721 2D4D			@
  2722 					.ifdef IFTMP_39
  2723 					sty IFTMP_39
  2724 					eif
  2725 2D4D 98				tya
  2726 2D4E D0 03			bne *+5
  2727 2D50 4C 5C 2D			jmp l_05F9
  2728
  2729 				; optimize OK (hoppe.pas), line = 191
  2730
  2731 2D53 AC AD 36			ldy BONUSW
  2732 2D56 B9 A4 36			lda adr.WALLPOSX,y
  2733 2D59 8D AC 36			sta BONUSX
  2734
  2735 				; IfThenEpilog
  2736 2D5C			l_05F9
  2737
  2738 				; optimize OK (hoppe.pas), line = 192
  2739
  2740 2D5C AD AC 36 8D 02 D0		mva BONUSX B_PMG.PMG_HPOS2
  2741
  2742 				; optimize OK (hoppe.pas), line = 193
  2743
  2744 2D62 AD AC 36 8D 03 D0		mva BONUSX B_PMG.PMG_HPOS3
  2745
  2746 				; -----------------------------------------------------------
  2747
  2748 = 0003			@FORTMP_1103	= $0003
  2749 = 0003			@FORTMP_1257	= $0003
  2750 = 36CA			IFTMP_35	= DATAORIGIN+$0096
  2751
  2752 = 36CA			@VarData	= IFTMP_35
  2753 = 0001			@VarDataSize	= 1
  2754
  2755
  2756 2D68			@exit
  2757 					.ifdef @new
  2758 					@FreeMem #@VarData #@VarDataSize
  2759 					eif
  2760 2D68 60				rts						; ret
  2761 				.endl
  2762
  2763 2D69			.local	SHOWENERGY					; PROCEDURE
  2764
  2765 					ift l_0615-*>3
  2766 					jmp l_0615
  2767 					eif
  2768
  2769 				; IfThenEpilog
  2770 2D69			l_0615
  2771
  2772 				; optimize OK (hoppe.pas), line = 199
  2773
  2774 2D69 AD B6 36			lda ENERGY
  2775 2D6C 4A				lsr @
  2776 2D6D 85 8A			sta :ecx
  2777 2D6F A9 00			lda #$00
  2778 2D71 85 8B			sta :ecx+1
  2779 2D73 A9 34			lda #$34
  2780 2D75 85 86			sta :edx
  2781 2D77 A9 5B			lda #$5B
  2782 2D79 85 87			sta :edx+1
  2783 2D7B A9 4E			lda #$4E
  2784 2D7D 85 82			sta :eax
  2785 2D7F 20 EC 35			jsr @fill
  2786
  2787 2D82			@exit
  2788 					.ifdef @new
  2789 					@FreeMem #@VarData #@VarDataSize
  2790 					eif
  2791 2D82 60				rts						; ret
  2792 				.endl
  2793
  2794 2D83			.local	SHOWHISCORE					; PROCEDURE | ASSEMBLER
  2795
  2796
  2797 				; ---------------------  ASM Block 058  ---------------------
  2798
  2799
  2800 2D83 8A			        txa
  2801 2D84 48			        pha
  2802 2D85 A0 2B		        ldy #43
  2803 2D87 20 64 25		        jsr printScore
  2804 2D8A 68			        pla
  2805 2D8B AA			        tax
  2806 				    
  2807
  2808 2D8C			@exit
  2809 					.ifdef @new
  2810 					@FreeMem #@VarData #@VarDataSize
  2811 					eif
  2812 2D8C 60				rts						; ret
  2813 				.endl
  2814
  2815 				; IfThenEpilog
  2816 2D8D			l_0007
  2817
  2818 				; optimize OK (hoppe.pas), line = 215
  2819
  2820 2D8D AD 54 34			lda PLANESX
  2821 2D90 85 86			sta :edx
  2822 2D92 AD 55 34			lda PLANESX+1
  2823 2D95 85 87			sta :edx+1
  2824 2D97 A9 05			lda #$05
  2825 2D99 85 8A			sta :ecx
  2826 2D9B A9 00			lda #$00
  2827 2D9D 85 8B			sta :ecx+1
  2828 2D9F 85 82			sta :eax
  2829 2DA1 20 EC 35			jsr @fill
  2830
  2831 				; optimize OK (hoppe.pas), line = 216
  2832
  2833 2DA4 AD 56 34			lda PLANESH
  2834 2DA7 85 86			sta :edx
  2835 2DA9 AD 57 34			lda PLANESH+1
  2836 2DAC 85 87			sta :edx+1
  2837 2DAE A9 05			lda #$05
  2838 2DB0 85 8A			sta :ecx
  2839 2DB2 A9 00			lda #$00
  2840 2DB4 85 8B			sta :ecx+1
  2841 2DB6 A9 07			lda #$07
  2842 2DB8 85 82			sta :eax
  2843 2DBA 20 EC 35			jsr @fill
  2844
  2845 				; optimize OK (hoppe.pas), line = 217
  2846
  2847 2DBD AD 58 34			lda PLANESC
  2848 2DC0 85 86			sta :edx
  2849 2DC2 AD 59 34			lda PLANESC+1
  2850 2DC5 85 87			sta :edx+1
  2851 2DC7 A9 05			lda #$05
  2852 2DC9 85 8A			sta :ecx
  2853 2DCB A9 00			lda #$00
  2854 2DCD 85 8B			sta :ecx+1
  2855 2DCF 85 82			sta :eax
  2856 2DD1 20 EC 35			jsr @fill
  2857
  2858 				; optimize OK (hoppe.pas), line = 219
  2859
  2860 2DD4 A9 00			lda #$00
  2861 2DD6 85 86			sta :edx
  2862 2DD8 A9 5B			lda #$5B
  2863 2DDA 85 87			sta :edx+1
  2864 2DDC A9 00			lda #$00
  2865 2DDE 85 8A			sta :ecx
  2866 2DE0 A9 24			lda #$24
  2867 2DE2 85 8B			sta :ecx+1
  2868 2DE4 A9 00			lda #$00
  2869 2DE6 85 82			sta :eax
  2870 2DE8 20 EC 35			jsr @fill
  2871
  2872 				; optimize OK (hoppe.pas), line = 221
  2873
  2874 2DEB A9 00			lda #$00
  2875 2DED 85 86			sta :edx
  2876 2DEF A9 E0			lda #$E0
  2877 2DF1 85 87			sta :edx+1
  2878 2DF3 A9 00			lda #$00
  2879 2DF5 85 8A			sta :ecx
  2880 2DF7 A9 80			lda #$80
  2881 2DF9 85 8B			sta :ecx+1
  2882 2DFB A9 00			lda #$00
  2883 2DFD 85 82			sta :eax
  2884 2DFF A9 04			lda #$04
  2885 2E01 85 83			sta :eax+1
  2886 2E03 20 97 35			jsr @move
  2887
  2888 				; optimize OK (hoppe.pas), line = 222
  2889
  2890 2E06 A9 00			lda #$00
  2891 2E08 85 86			sta :edx
  2892 2E0A A9 84			lda #$84
  2893 2E0C 85 87			sta :edx+1
  2894 2E0E A9 00			lda #$00
  2895 2E10 85 8A			sta :ecx
  2896 2E12 A9 82			lda #$82
  2897 2E14 85 8B			sta :ecx+1
  2898 2E16 A9 08			lda #$08
  2899 2E18 85 82			sta :eax
  2900 2E1A A9 01			lda #$01
  2901 2E1C 85 83			sta :eax+1
  2902 2E1E 20 97 35			jsr @move
  2903
  2904 				; optimize OK (hoppe.pas), line = 223
  2905
  2906 2E21 A9 80 8D F4 02		mva #$80 ATARI.CHBAS
  2907
  2908 				; optimize FAIL ('SYSTEM.PAUSE_0067', hoppe.pas), line = 226
  2909 2E26 20 D3 22			jsr SYSTEM.PAUSE_0067
  2910
  2911 				; optimize OK (hoppe.pas), line = 227
  2912
  2913 2E29 A9 00 8D 30 02		mva #$00 ATARI.SDLSTL
  2914 2E2E A9 5A 8D 31 02		mva #$5A ATARI.SDLSTL+1
  2915
  2916 				; optimize OK (hoppe.pas), line = 228
  2917
  2918 2E33 A9 7C 8D 00 02		mva <DLI VDSLST
  2919 2E38 A9 23 8D 01 02		mva >DLI VDSLST+1
  2920
  2921 				; optimize OK (hoppe.pas), line = 229
  2922
  2923 2E3D A9 C0 8D 0E D4		mva #$C0 ATARI.NMIEN
  2924
  2925 				; optimize FAIL ('B_PMG.PMG_INIT_00D7', hoppe.pas), line = 232
  2926 2E42 E8				inx
  2927 2E43 A9 70 95 98			mva #$70 :STACKORIGIN,x
  2928 2E47 E8				inx
  2929 2E48 A9 1F 95 98			mva #$1F :STACKORIGIN,x
  2930 2E4C 20 52 23			jsr B_PMG.PMG_INIT_00D7
  2931
  2932 				; optimize OK (hoppe.pas), line = 234
  2933
  2934 2E4F A9 24 8D C0 02		mva #$24 B_PMG.PMG_PCOLR0_S
  2935
  2936 				; optimize OK (hoppe.pas), line = 235
  2937
  2938 2E54 A9 1A 8D C1 02		mva #$1A B_PMG.PMG_PCOLR1_S
  2939
  2940 				; optimize OK (hoppe.pas), line = 236
  2941
  2942 2E59 A9 E6 8D C2 02		mva #$E6 B_PMG.PMG_PCOLR2_S
  2943
  2944 				; optimize OK (hoppe.pas), line = 237
  2945
  2946 2E5E A9 EA 8D C3 02		mva #$EA B_PMG.PMG_PCOLR3_S
  2947
  2948 				; optimize OK (hoppe.pas), line = 239
  2949
  2950 2E63 A9 3C 8D 00 D0		mva #$3C B_PMG.PMG_HPOS0
  2951
  2952 				; optimize OK (hoppe.pas), line = 240
  2953
  2954 2E68 8D 01 D0			sta B_PMG.PMG_HPOS1
  2955
  2956 				; optimize OK (hoppe.pas), line = 242
  2957
  2958 2E6B A9 31 8D 6F 02		mva #$31 B_PMG.PMG_GPRIOR_S
  2959
  2960 				; optimize OK (hoppe.pas), line = 243
  2961
  2962 2E70 A9 FF 8D 0C D0		mva #$FF B_PMG.PMG_SIZEM
  2963
  2964 				; optimize OK (hoppe.pas), line = 246
  2965
  2966 2E75 A9 00			lda #$00
  2967 2E77 85 86			sta :edx
  2968 2E79 A9 88			lda #$88
  2969 2E7B 85 87			sta :edx+1
  2970 2E7D A9 04			lda #$04
  2971 2E7F 85 8A			sta :ecx
  2972 2E81 A9 5B			lda #$5B
  2973 2E83 85 8B			sta :ecx+1
  2974 2E85 A9 28			lda #$28
  2975 2E87 85 82			sta :eax
  2976 2E89 A9 00			lda #$00
  2977 2E8B 85 83			sta :eax+1
  2978 2E8D 20 97 35			jsr @move
  2979
  2980 				; optimize FAIL ('DRAWBACKGROUND', hoppe.pas), line = 248
  2981 2E90 20 E5 25			jsr DRAWBACKGROUND
  2982
  2983 				; optimize OK (hoppe.pas), line = 250
  2984
  2985 2E93 A9 03			lda #$03
  2986 2E95 8D 0F D2			sta $D20F
  2987
  2988 				; optimize OK (hoppe.pas), line = 251
  2989
  2990 2E98 A9 00			lda #$00
  2991 2E9A 8D 08 D2			sta $D208
  2992
  2993 				; --- RepeatUntilProlog
  2994 2E9D			l_0678
  2995
  2996 				; optimize OK (hoppe.pas), line = 256
  2997
  2998 2E9D A9 4A			lda #$4A
  2999 2E9F 85 86			sta :edx
  3000 2EA1 A9 88			lda #$88
  3001 2EA3 85 87			sta :edx+1
  3002 2EA5 A9 3E			lda #$3E
  3003 2EA7 85 8A			sta :ecx
  3004 2EA9 A9 5B			lda #$5B
  3005 2EAB 85 8B			sta :ecx+1
  3006 2EAD A9 13			lda #$13
  3007 2EAF 85 82			sta :eax
  3008 2EB1 A9 00			lda #$00
  3009 2EB3 85 83			sta :eax+1
  3010 2EB5 20 97 35			jsr @move
  3011
  3012 				; optimize OK (hoppe.pas), line = 258
  3013
  3014 2EB8 A9 00			lda #$00
  3015 2EBA 85 86			sta :edx
  3016 2EBC A9 74			lda #$74
  3017 2EBE 85 87			sta :edx+1
  3018 2EC0 A9 00			lda #$00
  3019 2EC2 85 8A			sta :ecx
  3020 2EC4 A9 02			lda #$02
  3021 2EC6 85 8B			sta :ecx+1
  3022 2EC8 A9 00			lda #$00
  3023 2ECA 85 82			sta :eax
  3024 2ECC 20 EC 35			jsr @fill
  3025
  3026 				; optimize OK (hoppe.pas), line = 259
  3027
  3028 2ECF A9 01 8D 9B 36		mva #$01 GAMEOVER
  3029
  3030 				; optimize OK (hoppe.pas), line = 260
  3031
  3032 2ED4 A9 0A 8D AD 36		mva #$0A BONUSW
  3033
  3034 				; --- RepeatUntilProlog
  3035 2ED9			l_0689
  3036
  3037 				; optimize FAIL ('SYSTEM.PAUSE_0067', hoppe.pas), line = 263
  3038 2ED9 20 D3 22			jsr SYSTEM.PAUSE_0067
  3039
  3040 				; optimize FAIL ('MOVEPLANES', hoppe.pas), line = 264
  3041 2EDC 20 31 2B			jsr MOVEPLANES
  3042
  3043 				; optimize OK (hoppe.pas), line = 265
  3044
  3045 2EDF A0 01			ldy #1
  3046 2EE1 AD 84 02			lda JOYSTICK.STRIG0
  3047 2EE4 F0 01			beq @+
  3048 2EE6 88				dey
  3049 2EE7			@
  3050 2EE7 98				tya
  3051 2EE8 D0 03			bne *+5
  3052 2EEA			c_0689
  3053 2EEA 4C D9 2E			jmp l_0689
  3054 2EED			b_0689
  3055
  3056 				; optimize OK (hoppe.pas), line = 267
  3057
  3058 2EED A0 01			ldy #1
  3059 2EEF AD B1 36			lda SCORE+3
  3060 2EF2 CD B5 36			cmp HISCORE+3
  3061 2EF5 D0 16			bne @+
  3062 2EF7 AD B0 36			lda SCORE+2
  3063 2EFA CD B4 36			cmp HISCORE+2
  3064 2EFD D0 0E			bne @+
  3065 2EFF AD AF 36			lda SCORE+1
  3066 2F02 CD B3 36			cmp HISCORE+1
  3067 2F05 D0 06			bne @+
  3068 2F07 AD AE 36			lda SCORE
  3069 2F0A CD B2 36			cmp HISCORE
  3070 2F0D			@
  3071 2F0D B0 01			bcs @+
  3072 2F0F 88				dey
  3073 2F10			@
  3074 					.ifdef IFTMP_40
  3075 					sty IFTMP_40
  3076 					eif
  3077 2F10 98				tya
  3078 2F11 D0 03			bne *+5
  3079 2F13 4C 31 2F			jmp l_06A8
  3080
  3081 				; optimize OK (hoppe.pas), line = 268
  3082
  3083 2F16 AD AE 36 8D B2 36		mva SCORE HISCORE
  3084 2F1C AD AF 36 8D B3 36		mva SCORE+1 HISCORE+1
  3085 2F22 AD B0 36 8D B4 36		mva SCORE+2 HISCORE+2
  3086 2F28 AD B1 36 8D B5 36		mva SCORE+3 HISCORE+3
  3087
  3088 				; optimize FAIL ('SHOWHISCORE', hoppe.pas), line = 270
  3089 2F2E 20 83 2D			jsr SHOWHISCORE
  3090
  3091 				; IfThenEpilog
  3092 2F31			l_06A8
  3093
  3094 				; optimize OK (hoppe.pas), line = 272
  3095
  3096 2F31 A9 28			lda #$28
  3097 2F33 85 86			sta :edx
  3098 2F35 A9 88			lda #$88
  3099 2F37 85 87			sta :edx+1
  3100 2F39 A9 04			lda #$04
  3101 2F3B 85 8A			sta :ecx
  3102 2F3D A9 5B			lda #$5B
  3103 2F3F 85 8B			sta :ecx+1
  3104 2F41 A9 22			lda #$22
  3105 2F43 85 82			sta :eax
  3106 2F45 A9 00			lda #$00
  3107 2F47 85 83			sta :eax+1
  3108 2F49 20 97 35			jsr @move
  3109
  3110 				; optimize OK (hoppe.pas), line = 275
  3111
  3112 2F4C AD 5A 34			lda WALLPOSX
  3113 2F4F 85 86			sta :edx
  3114 2F51 AD 5B 34			lda WALLPOSX+1
  3115 2F54 85 87			sta :edx+1
  3116 2F56 A9 04			lda #$04
  3117 2F58 85 8A			sta :ecx
  3118 2F5A A9 00			lda #$00
  3119 2F5C 85 8B			sta :ecx+1
  3120 2F5E A9 01			lda #$01
  3121 2F60 85 82			sta :eax
  3122 2F62 20 EC 35			jsr @fill
  3123
  3124 				; optimize OK (hoppe.pas), line = 276
  3125
  3126 2F65 AD 5C 34			lda WALLWAIT
  3127 2F68 85 86			sta :edx
  3128 2F6A AD 5D 34			lda WALLWAIT+1
  3129 2F6D 85 87			sta :edx+1
  3130 2F6F A9 04			lda #$04
  3131 2F71 85 8A			sta :ecx
  3132 2F73 A9 00			lda #$00
  3133 2F75 85 8B			sta :ecx+1
  3134 2F77 A9 64			lda #$64
  3135 2F79 85 82			sta :eax
  3136 2F7B 20 EC 35			jsr @fill
  3137
  3138 				; optimize OK (hoppe.pas), line = 277
  3139
  3140 2F7E A9 01 8D AC 36		mva #$01 BONUSX
  3141
  3142 				; optimize FAIL ('MOVEPLANES', hoppe.pas), line = 278
  3143 2F83 20 31 2B			jsr MOVEPLANES
  3144
  3145 				; optimize OK (hoppe.pas), line = 280
  3146
  3147 2F86 A9 00 8D B7 36		mva #$00 LASTWALL
  3148
  3149 				; optimize OK (hoppe.pas), line = 281
  3150
  3151 2F8B A9 00 8D AE 36		mva #$00 SCORE
  3152 2F90 8D AF 36			sta SCORE+1
  3153 2F93 8D B0 36			sta SCORE+2
  3154 2F96 8D B1 36			sta SCORE+3
  3155
  3156 				; optimize OK (hoppe.pas), line = 282
  3157
  3158 2F99 A9 00 8D B8 36		mva #$00 DIFFICULTY
  3159
  3160 				; optimize OK (hoppe.pas), line = 283
  3161
  3162 2F9E 8D 97 36			sta CY
  3163
  3164 				; optimize OK (hoppe.pas), line = 284
  3165
  3166 2FA1 A9 50 8D B6 36		mva #$50 ENERGY
  3167
  3168 				; optimize OK (hoppe.pas), line = 285
  3169
  3170 2FA6 A9 20 8D 94 36		mva #$20 Y
  3171
  3172 				; optimize OK (hoppe.pas), line = 286
  3173
  3174 2FAB A9 01 8D 99 36		mva #$01 FLY
  3175
  3176 				; optimize OK (hoppe.pas), line = 287
  3177
  3178 2FB0 A9 00 8D 9A 36		mva #$00 JUMP
  3179
  3180 				; optimize OK (hoppe.pas), line = 288
  3181
  3182 2FB5 A9 01 8D 95 36		mva #$01 SY
  3183 2FBA A9 00 8D 96 36		mva #$00 SY+1
  3184
  3185 				; optimize OK (hoppe.pas), line = 289
  3186
  3187 2FBF 8D 9B 36			sta GAMEOVER
  3188
  3189 				; optimize OK (hoppe.pas), line = 290
  3190
  3191 2FC2 8D 9C 36			sta COUNTSCORE
  3192
  3193 				; optimize OK (hoppe.pas), line = 291
  3194
  3195 2FC5 A9 B2 8D 98 36		mva #$B2 BOTTOM
  3196
  3197 				; optimize OK (hoppe.pas), line = 292
  3198
  3199 2FCA A9 00 8D BB 36		mva #$00 DAMAGECOUNT
  3200
  3201 				; optimize OK (hoppe.pas), line = 294
  3202
  3203 2FCF A9 28 8D B9 36		mva #$28 FXVOL
  3204
  3205 				; optimize OK (hoppe.pas), line = 295
  3206
  3207 2FD4 A9 00 8D BA 36		mva #$00 FXFREQ
  3208
  3209 				; optimize FAIL ('SHOWENERGY', hoppe.pas), line = 297
  3210 2FD9 20 69 2D			jsr SHOWENERGY
  3211
  3212 				; --- RepeatUntilProlog
  3213 2FDC			l_0701
  3214
  3215 				; optimize OK (hoppe.pas), line = 301
  3216
  3217 2FDC A0 01			ldy #1
  3218 2FDE AD BB 36			lda DAMAGECOUNT
  3219 2FE1 F0 01			beq @+
  3220 2FE3 88				dey
  3221 2FE4			@
  3222 					.ifdef IFTMP_41
  3223 2FE4 8C CB 36			sty IFTMP_41
  3224 					eif
  3225 2FE7 98				tya
  3226 2FE8 D0 03			bne *+5
  3227 2FEA 4C 03 30			jmp l_0713
  3228
  3229 				; optimize OK (hoppe.pas), line = 302
  3230
  3231 2FED A5 14			lda $0014
  3232 2FEF 4A				lsr @
  3233 2FF0 4A				lsr @
  3234 2FF1 29 03			and #$03
  3235 2FF3 8D 93 36			sta FRAME
  3236
  3237 				; optimize OK (hoppe.pas), line = 303
  3238
  3239 					.ifdef IFTMP_42
  3240 					lda FLY
  3241 					sta IFTMP_42
  3242 					eif
  3243 2FF6 AD 99 36			lda FLY
  3244 2FF9 D0 03			bne *+5
  3245 2FFB 4C 03 30			jmp l_072D
  3246
  3247 				; optimize OK (hoppe.pas), line = 303
  3248
  3249 2FFE A9 04 8D 93 36		mva #$04 FRAME
  3250
  3251 				; IfThenEpilog
  3252 3003			l_072D
  3253
  3254 				; IfThenEpilog
  3255 3003			l_0713
  3256
  3257 				; Restore conditional expression
  3258 3003 AD CB 36			lda IFTMP_41
  3259
  3260 				; else condition
  3261 3006 F0 03			beq *+5						; je
  3262 3008 4C 0E 30			jmp l_073D
  3263
  3264 				; optimize FAIL (0, hoppe.pas), line = 304
  3265 300B CE BB 36			dec DAMAGECOUNT
  3266
  3267 				; IfThenEpilog
  3268 300E			l_073D
  3269
  3270 				; optimize OK (hoppe.pas), line = 309
  3271
  3272 300E AD 08 D0			lda B_PMG.PMG_SIZEP0
  3273 3011 0D 09 D0			ora B_PMG.PMG_SIZEP1
  3274 3014 0D 0A D0			ora B_PMG.PMG_SIZEP2
  3275 3017 A0 01			ldy #1
  3276 3019 0D 0B D0			ora B_PMG.PMG_SIZEP3
  3277 301C D0 01			bne @+
  3278 301E 88				dey
  3279 301F			@
  3280 301F 84 A1			sty :STACKORIGIN+9
  3281 3021 A0 01			ldy #1
  3282 3023 AD B6 36			lda ENERGY
  3283 3026 C9 00			cmp #$00
  3284 3028 F0 02			seq
  3285 302A B0 01			bcs @+
  3286 302C 88				dey
  3287 302D			@
  3288 302D 98				tya
  3289 302E 25 A1			and :STACKORIGIN+9
  3290 					.ifdef IFTMP_43
  3291 					sta IFTMP_43
  3292 					eif
  3293 3030 D0 03			bne *+5
  3294 3032 4C C1 30			jmp l_0771
  3295
  3296 				; optimize OK (hoppe.pas), line = 310
  3297
  3298 3035 A9 64 8D B9 36		mva #$64 FXVOL
  3299
  3300 				; optimize OK (hoppe.pas), line = 311
  3301
  3302 303A AD 0A D2			lda RND
  3303 303D 29 0F			and #$0F
  3304 303F 8D BA 36			sta FXFREQ
  3305
  3306 				; optimize FAIL (0, hoppe.pas), line = 312
  3307 3042 CE B6 36			dec ENERGY
  3308
  3309 				; optimize OK (hoppe.pas), line = 313
  3310
  3311 3045 A9 5B			lda #$5B
  3312 3047 85 B1			sta :STACKORIGIN+STACKWIDTH+9
  3313 3049 AD B6 36			lda ENERGY
  3314 304C 4A				lsr @
  3315 304D 18 69 34			add #$34
  3316 3050 A8				tay
  3317 3051 A5 B1			lda :STACKORIGIN+STACKWIDTH+9
  3318 3053 69 00			adc #$00
  3319 3055 85 8F			sta :bp+1
  3320 3057 A9 00			lda #$00
  3321 3059 91 8E			sta (:bp),y
  3322
  3323 				; optimize OK (hoppe.pas), line = 314
  3324
  3325 305B A9 05 8D 93 36		mva #$05 FRAME
  3326
  3327 				; optimize OK (hoppe.pas), line = 315
  3328
  3329 3060 A9 0A 8D BB 36		mva #$0A DAMAGECOUNT
  3330
  3331 				; optimize OK (hoppe.pas), line = 316
  3332
  3333 3065 A0 01			ldy #1
  3334 3067 AD B6 36			lda ENERGY
  3335 306A F0 01			beq @+
  3336 306C 88				dey
  3337 306D			@
  3338 					.ifdef IFTMP_44
  3339 					sty IFTMP_44
  3340 					eif
  3341 306D 98				tya
  3342 306E D0 03			bne *+5
  3343 3070 4C C1 30			jmp l_07AF
  3344
  3345 				; optimize OK (hoppe.pas), line = 317
  3346
  3347 3073 A9 F0 8D 98 36		mva #$F0 BOTTOM
  3348
  3349 				; optimize OK (hoppe.pas), line = 318
  3350
  3351 3078 A9 00 8D 9C 36		mva #$00 COUNTSCORE
  3352
  3353 				; optimize OK (hoppe.pas), line = 319
  3354
  3355 307D A0 01			ldy #1
  3356 307F				.LOCAL
  3357 307F AD 96 36			lda SY+1
  3358 3082 B8 38			clv:sec
  3359 3084 D0 13			bne L4
  3360 3086 AD 95 36			lda SY
  3361 3089 C9 01			cmp #$01
  3362 308B F0 12		L1	beq L5
  3363 308D B0 05			bcs L3
  3364 308F A9 FF			lda #$FF
  3365 3091 4C 9F 30			jmp L5
  3366 3094 A9 01		L3	lda #$01
  3367 3096 4C 9F 30			jmp L5
  3368 3099 50 04		L4	bvc L5
  3369 309B 49 FF			eor #$FF
  3370 309D 09 01			ora #$01
  3371 309F			L5
  3372 					.ENDL
  3373 309F 30 01			bmi @+
  3374 30A1 88				dey
  3375 30A2			@
  3376 					.ifdef IFTMP_45
  3377 					sty IFTMP_45
  3378 					eif
  3379 30A2 98				tya
  3380 30A3 D0 03			bne *+5
  3381 30A5 4C B2 30			jmp l_07C9
  3382
  3383 				; optimize OK (hoppe.pas), line = 319
  3384
  3385 30A8 A9 01 8D 95 36		mva #$01 SY
  3386 30AD A9 00 8D 96 36		mva #$00 SY+1
  3387
  3388 				; IfThenEpilog
  3389 30B2			l_07C9
  3390
  3391 				; optimize OK (hoppe.pas), line = 320
  3392
  3393 30B2 A9 CA 8D B9 36		mva #$CA FXVOL
  3394
  3395 				; optimize OK (hoppe.pas), line = 321
  3396
  3397 30B7 A9 FF 8D BA 36		mva #$FF FXFREQ
  3398
  3399 				; optimize OK (hoppe.pas), line = 322
  3400
  3401 30BC A9 01 8D 99 36		mva #$01 FLY
  3402
  3403 				; IfThenEpilog
  3404 30C1			l_07AF
  3405
  3406 				; IfThenEpilog
  3407 30C1			l_0771
  3408
  3409 				; optimize OK (hoppe.pas), line = 327
  3410
  3411 30C1 AD 0E D0			lda B_PMG.PMG_P2PL
  3412 30C4 0D 0F D0			ora B_PMG.PMG_P3PL
  3413 30C7 A0 01			ldy #1
  3414 30C9 29 03			and #$03
  3415 30CB D0 01			bne @+
  3416 30CD 88				dey
  3417 30CE			@
  3418 					.ifdef IFTMP_46
  3419 					sty IFTMP_46
  3420 					eif
  3421 30CE 98				tya
  3422 30CF D0 03			bne *+5
  3423 30D1 4C 13 31			jmp l_07FC
  3424
  3425 				; optimize OK (hoppe.pas), line = 328
  3426
  3427 30D4 A9 28 8D B9 36		mva #$28 FXVOL
  3428
  3429 				; optimize OK (hoppe.pas), line = 329
  3430
  3431 30D9 A9 00 8D BA 36		mva #$00 FXFREQ
  3432
  3433 				; optimize OK (hoppe.pas), line = 330
  3434
  3435 30DE A9 0A 8D AD 36		mva #$0A BONUSW
  3436
  3437 				; optimize OK (hoppe.pas), line = 331
  3438
  3439 30E3 A9 00 8D AC 36		mva #$00 BONUSX
  3440
  3441 				; optimize OK (hoppe.pas), line = 332
  3442
  3443 30E8 AD B6 36			lda ENERGY
  3444 30EB 18 69 0A			add #$0A
  3445 30EE 8D B6 36			sta ENERGY
  3446
  3447 				; optimize OK (hoppe.pas), line = 333
  3448
  3449 30F1 A0 01			ldy #1
  3450 30F3 AD B6 36			lda ENERGY
  3451 30F6 C9 50			cmp #$50
  3452 30F8 F0 02			seq
  3453 30FA B0 01			bcs @+
  3454 30FC 88				dey
  3455 30FD			@
  3456 					.ifdef IFTMP_47
  3457 					sty IFTMP_47
  3458 					eif
  3459 30FD 98				tya
  3460 30FE D0 03			bne *+5
  3461 3100 4C 10 31			jmp l_0829
  3462
  3463 				; optimize OK (hoppe.pas), line = 334
  3464
  3465 3103 A9 50 8D B6 36		mva #$50 ENERGY
  3466
  3467 				; ---------------------  ASM Block 059  ---------------------
  3468
  3469
  3470 3108 A9 FA		                      lda #250
  3471 310A 8D A1 36		                      sta count
  3472 310D 20 7B 25		                      jsr addScore
  3473 				                    
  3474
  3475 				; IfThenEpilog
  3476 3110			l_0829
  3477
  3478 				; optimize FAIL ('SHOWENERGY', hoppe.pas), line = 341
  3479 3110 20 69 2D			jsr SHOWENERGY
  3480
  3481 				; IfThenEpilog
  3482 3113			l_07FC
  3483
  3484 				; optimize OK (hoppe.pas), line = 345
  3485
  3486 3113 A9 FF 8D 1E D0		mva #$FF B_PMG.PMG_HITCLR
  3487
  3488 				; optimize OK (hoppe.pas), line = 346
  3489
  3490 3118 A9 00 85 4D			mva #$00 ATARI.ATRACT
  3491
  3492 				; optimize OK (hoppe.pas), line = 349
  3493
  3494 311C A9 FC			lda #$FC
  3495 311E 18 6D 94 36			add Y
  3496 3122 85 86			sta :edx
  3497 3124 A9 73			lda #$73
  3498 3126 69 00			adc #$00
  3499 3128 85 87			sta :edx+1
  3500 312A A9 26			lda #$26
  3501 312C 85 8A			sta :ecx
  3502 312E A9 00			lda #$00
  3503 3130 85 8B			sta :ecx+1
  3504 3132 85 82			sta :eax
  3505 3134 20 EC 35			jsr @fill
  3506
  3507 				; optimize OK (hoppe.pas), line = 350
  3508
  3509 3137 AD 93 36			lda FRAME
  3510 313A 0A				asl @
  3511 313B A8				tay
  3512 313C B9 BC 21			lda adr.P0FRAMES,y
  3513 313F 85 86			sta :edx
  3514 3141 B9 BD 21			lda adr.P0FRAMES+1,y
  3515 3144 85 87			sta :edx+1
  3516 3146 AD 94 36			lda Y
  3517 3149 85 8A			sta :ecx
  3518 314B A9 74			lda #$74
  3519 314D 85 8B			sta :ecx+1
  3520 314F A9 1D			lda #$1D
  3521 3151 85 82			sta :eax
  3522 3153 A9 00			lda #$00
  3523 3155 85 83			sta :eax+1
  3524 3157 20 97 35			jsr @move
  3525
  3526 				; optimize OK (hoppe.pas), line = 352
  3527
  3528 315A A9 FC			lda #$FC
  3529 315C 18 6D 94 36			add Y
  3530 3160 85 86			sta :edx
  3531 3162 A9 74			lda #$74
  3532 3164 69 00			adc #$00
  3533 3166 85 87			sta :edx+1
  3534 3168 A9 26			lda #$26
  3535 316A 85 8A			sta :ecx
  3536 316C A9 00			lda #$00
  3537 316E 85 8B			sta :ecx+1
  3538 3170 85 82			sta :eax
  3539 3172 20 EC 35			jsr @fill
  3540
  3541 				; optimize OK (hoppe.pas), line = 353
  3542
  3543 3175 AD 93 36			lda FRAME
  3544 3178 0A				asl @
  3545 3179 A8				tay
  3546 317A B9 C8 21			lda adr.P1FRAMES,y
  3547 317D 85 86			sta :edx
  3548 317F B9 C9 21			lda adr.P1FRAMES+1,y
  3549 3182 85 87			sta :edx+1
  3550 3184 AD 94 36			lda Y
  3551 3187 85 8A			sta :ecx
  3552 3189 A9 75			lda #$75
  3553 318B 85 8B			sta :ecx+1
  3554 318D A9 1D			lda #$1D
  3555 318F 85 82			sta :eax
  3556 3191 A9 00			lda #$00
  3557 3193 85 83			sta :eax+1
  3558 3195 20 97 35			jsr @move
  3559
  3560 				; optimize FAIL ('MOVEPLANES', hoppe.pas), line = 356
  3561 3198 20 31 2B			jsr MOVEPLANES
  3562
  3563 				; optimize OK (hoppe.pas), line = 358
  3564
  3565 319B AD 99 36			lda FLY
  3566 319E D0 04			bne @+
  3567 31A0 A9 01			lda #true
  3568 31A2 D0 02			sne
  3569 31A4 A9 00		@	lda #false
  3570 					.ifdef IFTMP_48
  3571 					sta IFTMP_48
  3572 					eif
  3573 31A6 D0 03			bne *+5
  3574 31A8 4C 31 32			jmp l_089B
  3575
  3576 				; optimize OK (hoppe.pas), line = 360
  3577
  3578 31AB A0 01			ldy #1
  3579 31AD AD 84 02			lda JOYSTICK.STRIG0
  3580 31B0 F0 01			beq @+
  3581 31B2 88				dey
  3582 31B3			@
  3583 					.ifdef IFTMP_49
  3584 					sty IFTMP_49
  3585 					eif
  3586 31B3 98				tya
  3587 31B4 D0 03			bne *+5
  3588 31B6 4C F2 31			jmp l_08AE
  3589
  3590 				; optimize OK (hoppe.pas), line = 361
  3591
  3592 31B9 AD 9A 36			lda JUMP
  3593 31BC D0 04			bne @+
  3594 31BE A9 01			lda #true
  3595 31C0 D0 02			sne
  3596 31C2 A9 00		@	lda #false
  3597 					.ifdef IFTMP_50
  3598 					sta IFTMP_50
  3599 					eif
  3600 31C4 D0 03			bne *+5
  3601 31C6 4C D3 31			jmp l_08BE
  3602
  3603 				; optimize OK (hoppe.pas), line = 362
  3604
  3605 31C9 A9 01 8D 9A 36		mva #$01 JUMP
  3606
  3607 				; optimize OK (hoppe.pas), line = 363
  3608
  3609 31CE A9 0A 8D 9D 36		mva #$0A JUMPFORCE
  3610
  3611 				; IfThenEpilog
  3612 31D3			l_08BE
  3613
  3614 				; optimize OK (hoppe.pas), line = 366
  3615
  3616 31D3 A0 01			ldy #1
  3617 31D5 AD 9D 36			lda JUMPFORCE
  3618 31D8 C9 46			cmp #$46
  3619 31DA 90 01			bcc @+
  3620 31DC 88				dey
  3621 31DD			@
  3622 31DD 84 A2			sty :STACKORIGIN+10
  3623 31DF AD 9A 36			lda JUMP
  3624 31E2 25 A2			and :STACKORIGIN+10
  3625 					.ifdef IFTMP_51
  3626 					sta IFTMP_51
  3627 					eif
  3628 31E4 D0 03			bne *+5
  3629 31E6 4C F2 31			jmp l_08E1
  3630
  3631 				; optimize OK (hoppe.pas), line = 366
  3632
  3633 31E9 AD 9D 36			lda JUMPFORCE
  3634 31EC 18 69 03			add #$03
  3635 31EF 8D 9D 36			sta JUMPFORCE
  3636
  3637 				; IfThenEpilog
  3638 31F2			l_08E1
  3639
  3640 				; IfThenEpilog
  3641 31F2			l_08AE
  3642
  3643 				; optimize OK (hoppe.pas), line = 370
  3644
  3645 31F2 A0 01			ldy #1
  3646 31F4 AD 84 02			lda JOYSTICK.STRIG0
  3647 31F7 C9 01			cmp #$01
  3648 31F9 F0 01			beq @+
  3649 31FB 88				dey
  3650 31FC			@
  3651 31FC 84 A2			sty :STACKORIGIN+10
  3652 31FE AD 9A 36			lda JUMP
  3653 3201 25 A2			and :STACKORIGIN+10
  3654 					.ifdef IFTMP_52
  3655 					sta IFTMP_52
  3656 					eif
  3657 3203 D0 03			bne *+5
  3658 3205 4C 31 32			jmp l_08FF
  3659
  3660 				; optimize OK (hoppe.pas), line = 371
  3661
  3662 3208 A9 01 8D 9C 36		mva #$01 COUNTSCORE
  3663
  3664 				; optimize OK (hoppe.pas), line = 372
  3665
  3666 320D A9 00 8D 9A 36		mva #$00 JUMP
  3667
  3668 				; optimize OK (hoppe.pas), line = 373
  3669
  3670 3212 A9 01 8D 99 36		mva #$01 FLY
  3671
  3672 				; optimize OK (hoppe.pas), line = 374
  3673
  3674 3217 A9 00			lda #$00
  3675 3219 38 ED 9D 36			sub JUMPFORCE
  3676 321D 85 A1			sta :STACKORIGIN+9
  3677 321F A0 00			ldy #$00
  3678 3221 A5 A1			lda :STACKORIGIN+9
  3679 3223 10 01			spl
  3680 3225 88				dey
  3681 3226 8C 96 36			sty SY+1
  3682 3229 8D 95 36			sta SY
  3683
  3684 				; optimize OK (hoppe.pas), line = 375
  3685
  3686 322C A9 AA 8D B9 36		mva #$AA FXVOL
  3687
  3688 				; IfThenEpilog
  3689 3231			l_08FF
  3690
  3691 				; IfThenEpilog
  3692 3231			l_089B
  3693
  3694 				; optimize OK (hoppe.pas), line = 380
  3695
  3696 3231 AD 99 36			lda FLY
  3697 3234 2D 9C 36			and COUNTSCORE
  3698 					.ifdef IFTMP_53
  3699 					sta IFTMP_53
  3700 					eif
  3701 3237 D0 03			bne *+5
  3702 3239 4C 59 32			jmp l_092F
  3703
  3704 				; ---------------------  ASM Block 060  ---------------------
  3705
  3706
  3707 323C A9 01		                  lda #1
  3708 323E 8D A1 36		                  sta count
  3709 3241 20 7B 25		                  jsr addScore
  3710 				                
  3711
  3712 				; optimize OK (hoppe.pas), line = 386
  3713
  3714 3244 A9 AE			lda <SCORE
  3715 3246 18 69 01			add #$01
  3716 3249 A8				tay
  3717 324A A9 36			lda >SCORE
  3718 324C 69 00			adc #$00
  3719 324E 85 8F			sta :bp+1
  3720 3250 B1 8E			lda (:bp),y
  3721 3252 4A				lsr @
  3722 3253 4A				lsr @
  3723 3254 4A				lsr @
  3724 3255 4A				lsr @
  3725 3256 8D B8 36			sta DIFFICULTY
  3726
  3727 				; IfThenEpilog
  3728 3259			l_092F
  3729
  3730 				; optimize OK (hoppe.pas), line = 391
  3731
  3732 3259 A0 01			ldy #1
  3733 325B				.LOCAL
  3734 325B AD 96 36			lda SY+1
  3735 325E B8 38			clv:sec
  3736 3260 D0 11			bne L4
  3737 3262 AD 95 36			lda SY
  3738 3265 F0 12		L1	beq L5
  3739 3267 B0 05			bcs L3
  3740 3269 A9 FF			lda #$FF
  3741 326B 4C 79 32			jmp L5
  3742 326E A9 01		L3	lda #$01
  3743 3270 4C 79 32			jmp L5
  3744 3273 50 04		L4	bvc L5
  3745 3275 49 FF			eor #$FF
  3746 3277 09 01			ora #$01
  3747 3279			L5
  3748 					.ENDL
  3749 3279 F0 02			seq
  3750 327B 10 01			bpl @+
  3751 327D 88				dey
  3752 327E			@
  3753 					.ifdef IFTMP_54
  3754 					sty IFTMP_54
  3755 					eif
  3756 327E 98				tya
  3757 327F D0 03			bne *+5
  3758 3281 4C D9 32			jmp l_0950
  3759
  3760 				; optimize OK (hoppe.pas), line = 392
  3761
  3762 3284 AD 97 36			lda CY
  3763 3287 18 6D 95 36			add SY
  3764 328B 8D 97 36			sta CY
  3765
  3766 				; optimize OK (hoppe.pas), line = 393
  3767
  3768 328E AD 97 36			lda CY
  3769 3291 4A				lsr @
  3770 3292 4A				lsr @
  3771 3293 4A				lsr @
  3772 3294 4A				lsr @
  3773 3295 4A				lsr @
  3774 3296 18 6D 94 36			add Y
  3775 329A 8D 94 36			sta Y
  3776
  3777 				; optimize OK (hoppe.pas), line = 394
  3778
  3779 329D A0 01			ldy #1
  3780 329F AD 94 36			lda Y
  3781 32A2 CD 98 36			cmp BOTTOM
  3782 32A5 B0 01			bcs @+
  3783 32A7 88				dey
  3784 32A8			@
  3785 					.ifdef IFTMP_55
  3786 					sty IFTMP_55
  3787 					eif
  3788 32A8 98				tya
  3789 32A9 D0 03			bne *+5
  3790 32AB 4C D9 32			jmp l_0980
  3791
  3792 				; optimize OK (hoppe.pas), line = 395
  3793
  3794 32AE A9 00 8D 95 36		mva #$00 SY
  3795 32B3 8D 96 36			sta SY+1
  3796
  3797 				; optimize OK (hoppe.pas), line = 396
  3798
  3799 32B6 8D 97 36			sta CY
  3800
  3801 				; optimize OK (hoppe.pas), line = 397
  3802
  3803 32B9 8D 99 36			sta FLY
  3804
  3805 				; optimize OK (hoppe.pas), line = 398
  3806
  3807 32BC AD 98 36 8D 94 36		mva BOTTOM Y
  3808
  3809 				; optimize OK (hoppe.pas), line = 399
  3810
  3811 32C2 A0 01			ldy #1
  3812 32C4 AD 98 36			lda BOTTOM
  3813 32C7 C9 B2			cmp #$B2
  3814 32C9 F0 02			seq
  3815 32CB B0 01			bcs @+
  3816 32CD 88				dey
  3817 32CE			@
  3818 					.ifdef IFTMP_56
  3819 					sty IFTMP_56
  3820 					eif
  3821 32CE 98				tya
  3822 32CF D0 03			bne *+5
  3823 32D1 4C D9 32			jmp l_09A5
  3824
  3825 				; optimize OK (hoppe.pas), line = 399
  3826
  3827 32D4 A9 01 8D 9B 36		mva #$01 GAMEOVER
  3828
  3829 				; IfThenEpilog
  3830 32D9			l_09A5
  3831
  3832 				; IfThenEpilog
  3833 32D9			l_0980
  3834
  3835 				; IfThenEpilog
  3836 32D9			l_0950
  3837
  3838 				; optimize OK (hoppe.pas), line = 403
  3839
  3840 32D9 A0 01			ldy #1
  3841 32DB				.LOCAL
  3842 32DB AD 96 36			lda SY+1
  3843 32DE B8 38			clv:sec
  3844 32E0 D0 11			bne L4
  3845 32E2 AD 95 36			lda SY
  3846 32E5 F0 12		L1	beq L5
  3847 32E7 B0 05			bcs L3
  3848 32E9 A9 FF			lda #$FF
  3849 32EB 4C F9 32			jmp L5
  3850 32EE A9 01		L3	lda #$01
  3851 32F0 4C F9 32			jmp L5
  3852 32F3 50 04		L4	bvc L5
  3853 32F5 49 FF			eor #$FF
  3854 32F7 09 01			ora #$01
  3855 32F9			L5
  3856 					.ENDL
  3857 32F9 30 01			bmi @+
  3858 32FB 88				dey
  3859 32FC			@
  3860 					.ifdef IFTMP_57
  3861 					sty IFTMP_57
  3862 					eif
  3863 32FC 98				tya
  3864 32FD D0 03			bne *+5
  3865 32FF 4C 6D 33			jmp l_09C1
  3866
  3867 				; optimize OK (hoppe.pas), line = 404
  3868
  3869 3302 AD 97 36			lda CY
  3870 3305 38 ED 95 36			sub SY
  3871 3309 8D 97 36			sta CY
  3872
  3873 				; optimize OK (hoppe.pas), line = 405
  3874
  3875 330C AD 97 36			lda CY
  3876 330F 4A				lsr @
  3877 3310 4A				lsr @
  3878 3311 4A				lsr @
  3879 3312 4A				lsr @
  3880 3313 4A				lsr @
  3881 3314 85 A2			sta :STACKORIGIN+10
  3882 3316 AD 94 36			lda Y
  3883 3319 38 E5 A2			sub :STACKORIGIN+10
  3884 331C 8D 94 36			sta Y
  3885
  3886 				; optimize OK (hoppe.pas), line = 406
  3887
  3888 331F A0 01			ldy #1
  3889 3321				.LOCAL
  3890 3321 AD 96 36			lda SY+1
  3891 3324 B8 38			clv:sec
  3892 3326 D0 11			bne L4
  3893 3328 AD 95 36			lda SY
  3894 332B F0 12		L1	beq L5
  3895 332D B0 05			bcs L3
  3896 332F A9 FF			lda #$FF
  3897 3331 4C 3F 33			jmp L5
  3898 3334 A9 01		L3	lda #$01
  3899 3336 4C 3F 33			jmp L5
  3900 3339 50 04		L4	bvc L5
  3901 333B 49 FF			eor #$FF
  3902 333D 09 01			ora #$01
  3903 333F			L5
  3904 					.ENDL
  3905 333F F0 01			beq @+
  3906 3341 88				dey
  3907 3342			@
  3908 					.ifdef IFTMP_58
  3909 					sty IFTMP_58
  3910 					eif
  3911 3342 98				tya
  3912 3343 D0 03			bne *+5
  3913 3345 4C 52 33			jmp l_09EE
  3914
  3915 				; optimize OK (hoppe.pas), line = 406
  3916
  3917 3348 A9 01 8D 95 36		mva #$01 SY
  3918 334D A9 00 8D 96 36		mva #$00 SY+1
  3919
  3920 				; IfThenEpilog
  3921 3352			l_09EE
  3922
  3923 				; optimize OK (hoppe.pas), line = 407
  3924
  3925 3352 A0 01			ldy #1
  3926 3354 AD BA 36			lda FXFREQ
  3927 3357 C9 10			cmp #$10
  3928 3359 F0 02			seq
  3929 335B B0 01			bcs @+
  3930 335D 88				dey
  3931 335E			@
  3932 					.ifdef IFTMP_59
  3933 					sty IFTMP_59
  3934 					eif
  3935 335E 98				tya
  3936 335F D0 03			bne *+5
  3937 3361 4C 6D 33			jmp l_0A07
  3938
  3939 				; optimize OK (hoppe.pas), line = 407
  3940
  3941 3364 AD 94 36			lda Y
  3942 3367 18 69 28			add #$28
  3943 336A 8D BA 36			sta FXFREQ
  3944
  3945 				; IfThenEpilog
  3946 336D			l_0A07
  3947
  3948 				; IfThenEpilog
  3949 336D			l_09C1
  3950
  3951 				; optimize OK (hoppe.pas), line = 410
  3952
  3953 336D AD 99 36			lda FLY
  3954 3370 D0 04			bne @+
  3955 3372 A9 01			lda #true
  3956 3374 D0 02			sne
  3957 3376 A9 00		@	lda #false
  3958 3378 85 A1			sta :STACKORIGIN+9
  3959 337A A0 01			ldy #1
  3960 337C AD 94 36			lda Y
  3961 337F C9 B2			cmp #$B2
  3962 3381 F0 01			beq @+
  3963 3383 88				dey
  3964 3384			@
  3965 3384 98				tya
  3966 3385 25 A1			and :STACKORIGIN+9
  3967 3387 85 A1			sta :STACKORIGIN+9
  3968 3389 A0 01			ldy #1
  3969 338B AD BB 36			lda DAMAGECOUNT
  3970 338E F0 01			beq @+
  3971 3390 88				dey
  3972 3391			@
  3973 3391 98				tya
  3974 3392 25 A1			and :STACKORIGIN+9
  3975 					.ifdef IFTMP_60
  3976 					sta IFTMP_60
  3977 					eif
  3978 3394 D0 03			bne *+5
  3979 3396 4C AF 33			jmp l_0A3D
  3980
  3981 				; optimize OK (hoppe.pas), line = 411
  3982
  3983 3399 A5 14			lda $0014
  3984 339B 29 04			and #$04
  3985 339D 09 80			ora #$80
  3986 339F 8D B9 36			sta FXVOL
  3987
  3988 				; optimize OK (hoppe.pas), line = 412
  3989
  3990 33A2 AD 93 36			lda FRAME
  3991 33A5 0A 0A 0A 0A			:4 asl @
  3992 33A9 18 69 78			add #$78
  3993 33AC 8D BA 36			sta FXFREQ
  3994
  3995 				; IfThenEpilog
  3996 33AF			l_0A3D
  3997
  3998 				; optimize OK (hoppe.pas), line = 415
  3999
  4000 33AF AD 97 36			lda CY
  4001 33B2 29 1F			and #$1F
  4002 33B4 8D 97 36			sta CY
  4003
  4004 				; optimize FAIL (0, hoppe.pas), line = 416
  4005 33B7 EE 95 36 D0 03 EE + 	inw SY
  4006
  4007 				; optimize OK (hoppe.pas), line = 419
  4008
  4009 33BF AD BA 36			lda FXFREQ
  4010 33C2 8D 06 D2			sta $D206
  4011
  4012 				; optimize OK (hoppe.pas), line = 420
  4013
  4014 33C5 AD B9 36			lda FXVOL
  4015 33C8 8D 07 D2			sta $D207
  4016
  4017 				; optimize OK (hoppe.pas), line = 421
  4018
  4019 33CB AD B9 36			lda FXVOL
  4020 33CE A0 01			ldy #1
  4021 33D0 29 0F			and #$0F
  4022 33D2 D0 01			bne @+
  4023 33D4 88				dey
  4024 33D5			@
  4025 33D5 84 A1			sty :STACKORIGIN+9
  4026 33D7 A5 14			lda $0014
  4027 33D9 A0 01			ldy #1
  4028 33DB 29 02			and #$02
  4029 33DD D0 01			bne @+
  4030 33DF 88				dey
  4031 33E0			@
  4032 33E0 98				tya
  4033 33E1 25 A1			and :STACKORIGIN+9
  4034 					.ifdef IFTMP_61
  4035 					sta IFTMP_61
  4036 					eif
  4037 33E3 D0 03			bne *+5
  4038 33E5 4C EB 33			jmp l_0A98
  4039
  4040 				; optimize FAIL (0, hoppe.pas), line = 421
  4041 33E8 CE B9 36			dec FXVOL
  4042
  4043 				; IfThenEpilog
  4044 33EB			l_0A98
  4045
  4046 				; optimize FAIL ('SYSTEM.PAUSE_0067', hoppe.pas), line = 423
  4047 33EB 20 D3 22			jsr SYSTEM.PAUSE_0067
  4048
  4049 				; optimize OK (hoppe.pas), line = 425
  4050
  4051 33EE AD 9B 36			lda GAMEOVER
  4052 33F1 D0 03			bne *+5
  4053 33F3			c_0701
  4054 33F3 4C DC 2F			jmp l_0701
  4055 33F6			b_0701
  4056
  4057 				; optimize OK (hoppe.pas), line = 426
  4058
  4059 33F6 A9 00			lda #$00
  4060 33F8 8D 07 D2			sta $D207
  4061
  4062 				; optimize OK (hoppe.pas), line = 427
  4063
  4064 33FB A9 00			lda #$00
  4065 33FD D0 03			bne *+5
  4066 33FF			c_0678
  4067 33FF 4C 9D 2E			jmp l_0678
  4068 3402			b_0678
  4069
  4070 				; -----------------------------------------------------------
  4071
  4072 = 5A00			DL_MEM	= $5A00
  4073 = 5B00			TXT_RAM	= $5B00
  4074 = 6000			GFX_RAM	= $6000
  4075 = 7000			PMGBASE	= $7000
  4076 = 8400			CHARSET_TILE_ADDRESS	= $8400
  4077 = 8800			STRINGS	= $8800
  4078 = 000A			MIN_JUMP_FORCE	= $000A
  4079 = 0046			MAX_JUMP_FORCE	= $0046
  4080 = 0060			SCREENLINEWIDTH	= $0060
  4081 = 00B2			BOTTOM_LVL	= $00B2
  4082 = 00D0			ROAD_LVL	= $00D0
  4083 = 006C			BONUS_LVL	= $006C
  4084 = 0004			PLANE_1_SPEED	= $0004
  4085 = 000C			PLANE_2_SPEED	= $000C
  4086 = 0030			PLANE_3_SPEED	= $0030
  4087 = 0009			PLANE_1_START	= $0009
  4088 = 0003			PLANE_2_START	= $0003
  4089 = 0000			PLANE_3_START	= $0000
  4090 = 000F			PLANE_4_START	= $000F
  4091 = 0012			PLANE_0_START	= $0012
  4092 = 0046			MAX_WALL_H	= $0046
  4093 = 0098			B_TOP	= $0098
  4094 = 0090			B_BOTTOM	= $0090
  4095 = 0092			B_SHADOW	= $0092
  4096 = 0094			B_BODY	= $0094
  4097 = 0007			DL_OFFSET	= $0007
  4098 = 2000			adr.P0FRAME0	= CODEORIGIN+$0000
  4099 3402			.var P0FRAME0	= adr.P0FRAME0 .word
  4100 = 201D			adr.P0FRAME1	= CODEORIGIN+$001D
  4101 3402			.var P0FRAME1	= adr.P0FRAME1 .word
  4102 = 203A			adr.P0FRAME2	= CODEORIGIN+$003A
  4103 3402			.var P0FRAME2	= adr.P0FRAME2 .word
  4104 = 2057			adr.P0FRAME3	= CODEORIGIN+$0057
  4105 3402			.var P0FRAME3	= adr.P0FRAME3 .word
  4106 = 2074			adr.P0FRAME4	= CODEORIGIN+$0074
  4107 3402			.var P0FRAME4	= adr.P0FRAME4 .word
  4108 = 2091			adr.P0FRAME5	= CODEORIGIN+$0091
  4109 3402			.var P0FRAME5	= adr.P0FRAME5 .word
  4110 = 20AE			adr.P1FRAME0	= CODEORIGIN+$00AE
  4111 3402			.var P1FRAME0	= adr.P1FRAME0 .word
  4112 = 20CB			adr.P1FRAME1	= CODEORIGIN+$00CB
  4113 3402			.var P1FRAME1	= adr.P1FRAME1 .word
  4114 = 20E8			adr.P1FRAME2	= CODEORIGIN+$00E8
  4115 3402			.var P1FRAME2	= adr.P1FRAME2 .word
  4116 = 2105			adr.P1FRAME3	= CODEORIGIN+$0105
  4117 3402			.var P1FRAME3	= adr.P1FRAME3 .word
  4118 = 2122			adr.P1FRAME4	= CODEORIGIN+$0122
  4119 3402			.var P1FRAME4	= adr.P1FRAME4 .word
  4120 = 213F			adr.P1FRAME5	= CODEORIGIN+$013F
  4121 3402			.var P1FRAME5	= adr.P1FRAME5 .word
  4122 = 215C			adr.P0BONUS0	= CODEORIGIN+$015C
  4123 3402			.var P0BONUS0	= adr.P0BONUS0 .word
  4124 = 2168			adr.P0BONUS1	= CODEORIGIN+$0168
  4125 3402			.var P0BONUS1	= adr.P0BONUS1 .word
  4126 = 2174			adr.P0BONUS2	= CODEORIGIN+$0174
  4127 3402			.var P0BONUS2	= adr.P0BONUS2 .word
  4128 = 2180			adr.P0BONUS3	= CODEORIGIN+$0180
  4129 3402			.var P0BONUS3	= adr.P0BONUS3 .word
  4130 = 218C			adr.P1BONUS0	= CODEORIGIN+$018C
  4131 3402			.var P1BONUS0	= adr.P1BONUS0 .word
  4132 = 2198			adr.P1BONUS1	= CODEORIGIN+$0198
  4133 3402			.var P1BONUS1	= adr.P1BONUS1 .word
  4134 = 21A4			adr.P1BONUS2	= CODEORIGIN+$01A4
  4135 3402			.var P1BONUS2	= adr.P1BONUS2 .word
  4136 = 21B0			adr.P1BONUS3	= CODEORIGIN+$01B0
  4137 3402			.var P1BONUS3	= adr.P1BONUS3 .word
  4138 = 21BC			adr.P0FRAMES	= CODEORIGIN+$01BC
  4139 3402			.var P0FRAMES	= adr.P0FRAMES .word
  4140 = 21C8			adr.P1FRAMES	= CODEORIGIN+$01C8
  4141 3402			.var P1FRAMES	= adr.P1FRAMES .word
  4142 = 21D4			adr.B0FRAMES	= CODEORIGIN+$01D4
  4143 3402			.var B0FRAMES	= adr.B0FRAMES .word
  4144 = 21DC			adr.B1FRAMES	= CODEORIGIN+$01DC
  4145 3402			.var B1FRAMES	= adr.B1FRAMES .word
  4146 = 3650			adr.TILE_FENCE	= DATAORIGIN+$001C
  4147 3402			.var TILE_FENCE	= adr.TILE_FENCE .word
  4148 = 3658			adr.CLOUD1	= DATAORIGIN+$0024
  4149 3402			.var CLOUD1	= adr.CLOUD1 .word
  4150 = 3662			adr.CLOUD2	= DATAORIGIN+$002E
  4151 3402			.var CLOUD2	= adr.CLOUD2 .word
  4152 = 366C			adr.BOAT	= DATAORIGIN+$0038
  4153 3402			.var BOAT	= adr.BOAT .word
  4154 = 3674			adr.PLANESSPEEDS	= DATAORIGIN+$0040
  4155 3402			.var PLANESSPEEDS	= adr.PLANESSPEEDS .word
  4156 = 3679			adr.PLANESLENGTHS	= DATAORIGIN+$0045
  4157 3402			.var PLANESLENGTHS	= adr.PLANESLENGTHS .word
  4158 = 367E			adr.PLANESSTARTS	= DATAORIGIN+$004A
  4159 3402			.var PLANESSTARTS	= adr.PLANESSTARTS .word
  4160 = 3683			adr.PLANESX	= DATAORIGIN+$004F
  4161 3402			.var PLANESX	= adr.PLANESX .word
  4162 = 3688			adr.PLANESH	= DATAORIGIN+$0054
  4163 3402			.var PLANESH	= adr.PLANESH .word
  4164 = 368D			adr.PLANESC	= DATAORIGIN+$0059
  4165 3402			.var PLANESC	= adr.PLANESC .word
  4166 = 3692			PLANE	= DATAORIGIN+$005E
  4167 = 3693			FRAME	= DATAORIGIN+$005F
  4168 = 3694			Y	= DATAORIGIN+$0060
  4169 = 3695			SY	= DATAORIGIN+$0061
  4170 = 3697			CY	= DATAORIGIN+$0063
  4171 = 3698			BOTTOM	= DATAORIGIN+$0064
  4172 = 3699			FLY	= DATAORIGIN+$0065
  4173 = 369A			JUMP	= DATAORIGIN+$0066
  4174 = 369B			GAMEOVER	= DATAORIGIN+$0067
  4175 = 369C			COUNTSCORE	= DATAORIGIN+$0068
  4176 = 369D			JUMPFORCE	= DATAORIGIN+$0069
  4177 = 369E			LINE	= DATAORIGIN+$006A
  4178 = 369F			X	= DATAORIGIN+$006B
  4179 = 36A0			B	= DATAORIGIN+$006C
  4180 = 36A1			COUNT	= DATAORIGIN+$006D
  4181 = 36A2			VRAM	= DATAORIGIN+$006E
  4182 = 36A4			adr.WALLPOSX	= DATAORIGIN+$0070
  4183 3402			.var WALLPOSX	= adr.WALLPOSX .word
  4184 = 36A8			adr.WALLWAIT	= DATAORIGIN+$0074
  4185 3402			.var WALLWAIT	= adr.WALLWAIT .word
  4186 = 36AC			BONUSX	= DATAORIGIN+$0078
  4187 = 36AD			BONUSW	= DATAORIGIN+$0079
  4188 = 36AE			SCORE	= DATAORIGIN+$007A
  4189 = 36B2			HISCORE	= DATAORIGIN+$007E
  4190 = 36B6			ENERGY	= DATAORIGIN+$0082
  4191 = 36B7			LASTWALL	= DATAORIGIN+$0083
  4192 = 36B8			DIFFICULTY	= DATAORIGIN+$0084
  4193 = 36B9			FXVOL	= DATAORIGIN+$0085
  4194 = 36BA			FXFREQ	= DATAORIGIN+$0086
  4195 = 36BB			DAMAGECOUNT	= DATAORIGIN+$0087
  4196 = D20A			RND	= $D20A
  4197 = 36CB			IFTMP_41	= DATAORIGIN+$0097
  4198
  4199 3402			@exit
  4200
  4201 3402 A2 00		@halt	ldx #0
  4202 3404 9A				txs
  4203
  4204 3405 60				rts
  4205
  4206 3406 00 00 00 00 00 00 + IOCB@COPY	:16 brk
  4207
  4208 3416			.local	@DEFINES
  4209 3416			ATARI
  4210 				.endl
  4211
  4212 = 3416 00 20		P0FRAME0
  4212 = 3418 1D 20		P0FRAME1
  4212 = 341A 3A 20		P0FRAME2
  4212 = 341C 57 20		P0FRAME3
  4212 = 341E 74 20		P0FRAME4
  4212 = 3420 91 20		P0FRAME5
  4212 = 3422 AE 20		P1FRAME0
  4212 = 3424 CB 20		P1FRAME1
  4212 = 3426 E8 20		P1FRAME2
  4212 = 3428 05 21		P1FRAME3
  4212 = 342A 22 21		P1FRAME4
  4212 = 342C 3F 21		P1FRAME5
  4212 = 342E 5C 21		P0BONUS0
  4212 = 3430 68 21		P0BONUS1
  4212 = 3432 74 21		P0BONUS2
  4212 = 3434 80 21		P0BONUS3
  4212 = 3436 8C 21		P1BONUS0
  4212 = 3438 98 21		P1BONUS1
  4212 = 343A A4 21		P1BONUS2
  4212 = 343C B0 21		P1BONUS3
  4212 = 343E BC 21		P0FRAMES
  4212 = 3440 C8 21		P1FRAMES
  4212 = 3442 D4 21		B0FRAMES
  4212 = 3444 DC 21		B1FRAMES
  4212 = 3446 50 36		TILE_FENCE
  4212 = 3448 58 36		CLOUD1
  4212 = 344A 62 36		CLOUD2
  4212 = 344C 6C 36		BOAT
  4212 = 344E 74 36		PLANESSPEEDS
  4212 = 3450 79 36		PLANESLENGTHS
  4212 = 3452 7E 36		PLANESSTARTS
  4212 = 3454 83 36		PLANESX
  4212 = 3456 88 36		PLANESH
  4212 = 3458 8D 36		PLANESC
  4212 = 345A A4 36		WALLPOSX
  4212 = 345C A8 36		WALLWAIT
  4212 				.endl
  4213
  4214 				; -----------------------------------------------------------
  4215
  4216 345E				icl 'cpu6502.asm'
Source: cpu6502.asm
   290 					opt l+
   227 					opt l+
   228
   229 				/* ----------------------------------------------------------------------- */
   230
   231
   232 345E			.proc	hiBYTE
   233 					lda :STACKORIGIN,x
   234 345E				:4 lsr @
   235 					sta :STACKORIGIN,x
   236 					rts
   237 				.endp
   238
   239 345E			.proc	hiWORD
   240 					lda :STACKORIGIN+STACKWIDTH,x
   241 					sta :STACKORIGIN,x
   242 					rts
   243 				.endp
   244
   245 345E			.proc	hiCARD
   246 					lda :STACKORIGIN+STACKWIDTH*3,x
   247 					sta :STACKORIGIN+STACKWIDTH,x
   248
   249 					lda :STACKORIGIN+STACKWIDTH*2,x
   250 					sta :STACKORIGIN,x
   251 					rts
   252 				.endp
   253
   254
   255 345E			.proc	movaBX_EAX		; mov [BX], EAX
   256 345E A5 82 95 97 A5 83 + 	:MAXSIZE mva eax+# :STACKORIGIN-1+#*STACKWIDTH,x
   257 346E 60				rts
   258 				.endp
   259
   260 				/*
   261 				.proc	@pushBYTE
   262 					adc :STACKORIGIN+STACKWIDTH,x
   263 					sta bp+1
   264
   265 					mva (bp),y :STACKORIGIN,x
   266
   267 				;	lda #$00
   268 				;	sta :STACKORIGIN+STACKWIDTH,x
   269 				;	sta :STACKORIGIN+STACKWIDTH*2,x
   270 				;	sta :STACKORIGIN+STACKWIDTH*3,x
   271
   272 					rts
   273 				.endp
   274
   275
   276 				.proc	@pullWORD (.word ya) .reg
   277 					add :STACKORIGIN-1,x
   278 					sta bp2
   279 					tya
   280 					adc :STACKORIGIN-1+STACKWIDTH,x
   281 					sta bp2+1
   282
   283 					ldy #$00
   284
   285 					mva :STACKORIGIN,x (bp2),y
   286 					iny
   287 					mva :STACKORIGIN+STACKWIDTH,x (bp2),y
   288
   289 					rts
   290 				.endp
   291
   292
   293 				.proc	@pullCARD (.word ya) .reg
   294 					add :STACKORIGIN-1,x
   295 					sta bp2
   296 					tya
   297 					adc :STACKORIGIN-1+STACKWIDTH,x
   298 					sta bp2+1
   299
   300 					ldy #$00
   301
   302 					mva :STACKORIGIN,x (bp2),y
   303 					iny
   304 					mva :STACKORIGIN+STACKWIDTH,x (bp2),y
   305 					iny
   306 					mva :STACKORIGIN+STACKWIDTH*2,x (bp2),y
   307 					iny
   308 					mva :STACKORIGIN+STACKWIDTH*3,x (bp2),y
   309
   310 					rts
   311 				.endp
   312
   313
   314 				.proc	@pushWORD (.word ya) .reg
   315 					add :STACKORIGIN,x
   316 					sta bp2
   317 					tya
   318 					adc :STACKORIGIN+STACKWIDTH,x
   319 					sta bp2+1
   320
   321 					ldy #$00
   322
   323 					mva (bp2),y :STACKORIGIN,x
   324 					iny
   325 					mva (bp2),y :STACKORIGIN+STACKWIDTH,x
   326
   327 					rts
   328 				.endp
   329
   330
   331 				.proc	@pushCARD (.word ya) .reg
   332 					add :STACKORIGIN,x
   333 					sta bp2
   334 					tya
   335 					adc :STACKORIGIN+STACKWIDTH,x
   336 					sta bp2+1
   337
   338 					ldy #$00
   339
   340 					mva (bp2),y :STACKORIGIN,x
   341 					iny
   342 					mva (bp2),y :STACKORIGIN+STACKWIDTH,x
   343 					iny
   344 					mva (bp2),y :STACKORIGIN+STACKWIDTH*2,x
   345 					iny
   346 					mva (bp2),y :STACKORIGIN+STACKWIDTH*3,x
   347
   348 					rts
   349 				.endp
   350 				*/
   350
   351
   352 346F			.proc	shlEAX_CL
   353
   354 				;SHORT	jsr @expandToCARD1.SHORT
   355 				;	jmp CARD
   356
   357 				;SMALL	jsr @expandToCARD1.SMALL
   358 				;	jmp CARD
   359
   360 346F			BYTE	lda #0
   361 					sta :STACKORIGIN-1+STACKWIDTH,x
   362
   363 346F			WORD	lda #0
   364 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   365 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   366
   367 346F			CARD	clc
   368 					ldy :STACKORIGIN,x	; cl
   369 					beq stop
   370 346F			@	asl :STACKORIGIN-1,x	; eax
   371 					rol :STACKORIGIN-1+STACKWIDTH,x
   372 					rol :STACKORIGIN-1+STACKWIDTH*2,x
   373 					rol :STACKORIGIN-1+STACKWIDTH*3,x
   374 					dey
   375 					bne @-
   376
   377 346F			stop	rts
   378 				.endp
   379
   380
   381 346F			.proc	shrAL_CL
   382
   383 				;SHORT	jsr @expandToCARD1.SHORT
   384 				;	jmp shrEAX_CL
   385
   386 346F			BYTE	ldy :STACKORIGIN,x	; cl
   387 					beq stop
   388 346F			@	lsr :STACKORIGIN-1,x
   389 					dey
   390 					bne @-
   391
   392 346F			stop	lda #0
   393 					sta :STACKORIGIN-1+STACKWIDTH,x
   394 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   395 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   396
   397 					rts
   398 				.endp
   399
   400 346F			.proc	shrAX_CL
   401
   402 				;SMALL	jsr @expandToCARD1.SMALL
   403 				;	jmp shrEAX_CL
   404
   405 346F			WORD	ldy :STACKORIGIN,x	; cl
   406 					beq stop
   407 346F			@	lsr :STACKORIGIN-1+STACKWIDTH,x
   408 					ror :STACKORIGIN-1,x
   409 					dey
   410 					bne @-
   411
   412 346F			stop	lda #0
   413 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   414 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   415
   416 					rts
   417 				.endp
   418
   419 346F			.proc	shrEAX_CL
   420
   421 					ldy :STACKORIGIN,x	; cl
   422 					beq stop
   423 346F			@	lsr :STACKORIGIN-1+STACKWIDTH*3,x
   424 					ror :STACKORIGIN-1+STACKWIDTH*2,x
   425 					ror :STACKORIGIN-1+STACKWIDTH,x
   426 					ror :STACKORIGIN-1,x
   427 					dey
   428 					bne @-
   429
   430 346F			stop	rts
   431 				.endp
   432
   433 				; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   434 				; wynik operacji ADD zostanie potraktowany jako INTEGER / CARDINAL
   435 				; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   436
   437 346F			.proc	addAL_CL
   438
   439 346F A0 00			ldy #0
   440
   441 3471 94 B7			sty :STACKORIGIN-1+STACKWIDTH*2,x
   442 3473 94 C7			sty :STACKORIGIN-1+STACKWIDTH*3,x
   443
   444 3475 B5 97			lda :STACKORIGIN-1,x
   445 3477 18 75 98			add :STACKORIGIN,x
   446 347A 95 97			sta :STACKORIGIN-1,x
   447 347C 90 01			scc
   448 347E C8				iny
   449
   450 347F 94 A7			sty :STACKORIGIN-1+STACKWIDTH,x
   451
   452 3481 60				rts
   453 				.endp
   454
   455 3482			.proc	addAX_CX
   456
   457 3482 A0 00			ldy #0
   458
   459 3484 94 C7			sty :STACKORIGIN-1+STACKWIDTH*3,x
   460
   461 3486 B5 97			lda :STACKORIGIN-1,x
   462 3488 18 75 98			add :STACKORIGIN,x
   463 348B 95 97			sta :STACKORIGIN-1,x
   464
   465 348D B5 A7			lda :STACKORIGIN-1+STACKWIDTH,x
   466 348F 75 A8			adc :STACKORIGIN+STACKWIDTH,x
   467 3491 95 A7			sta :STACKORIGIN-1+STACKWIDTH,x
   468 3493 90 01			scc
   469 3495 C8				iny
   470
   471 3496 94 B7			sty :STACKORIGIN-1+STACKWIDTH*2,x
   472
   473 3498 60				rts
   474 				.endp
   475
   476
   477 3499			.proc	addEAX_ECX
   478 				/*
   479 				SHORT	jsr @expandToCARD.SHORT
   480 					jsr @expandToCARD1.SHORT
   481 					jmp CARD
   482
   483 				SMALL	jsr @expandToCARD.SMALL
   484 					jsr @expandToCARD1.SMALL
   485 				*/
   485
   486 3499 B5 97		CARD	lda :STACKORIGIN-1,x
   487 349B 18 75 98			add :STACKORIGIN,x
   488 349E 95 97			sta :STACKORIGIN-1,x
   489
   490 34A0 B5 A7			lda :STACKORIGIN-1+STACKWIDTH,x
   491 34A2 75 A8			adc :STACKORIGIN+STACKWIDTH,x
   492 34A4 95 A7			sta :STACKORIGIN-1+STACKWIDTH,x
   493
   494 34A6 B5 B7			lda :STACKORIGIN-1+STACKWIDTH*2,x
   495 34A8 75 B8			adc :STACKORIGIN+STACKWIDTH*2,x
   496 34AA 95 B7			sta :STACKORIGIN-1+STACKWIDTH*2,x
   497
   498 34AC B5 C7			lda :STACKORIGIN-1+STACKWIDTH*3,x
   499 34AE 75 C8			adc :STACKORIGIN+STACKWIDTH*3,x
   500 34B0 95 C7			sta :STACKORIGIN-1+STACKWIDTH*3,x
   501
   502 34B2 60				rts
   503 				.endp
   504
   505
   506 34B3			.proc	subAL_CL
   507
   508 					ldy #0
   509
   510 					lda :STACKORIGIN-1,x
   511 					sub :STACKORIGIN,x
   512 					sta :STACKORIGIN-1,x
   513 					scs
   514 					dey
   515
   516 					sty :STACKORIGIN-1+STACKWIDTH,x
   517 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   518 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   519
   520 					rts
   521 				.endp
   522
   523 34B3			.proc	subAX_CX
   524
   525 					ldy #0
   526
   527 					lda :STACKORIGIN-1,x		; ax
   528 					sub :STACKORIGIN,x		; cx
   529 					sta :STACKORIGIN-1,x
   530
   531 					lda :STACKORIGIN-1+STACKWIDTH,x
   532 					sbc :STACKORIGIN+STACKWIDTH,x
   533 					sta :STACKORIGIN-1+STACKWIDTH,x
   534 					scs
   535 					dey
   536
   537 					sty :STACKORIGIN-1+STACKWIDTH*2,x
   538 					sty :STACKORIGIN-1+STACKWIDTH*3,x
   539
   540 					rts
   541 				.endp
   542
   543 34B3			.proc	subEAX_ECX
   544
   545 					lda :STACKORIGIN-1,x
   546 					sub :STACKORIGIN,x
   547 					sta :STACKORIGIN-1,x
   548
   549 					lda :STACKORIGIN-1+STACKWIDTH,x
   550 					sbc :STACKORIGIN+STACKWIDTH,x
   551 					sta :STACKORIGIN-1+STACKWIDTH,x
   552
   553 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   554 					sbc :STACKORIGIN+STACKWIDTH*2,x
   555 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   556
   557 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   558 					sbc :STACKORIGIN+STACKWIDTH*3,x
   559 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   560
   561 					rts
   562 				.endp
   563
   564
   565 34B3			.proc	@expandSHORT2SMALL
   566 					ldy #$00
   567 					lda :STACKORIGIN,x
   568 					spl
   569 					dey
   570 					sty :STACKORIGIN+STACKWIDTH,x
   571
   572 					rts
   573 				.endp
   574
   575 34B3			.proc	@expandSHORT2SMALL1
   576 					ldy #$00
   577 					lda :STACKORIGIN-1,x
   578 					spl
   579 					dey
   580 					sty :STACKORIGIN-1+STACKWIDTH,x
   581
   582 					rts
   583 				.endp
   584
   585
   586 34B3			.proc	@expandToCARD
   587
   588 34B3			SMALL	lda :STACKORIGIN+STACKWIDTH,x
   589 					bpl WORD
   590
   591 					lda #$ff
   592 					bne _wo
   593
   594 34B3			WORD	lda #$00
   595 					beq _wo
   596
   597 34B3			SHORT	lda :STACKORIGIN,x
   598 					bpl BYTE
   599
   600 					lda #$ff
   601 					bne _by
   602
   603 34B3			BYTE	lda #$00
   604
   605 34B3			_by	sta :STACKORIGIN+STACKWIDTH,x
   606 34B3			_wo	sta :STACKORIGIN+STACKWIDTH*2,x
   607 34B3			_lo	sta :STACKORIGIN+STACKWIDTH*3,x
   608 					rts
   609 				.endp
   610
   611
   612 34B3			.proc	@expandToCARD1
   613
   614 34B3			SMALL	lda :STACKORIGIN-1+STACKWIDTH,x
   615 					bpl WORD
   616
   617 					lda #$ff
   618 					bne _wo
   619
   620 34B3			WORD	lda #$00
   621 					beq _wo
   622
   623 34B3			SHORT	lda :STACKORIGIN-1,x
   624 					bpl BYTE
   625
   626 					lda #$ff
   627 					bne _by
   628
   629 34B3			BYTE	lda #$00
   630
   631 34B3			_by	sta :STACKORIGIN-1+STACKWIDTH,x
   632 34B3			_wo	sta :STACKORIGIN-1+STACKWIDTH*2,x
   633 34B3			_lo	sta :STACKORIGIN-1+STACKWIDTH*3,x
   634 					rts
   635 				.endp
   636
   637 				/*
   638 				.proc	@cmpFor_WORD (.word ya) .reg
   639 					sta ztmp
   640 					sty ztmp+1
   641
   642 					ldy #1
   643 					lda (ztmp),y
   644 					cmp :STACKORIGIN+1+STACKWIDTH,x
   645 					bne stop
   646 					dey
   647 					lda (ztmp),y
   648 					cmp :STACKORIGIN+1,x
   649 				stop	rts
   650 				.endp
   651
   652
   653 				.proc	@cmpFor_CARD (.word ya) .reg
   654 					sta ztmp
   655 					sty ztmp+1
   656
   657 					ldy #3
   658 					lda (ztmp),y
   659 					cmp :STACKORIGIN+1+STACKWIDTH*3,x
   660 					bne stop
   661 					dey
   662 					lda (ztmp),y
   663 					cmp :STACKORIGIN+1+STACKWIDTH*2,x
   664 					bne stop
   665 					dey
   666 					lda (ztmp),y
   667 					cmp :STACKORIGIN+1+STACKWIDTH,x
   668 					bne stop
   669 					dey
   670 					lda (ztmp),y
   671 					cmp :STACKORIGIN+1,x
   672
   673 				stop	rts
   674 				.endp
   675
   676
   677 				.proc	@cmpFor_SHORTINT(.word ya) .reg
   678 					sta ztmp
   679 					sty ztmp+1
   680
   681 					ldy	#0
   682 					lda	(ztmp),y
   683 					sec
   684 					sbc	:STACKORIGIN+1,x
   685 					bne	@cmpFor_INT.L4
   686
   687 					jmp	@cmpFor_INT.L1
   688 				.endp
   689
   690
   691 				.proc	@cmpFor_SMALLINT(.word ya) .reg
   692 					sta ztmp
   693 					sty ztmp+1
   694
   695 					ldy	#1
   696 					lda	(ztmp),y
   697 					sec
   698 					sbc	:STACKORIGIN+1+STACKWIDTH,x
   699 					bne	@cmpFor_INT.L4
   700
   701 					dey
   702 					lda	(ztmp),y
   703 					cmp	:STACKORIGIN+1,x
   704
   705 					jmp	@cmpFor_INT.L1
   706 				.endp
   707
   708
   709 				.proc	@cmpFor_INT(.word ya) .reg
   710 					sta ztmp
   711 					sty ztmp+1
   712
   713 					ldy	#3
   714 					lda	(ztmp),y
   715 					sec
   716 					sbc	:STACKORIGIN+1+STACKWIDTH*3,x
   717 					bne	L4
   718
   719 					dey
   720 					lda	(ztmp),y
   721 					cmp	:STACKORIGIN+1+STACKWIDTH*2,x
   722 					bne	L1
   723
   724 					dey
   725 					lda	(ztmp),y
   726 					cmp	:STACKORIGIN+1+STACKWIDTH,x
   727 					bne	L1
   728
   729 					dey
   730 					lda	(ztmp),y
   731 					cmp	:STACKORIGIN+1,x
   732
   733 				L1	beq	L2
   734 					bcs	L3
   735
   736 					lda	#$FF	; Set the N flag
   737 				L2	rts
   738
   739 				L3	lda	#$01	; Clear the N flag
   740 					rts
   741
   742 				L4	bvc	L5
   743 					eor	#$FF	; Fix the N flag if overflow
   744 					ora	#$01	; Clear the Z flag
   745 				L5	rts
   746 				.endp
   747 				*/
   747
   748
   749 				; Piotr Fusik, 15.04.2002
   750 				; originally by Ullrich von Bassewitz
   751
   752 34B3			.proc	cmpSHORTINT
   753 					lda	:STACKORIGIN-1,x
   754 					clv:sec
   755 					sbc	:STACKORIGIN,x
   756 					bne	cmpINT.L4
   757
   758 					jmp	cmpINT.L1
   759 				.endp
   760
   761
   762 34B3			.proc	cmpSMALLINT
   763 					lda	:STACKORIGIN-1+STACKWIDTH,x
   764 					clv:sec
   765 					sbc	:STACKORIGIN+STACKWIDTH,x
   766 					bne	cmpINT.L4
   767
   768 					lda	:STACKORIGIN-1,x
   769 					cmp	:STACKORIGIN,x
   770
   771 					jmp	cmpINT.L1
   772 				.endp
   773
   774
   775 34B3			.proc	cmpINT
   776 					lda	:STACKORIGIN-1+STACKWIDTH*3,x
   777 					clv:sec
   778 					sbc	:STACKORIGIN+STACKWIDTH*3,x
   779 					bne	L4
   780
   781 					lda	:STACKORIGIN-1+STACKWIDTH*2,x
   782 					cmp	:STACKORIGIN+STACKWIDTH*2,x
   783 					bne	L1
   784
   785 					lda	:STACKORIGIN-1+STACKWIDTH,x
   786 					cmp	:STACKORIGIN+STACKWIDTH,x
   787 					bne	L1
   788
   789 					lda	:STACKORIGIN-1,x
   790 					cmp	:STACKORIGIN,x
   791
   792 34B3			L1	beq	L2
   793 					bcs	L3
   794
   795 					lda	#$FF	; Set the N flag
   796 34B3			L2	rts
   797
   798 34B3			L3	lda	#$01	; Clear the N flag
   799 					rts
   800
   801 34B3			L4	bvc	L5
   802 					eor	#$FF	; Fix the N flag if overflow
   803 					ora	#$01	; Clear the Z flag
   804 34B3			L5	rts
   805 				.endp
   806
   807
   808 34B3			.proc	cmpEAX_ECX
   809 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   810 					cmp :STACKORIGIN+STACKWIDTH*3,x
   811 					bne _done
   812 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   813 					cmp :STACKORIGIN+STACKWIDTH*2,x
   814 					bne _done
   815 34B3			AX_CX
   816 					lda :STACKORIGIN-1+STACKWIDTH,x
   817 					cmp :STACKORIGIN+STACKWIDTH,x
   818 					bne _done
   819 					lda :STACKORIGIN-1,x
   820 					cmp :STACKORIGIN,x
   821
   822 34B3			_done	rts
   823 				.endp
   824
   825
   826 34B3			.proc	cmpSTRING2CHAR
   827
   828 					lda :STACKORIGIN-1,x
   829 					sta ztmp8
   830 					lda :STACKORIGIN-1+STACKWIDTH,x
   831 					sta ztmp8+1
   832
   833 					lda :STACKORIGIN,x
   834 					sta ztmp10
   835
   836 					ldy #0
   837
   838 					lda (ztmp8),y		; if length <> 1
   839 					cmp #1
   840 					bne fail
   841
   842 					iny
   843
   844 34B3			loop	lda (ztmp8),y
   845 					cmp ztmp10
   846 					bne fail
   847
   848 					lda #0
   849 					seq
   850
   851 34B3			fail	lda #$ff
   852
   853 					ldy #1
   854
   855 					cmp #0
   856 					rts
   857 				.endp
   858
   859
   860
   861 34B3			.proc	cmpCHAR2STRING
   862
   863 					lda :STACKORIGIN-1,x
   864 					sta ztmp8
   865
   866 					lda :STACKORIGIN,x
   867 					sta ztmp10
   868 					lda :STACKORIGIN+STACKWIDTH,x
   869 					sta ztmp10+1
   870
   871 					ldy #0
   872
   873 					lda (ztmp10),y		; if length <> 1
   874 					cmp #1
   875 					bne fail
   876
   877 					iny
   878
   879 34B3			loop	lda (ztmp10),y
   880 					cmp ztmp8
   881 					bne fail
   882
   883 					lda #0
   884 					seq
   885
   886 34B3			fail	lda #$ff
   887
   888 					ldy #1
   889
   890 					cmp #0
   891 					rts
   892 				.endp
   893
   894
   895 34B3			.proc	cmpSTRING
   896
   897 					lda :STACKORIGIN-1,x
   898 					sta ztmp8
   899 					lda :STACKORIGIN-1+STACKWIDTH,x
   900 					sta ztmp8+1
   901
   902 					lda :STACKORIGIN,x
   903 					sta ztmp10
   904 					lda :STACKORIGIN+STACKWIDTH,x
   905 					sta ztmp10+1
   906
   907 					ldy #0
   908
   909 					lda (ztmp8),y		; if length1 = 0
   910 					beq fail
   911 					lda (ztmp10),y		; if length2 = 0
   912 					beq fail
   913
   914 					lda (ztmp8),y		; if length1 <> length2
   915 					cmp (ztmp10),y
   916 					bne fail
   917
   918 					sta max
   919
   920 					inw ztmp8
   921 					inw ztmp10
   922
   923 34B3			loop	lda (ztmp8),y
   924 					cmp (ztmp10),y
   925 					bne fail
   926
   927 					iny
   928
   929 					cpy #0
   930 34B3			max	equ *-1
   931 					bne loop
   932
   933 					lda #0
   934 					seq
   935
   936 34B3			fail	lda #$ff
   937
   938 					ldy #1
   939
   940 					cmp #0
   941 					rts
   942 				.endp
   943
   944
   945 34B3			.proc	notaBX
   946
   947 					.rept MAXSIZE
   948 					LDA :STACKORIGIN+#*STACKWIDTH,X
   949 					EOR #$FF
   950 					STA :STACKORIGIN+#*STACKWIDTH,X
   951 					.ENDR
   951 					.endr
Source: REPT
   948 					LDA :STACKORIGIN+#*STACKWIDTH,X
   948 					EOR #$FF
   948 					STA :STACKORIGIN+#*STACKWIDTH,X
   948 					LDA :STACKORIGIN+#*STACKWIDTH,X
   948 					EOR #$FF
   948 					STA :STACKORIGIN+#*STACKWIDTH,X
   948 					LDA :STACKORIGIN+#*STACKWIDTH,X
   948 					EOR #$FF
   948 					STA :STACKORIGIN+#*STACKWIDTH,X
   948 					LDA :STACKORIGIN+#*STACKWIDTH,X
   948 					EOR #$FF
   948 					STA :STACKORIGIN+#*STACKWIDTH,X
Source: cpu6502.asm
   952
   953 					rts
   954 				.endp
   955
   956
   957 34B3			.proc	notBOOLEAN
   958 					lda :STACKORIGIN,x
   959 					bne _0
   960
   961 					lda #true
   962 					sne
   963
   964 34B3			_0	lda #false
   965 					sta :STACKORIGIN,x
   966
   967 					rts
   968 				.endp
   969
   970
   971 34B3			.proc	negBYTE
   972 					lda #$00
   973 					sub :STACKORIGIN,x
   974 					sta :STACKORIGIN,x
   975
   976 					lda #$00
   977 					sbc #$00
   978 					sta :STACKORIGIN+STACKWIDTH,x
   979
   980 					lda #$00
   981 					sbc #$00
   982 					sta :STACKORIGIN+STACKWIDTH*2,x
   983
   984 					lda #$00
   985 					sbc #$00
   986 					sta :STACKORIGIN+STACKWIDTH*3,x
   987
   988 					rts
   989 				.endp
   990
   991 34B3			.proc	negWORD
   992 					lda #$00
   993 					sub :STACKORIGIN,x
   994 					sta :STACKORIGIN,x
   995
   996 					lda #$00
   997 					sbc :STACKORIGIN+STACKWIDTH,x
   998 					sta :STACKORIGIN+STACKWIDTH,x
   999
  1000 					lda #$00
  1001 					sbc #$00
  1002 					sta :STACKORIGIN+STACKWIDTH*2,x
  1003
  1004 					lda #$00
  1005 					sbc #$00
  1006 					sta :STACKORIGIN+STACKWIDTH*3,x
  1007
  1008 					rts
  1009 				.endp
  1010
  1011 34B3			.proc	negCARD
  1012 					lda #$00
  1013 					sub :STACKORIGIN,x
  1014 					sta :STACKORIGIN,x
  1015
  1016 					lda #$00
  1017 					sbc :STACKORIGIN+STACKWIDTH,x
  1018 					sta :STACKORIGIN+STACKWIDTH,x
  1019
  1020 					lda #$00
  1021 					sbc :STACKORIGIN+STACKWIDTH*2,x
  1022 					sta :STACKORIGIN+STACKWIDTH*2,x
  1023
  1024 					lda #$00
  1025 					sbc :STACKORIGIN+STACKWIDTH*3,x
  1026 					sta :STACKORIGIN+STACKWIDTH*3,x
  1027
  1028 					rts
  1029 				.endp
  1030
  1031
  1032 34B3			.proc	negBYTE1
  1033 					lda #$00
  1034 					sub :STACKORIGIN-1,x
  1035 					sta :STACKORIGIN-1,x
  1036
  1037 					lda #$00
  1038 					sbc #$00
  1039 					sta :STACKORIGIN-1+STACKWIDTH,x
  1040
  1041 					lda #$00
  1042 					sbc #$00
  1043 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1044
  1045 					lda #$00
  1046 					sbc #$00
  1047 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1048
  1049 					rts
  1050 				.endp
  1051
  1052 34B3			.proc	negWORD1
  1053 					lda #$00
  1054 					sub :STACKORIGIN-1,x
  1055 					sta :STACKORIGIN-1,x
  1056
  1057 					lda #$00
  1058 					sbc :STACKORIGIN-1+STACKWIDTH,x
  1059 					sta :STACKORIGIN-1+STACKWIDTH,x
  1060
  1061 					lda #$00
  1062 					sbc #$00
  1063 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1064
  1065 					lda #$00
  1066 					sbc #$00
  1067 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1068
  1069 					rts
  1070 				.endp
  1071
  1072 34B3			.proc	negCARD1
  1073 					lda #$00
  1074 					sub :STACKORIGIN-1,x
  1075 					sta :STACKORIGIN-1,x
  1076
  1077 					lda #$00
  1078 					sbc :STACKORIGIN-1+STACKWIDTH,x
  1079 					sta :STACKORIGIN-1+STACKWIDTH,x
  1080
  1081 					lda #$00
  1082 					sbc :STACKORIGIN-1+STACKWIDTH*2,x
  1083 					sta :STACKORIGIN-1+STACKWIDTH*2,x
  1084
  1085 					lda #$00
  1086 					sbc :STACKORIGIN-1+STACKWIDTH*3,x
  1087 					sta :STACKORIGIN-1+STACKWIDTH*3,x
  1088
  1089 					rts
  1090 				.endp
  1091
  1092
  1093 34B3			.proc	andAL_CL
  1094
  1095 					lda :STACKORIGIN-1,x
  1096 					and :STACKORIGIN,x
  1097 					sta :STACKORIGIN-1,x
  1098
  1099 					rts
  1100 				.endp
  1101
  1102 34B3			.proc	andAX_CX
  1103
  1104 					.rept 2
  1105 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1106 					AND :STACKORIGIN+#*STACKWIDTH,X
  1107 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1108 					.ENDR
  1108 					.endr
Source: REPT
  1105 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1105 					AND :STACKORIGIN+#*STACKWIDTH,X
  1105 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1105 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1105 					AND :STACKORIGIN+#*STACKWIDTH,X
  1105 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1109
  1110 					rts
  1111 				.endp
  1112
  1113 34B3			.proc	andEAX_ECX
  1114
  1115 					.rept MAXSIZE
  1116 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1117 					AND :STACKORIGIN+#*STACKWIDTH,X
  1118 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1119 					.ENDR
  1119 					.endr
Source: REPT
  1116 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1116 					AND :STACKORIGIN+#*STACKWIDTH,X
  1116 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1116 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1116 					AND :STACKORIGIN+#*STACKWIDTH,X
  1116 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1116 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1116 					AND :STACKORIGIN+#*STACKWIDTH,X
  1116 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1116 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1116 					AND :STACKORIGIN+#*STACKWIDTH,X
  1116 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1120
  1121 					rts
  1122 				.endp
  1123
  1124
  1125 34B3			.proc	orAL_CL
  1126
  1127 					lda :STACKORIGIN-1,x
  1128 					ora :STACKORIGIN,x
  1129 					sta :STACKORIGIN-1,x
  1130
  1131 					rts
  1132 				.endp
  1133
  1134 34B3			.proc	orAX_CX
  1135
  1136 					.rept 2
  1137 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1138 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1139 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1140 					.ENDR
  1140 					.endr
Source: REPT
  1137 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1137 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1137 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1137 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1137 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1137 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1141
  1142 					rts
  1143 				.endp
  1144
  1145 34B3			.proc	orEAX_ECX
  1146
  1147 					.rept MAXSIZE
  1148 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1149 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1150 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1151 					.ENDR
  1151 					.endr
Source: REPT
  1148 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1148 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1148 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1148 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1148 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1148 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1148 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1148 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1148 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1148 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1148 					ORA :STACKORIGIN+#*STACKWIDTH,X
  1148 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1152
  1153 					rts
  1154 				.endp
  1155
  1156
  1157 34B3			.proc	xorAL_CL
  1158
  1159 					lda :STACKORIGIN-1,x
  1160 					eor :STACKORIGIN,x
  1161 					sta :STACKORIGIN-1,x
  1162
  1163 					rts
  1164 				.endp
  1165
  1166 34B3			.proc	xorAX_CX
  1167
  1168 					.rept 2
  1169 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1170 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1171 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1172 					.ENDR
  1172 					.endr
Source: REPT
  1169 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1169 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1169 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1169 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1169 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1169 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1173
  1174 					rts
  1175 				.endp
  1176
  1177 34B3			.proc	xorEAX_ECX
  1178
  1179 					.rept MAXSIZE
  1180 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1181 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1182 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1183 					.ENDR
  1183 					.endr
Source: REPT
  1180 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1180 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1180 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1180 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1180 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1180 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1180 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1180 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1180 					STA :STACKORIGIN-1+#*STACKWIDTH,X
  1180 					LDA :STACKORIGIN-1+#*STACKWIDTH,X
  1180 					EOR :STACKORIGIN+#*STACKWIDTH,X
  1180 					STA :STACKORIGIN-1+#*STACKWIDTH,X
Source: cpu6502.asm
  1184
  1185 					rts
  1186 				.endp
  1187
  1188
  1189 				/*
  1190 				.proc	iniEAX_ECX_BYTE
  1191
  1192 					mva :STACKORIGIN,x ecx
  1193 					mva :STACKORIGIN-1,x eax
  1194
  1195 					rts
  1196 				.endp
  1197 				*/
  1197
  1198
  1199
  1200 34B3			.proc	iniEAX_ECX_WORD
  1201
  1202 					mva :STACKORIGIN,x ecx
  1203 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
  1204
  1205 					mva :STACKORIGIN-1,x eax
  1206 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
  1207
  1208 					mva #$00 ecx+2
  1209 					sta ecx+3
  1210
  1211 					sta eax+2
  1212 					sta eax+3
  1213
  1214 					rts
  1215 				.endp
  1216
  1217
  1218 34B3			.proc	iniEAX_ECX_CARD
  1219 34B3 B5 98 85 8A			mva :STACKORIGIN,x ecx
  1220 34B7 B5 A8 85 8B			mva :STACKORIGIN+STACKWIDTH,x ecx+1
  1221 34BB B5 B8 85 8C			mva :STACKORIGIN+STACKWIDTH*2,x ecx+2
  1222 34BF B5 C8 85 8D			mva :STACKORIGIN+STACKWIDTH*3,x ecx+3
  1223
  1224 34C3 B5 97 85 82			mva :STACKORIGIN-1,x eax
  1225 34C7 B5 A7 85 83			mva :STACKORIGIN-1+STACKWIDTH,x eax+1
  1226 34CB B5 B7 85 84			mva :STACKORIGIN-1+STACKWIDTH*2,x eax+2
  1227 34CF B5 C7 85 85			mva :STACKORIGIN-1+STACKWIDTH*3,x eax+3
  1228
  1229 34D3 60				rts
  1230 				.endp
  1231
  1232 34D4			.proc	movZTMP_aBX
  1233 					mva ZTMP8 :STACKORIGIN-1,x
  1234 					mva ZTMP9 :STACKORIGIN-1+STACKWIDTH,x
  1235 					mva ZTMP10 :STACKORIGIN-1+STACKWIDTH*2,x
  1236 					mva ZTMP11 :STACKORIGIN-1+STACKWIDTH*3,x
  1237
  1238 					rts
  1239 				.endp
  1240
  1241
  1242 34D4				icl '6502\cpu6502_sio.asm'
Source: cpu6502_sio.asm
     1
     2 34D4			.proc	@sio
     3
     4 					stx dbufa		;< adres bufora
     5 					sty dbufa+1		;> adres bufora
     6 					sta dcmnd		; 'R' read sector / 'P' write sector
     7
     8 					ldy dunit
     9 					lda lsector-1,y
    10 					sta dsctln		; < dlugosc sektora
    11 				;	sta dbyt		;< dlugosc bufora
    12
    13 					lda hsector-1,y
    14 					sta dsctln+1		; > dlugosc sektora 
    15 				;	sta dbyt+1		;> dlugosc bufora
    16
    17 					lda #$c0		; $40 read / $80 write
    18 					sta dstats
    19
    20 					lda #0
    21 					sta casflg		; = 00 to indicate that it isn't a cassette operation
    22
    23 					jmp jdskint
    24
    25 				// A = [1..8]
    26 34D4			devnrm	tax
    27
    28 					CLC			; clear carry for add
    29 					ADC #$FF-8		; make m = $FF
    30 					ADC #8-1+1		; carry set if in range n to m
    31 					bcs ok
    32
    33 					ldy #-123		; kod bledu "DEVICE OR FILE NOT OPEN"
    34 					rts
    35 					
    36 34D4			ok	txa
    37 					sta dunit		; nr stacji
    38 					ora #$30
    39 					sta ddevic		; nr stacji + $30
    40
    41 					lda #7
    42 					sta dtimlo		; timeout
    43
    44 					ldy #0
    45 					rts
    46
    47 34D4			devsec	tya			; zapisz rozmiar sektora
    48 					ldy dunit
    49 					sta hsector-1,y
    50 					txa
    51 					sta lsector-1,y
    52 					rts
    53
    54 34D4			lsector	:8 dta l(256)
    55 34D4			hsector	:8 dta h(256)
    56
    57 				.endp
  1243 34D4				icl '6502\cpu6502_cio.asm'
Source: cpu6502_cio.asm
     1
     2 				/*
     3 					Reset(f, record)
     4 					Rewrite(f, record)
     5
     6 					C = 1	SEC	IOCHECK TRUE
     7 					C = 0	CLC	IOCHECK FALSE
     8 				*/
     8
     9
    10 34D4			.proc	@openfile (.word ya .byte x) .reg
    11
    12 					sta bp2
    13 					sty bp2+1
    14
    15 					stx code
    16
    17 					lda #0
    18 					rol @
    19 					sta iocheck
    20
    21 					ldy #s@file.status
    22 					lda (bp2),y
    23 					and #e@file.eof^$ff
    24 					sta (bp2),y
    25
    26 					ldy #s@file.pfname
    27 					lda (bp2),y
    28 					add #1
    29 					sta lfname
    30 					iny
    31 					lda (bp2),y
    32 					adc #0
    33 					sta hfname
    34
    35 					jsr lookup
    36 					bmi error
    37
    38 					ldy #s@file.chanel
    39 					txa
    40 					sta (bp2),y		;CHANNEL
    41
    42 				; -----------------------------------------
    43
    44 					lda #$03		;komenda: OPEN
    45 					sta iccmd,x
    46 					lda #$00		;adres nazwy pliku
    47 34D4			lfname	equ *-1
    48 					sta icbufa,x
    49 					lda #$00
    50 34D4			hfname	equ *-1
    51 					sta icbufa+1,x
    52 					lda #$00		;kod dostepu: $04 odczyt, $08 zapis, $09 dopisywanie, $0c odczyt/zapis, $0d odczyt/dopisywanie
    53 34D4			code	equ *-1
    54 					sta icax1,x
    55 					lda #$00		;dodatkowy parametr, $00 jest zawsze dobre
    56 					sta icax2,x
    57 					jsr ciov
    58
    59 34D4			error	sty MAIN.SYSTEM.IOResult
    60
    61 					bpl ok
    62
    63 34D4			msg	lda #true
    64 34D4			iocheck	equ *-1
    65 					beq skp
    66
    67 					sty dx
    68 				;	sty FX_CORE_RESET
    69
    70 					@clrscr
    71
    72 					lda <_error
    73 					ldy >_error
    74 					jsr @printSTRING
    75
    76 					lda #$00
    77 					sta dx+1
    78 					sta dx+2
    79 					sta dx+3
    80
    81 					jsr @printVALUE
    82
    83 					jmp MAIN.@halt
    84
    85 34D4			skp	ldy #s@file.status
    86 					lda (bp2),y
    87 					ora #e@file.eof
    88 					sta (bp2),y
    89
    90 					ldy #s@file.record
    91 					lda #$00
    92 					sta (bp2),y
    93 					iny
    94 					sta (bp2),y
    95
    96 					rts
    97
    98 34D4			ok	ldy #s@file.status
    99 					lda (bp2),y
   100 					ora #e@file.open
   101 					sta (bp2),y
   102
   103 					rts
   104
   105 34D4			_error	dta 6,c'ERROR '
   106
   107 				; -----------------------------------------
   108
   109 34D4			lookup	ldx #$00
   110 					ldy #$01
   111 34D4			loop	lda icchid,x
   112 					cmp #$ff
   113 					beq found
   114 					txa
   115 					clc
   116 					adc #$10
   117 					tax
   118 					bpl loop
   119 					ldy #-95       		; kod bledu "TOO MANY CHANNELS OPEN"
   120 34D4			found	rts
   121 				.endp
   122
   123
   124 				/*
   125 					Close(f)
   126
   127 					C = 1	SEC	IOCHECK TRUE
   128 					C = 0	CLC	IOCHECK FALSE
   129 				*/
   129
   130
   131 34D4			.proc	@closefile (.word ya) .reg
   132 					sta	bp2
   133 					sty	bp2+1
   134
   135 					ldy	#s@file.status
   136
   137 					lda	#0
   138 					rol	@
   139 					sta	@openfile.iocheck
   140 				;	beq	ok_open
   141
   142 					lda	(bp2),y
   143 					and 	#e@file.open
   144 					bne	ok_open
   145
   146 					ldy	#-123		; kod bledu "DEVICE OR FILE NOT OPEN"
   147 					jmp	@openfile.error
   148
   149 34D4			ok_open	lda	(bp2),y
   150 					ora	#e@file.eof
   151 					sta	(bp2),y
   152
   153 					ldy	#s@file.chanel
   154 					lda	(bp2),y
   155 					tax
   156
   157 					lda	#$0c		;komenda: CLOSE
   158 					sta	iccmd,x
   159 					jsr	ciov
   160
   161 				;	lda	#0		; iocheck off
   162 				;	sta	@openfile.iocheck
   163
   164 					jmp	@openfile.error
   165
   166 				.endp
   167
   168
   169 				/*
   170 					BlockRead(f, buf, num_records, numread)
   171 					BlockWrite(f, buf, num_records, numwrite)
   172
   173 					C = 1	SEC	IOCHECK TRUE
   174 					C = 0	CLC	IOCHECK FALSE
   175 				*/
   175
   176
   177 34D4			.proc	@readfile (.word ya .byte x) .reg
   178
   179 					sta	bp2
   180 					sty	bp2+1
   181
   182 					stx	code
   183
   184 					lda	#$00
   185 					sta	eax+2
   186 					sta	eax+3
   187 					sta	ecx+2
   188 					sta	ecx+3
   189
   190 					sta	MAIN.SYSTEM.IOResult
   191
   192 					rol	@
   193 					sta	@openfile.iocheck
   194
   195 					ldy	#s@file.status
   196 					lda	(bp2),y
   197 					and	#e@file.open
   198 					bne	ok_open
   199
   200 					ldy	#-123			; kod bledu "DEVICE OR FILE NOT OPEN"
   201 					jmp	@openfile.error
   202
   203 34D4			ok_open	ldy	#s@file.record
   204 					mwa	(bp2),y	ecx
   205
   206 					ldy	#s@file.nrecord
   207 					mwa	(bp2),y	eax
   208
   209 				;	lda	#0
   210 					jsr	imulCX			; record * nrecord = file length to load
   211
   212 					cpw	eax #0
   213 					beq	nothing
   214
   215 					ldy	#s@file.chanel
   216 					lda	(bp2),y
   217 					tax
   218
   219 					mwa	eax	icbufl,x
   220
   221 					ldy	#s@file.buffer
   222 					mwa	(bp2),y	icbufa,x
   223
   224 					lda	#$00
   225 34D4			code	equ *-1
   226 					and	#$7f
   227 					sta	iccmd,x
   228
   229 					jsr	ciov
   230
   231 					sty	MAIN.SYSTEM.IOResult
   232
   233 					bpl ok
   234
   235 					cpy #136
   236 					beq done
   237
   238 					jsr eof
   239
   240 					lda #$00
   241 					sta eax
   242 					sta eax+1
   243
   244 					jmp	@openfile.msg
   245
   246 34D4			done	jsr eof
   247
   248 34D4			ok	mwa icbufl,x	eax
   249 					ldy #s@file.record
   250 					mwa (bp2),y	ecx
   251
   252 					lda #$00
   253 					jsr idivAX_CX.main
   254
   255 34D4			nothing	lda code
   256 					bpl quit			; blockread(f, buf, len)   short version
   257
   258 					ldy #s@file.numread
   259 					mwa (bp2),y ztmp
   260
   261 					ldy #0
   262 					mwa eax (ztmp),y		; length of loaded data / record = number of records
   263
   264 34D4			quit	rts
   265
   266 34D4			eof	ldy #s@file.status
   267 					lda (bp2),y
   268 					ora #e@file.eof
   269 					sta (bp2),y
   270
   271 					rts
   272 				.endp
   273
   274
   275 34D4			.proc	@ReadDirFileName (.word ya) .reg
   276
   277 					ldx #5
   278 					clc		; iocheck off
   279 					jsr @readfile	; (ya, x)
   280
   281 					ldy eax
   282
   283 					lda MAIN.SYSTEM.IOResult
   284 					smi
   285 					lda #0		; ok
   286
   287 					rts
   288 				.endp
   289
   290
   291 34D4			.proc	@DirFileName
   292
   293 					lda #0
   294 					sta attr
   295
   296 					cpy #$12
   297 					bne stop
   298
   299 					lda @buf
   300 					cmp #'*'
   301 					bne skp
   302
   303 					lda #MAIN.SYSUTILS.faReadOnly
   304 					sta attr
   305
   306 34D4			skp	ldy #1
   307 					ldx #2
   308 					lda #10
   309 					jsr cpName
   310
   311 					ldx #10
   312 					lda @buf,x
   313 					pha
   314 					bpl files
   315
   316 					lda attr
   317 					ora #MAIN.SYSUTILS.faDirectory
   318 					sta attr
   319
   320 					jmp skp2
   321
   322 34D4			files	lda attr
   323 					ora #MAIN.SYSUTILS.faArchive
   324 					sta attr
   325
   326 34D4			skp2	pla
   327 					beq stp2
   328
   329 					lda #'.'
   330 					sta (bp2),y
   331 					iny
   332
   333 					lda #13
   334 					jsr cpName
   335 34D4			stp2
   336 					dey
   337 					tya
   338 34D4			stop	ldy #0
   339 					sta (bp2),y
   340
   341 					ldx #0
   342 34D4			attr	equ *-1
   343 					rts
   344
   345 34D4			cpName	sta ln
   346 34D4			cp	lda @buf,x
   347 					cmp #' '
   348 					beq stp
   349 					sta (bp2),y
   350 					iny
   351 					inx
   352 					cpx #0
   353 34D4			ln	equ *-1
   354 					bne cp
   355 34D4			stp	rts
   356 				.endp
   357
  1244
  1245 34D4				icl '6502\cpu6502_shortint.asm'		; mul / div -> SHORTINT
Source: cpu6502_shortint.asm
     1
     2 				/*
     3 					mulSHORTINT
     4 					divmulSHORTINT
     5 				*/
     5
     6
     7
     8 34D4			.proc	mulSHORTINT
     9
    10 					jsr imulBYTE
    11
    12 					lda :STACKORIGIN-1,x
    13 					bpl @+
    14 						sec
    15 						lda eax+1
    16 						sbc :STACKORIGIN,x
    17 						sta eax+1
    18 34D4			@
    19 					lda :STACKORIGIN,x
    20 					bpl @+
    21 						sec
    22 						lda eax+1
    23 						sbc :STACKORIGIN-1,x
    24 						sta eax+1
    25 34D4			@
    26 					jmp movaBX_EAX
    27 				.endp
    28
    29
    30 34D4			.proc	divmulSHORTINT
    31
    32 34D4			MOD	mva #{jsr} _mod
    33
    34 					lda :STACKORIGIN,x		; divisor sign
    35 					spl
    36 					jsr negBYTE
    37
    38 34D4			DIV	ldy <idivBYTE
    39 					lda >idivBYTE
    40
    41 34D4			skp	sty addr
    42 					sta addr+1
    43
    44 					ldy #0
    45
    46 					lda :STACKORIGIN-1,x		; dividend sign
    47 					bpl @+
    48 					jsr negBYTE1
    49 					iny
    50
    51 34D4			@	lda :STACKORIGIN,x		; divisor sign
    52 					bpl @+
    53 					jsr negBYTE
    54 					iny
    55
    56 34D4			@	tya
    57 					and #1
    58 					pha
    59
    60 					jsr $ffff			; idiv ecx
    61 34D4			addr	equ *-2
    62
    63 					jsr movaBX_EAX
    64
    65 34D4			_mod	bit movZTMP_aBX			; mod
    66 					mva #{bit} _mod
    67
    68 					pla
    69 					seq
    70 					jmp negCARD1
    71
    72 					rts
    73 				.endp
  1246 34D4				icl '6502\cpu6502_smallint.asm'		; mul / div -> SMALLINT
Source: cpu6502_smallint.asm
     1
     2 				/*
     3 					mulSMALLINT
     4 					divmulSMALLINT
     5 				*/
     5
     6
     7
     8 34D4			.proc	mulSMALLINT
     9
    10 					jsr imulWORD
    11
    12 					lda :STACKORIGIN-1+STACKWIDTH,x	; t1
    13 					bpl @+
    14 						sec
    15 						lda eax+2
    16 						sbc :STACKORIGIN,x
    17 						sta eax+2
    18 						lda eax+3
    19 						sbc :STACKORIGIN+STACKWIDTH,x
    20 						sta eax+3
    21 34D4			@
    22 					lda :STACKORIGIN+STACKWIDTH,x	; t2
    23 					bpl @+
    24 						sec
    25 						lda eax+2
    26 						sbc :STACKORIGIN-1,x
    27 						sta eax+2
    28 						lda eax+3
    29 						sbc :STACKORIGIN-1+STACKWIDTH,x
    30 						sta eax+3
    31 34D4			@
    32 					jmp movaBX_EAX
    33 				.endp
    34
    35
    36 34D4			.proc	divmulSMALLINT
    37
    38 34D4			SHORTREAL
    39 					ldy <divSHORTREAL
    40 					lda >divSHORTREAL
    41 					bne skp
    42
    43 34D4			MOD	mva #{jsr} _mod
    44
    45 					lda :STACKORIGIN+STACKWIDTH,x	; divisor sign
    46 					spl
    47 					jsr negWORD
    48
    49 34D4			DIV	ldy <idivWORD
    50 					lda >idivWORD
    51
    52 34D4			skp	sty addr
    53 					sta addr+1
    54
    55 					ldy #0
    56
    57 					lda :STACKORIGIN-1+STACKWIDTH,x	; dividend sign
    58 					bpl @+
    59 					jsr negWORD1
    60 					iny
    61 34D4			@
    62 					lda :STACKORIGIN+STACKWIDTH,x	; divisor sign
    63 					bpl @+
    64 					jsr negWORD
    65 					iny
    66 34D4			@
    67 					tya
    68 					and #1
    69 					pha
    70
    71 					jsr $ffff			; idiv cx
    72 34D4			addr	equ *-2
    73
    74 					jsr movaBX_EAX
    75
    76 34D4			_mod	bit movZTMP_aBX			; mod
    77 					mva #{bit} _mod
    78
    79 					pla
    80 					seq
    81 					jmp negCARD1
    82
    83 					rts
    84 				.endp
  1247 34D4				icl '6502\cpu6502_integer.asm'		; mul / div -> INTEGER
Source: cpu6502_integer.asm
     1
     2 				/*
     3 					mulINTEGER
     4 					divmulINT
     5 				*/
     5
     6
     7 34D4			.proc	mulINTEGER
     8
     9 					jsr imulCARD
    10
    11 					jmp movaBX_EAX
    12 				.endp
    13
    14
    15 34D4			.proc	divmulINT
    16
    17 34D4			REAL	ldy <divREAL
    18 					lda >divREAL
    19 					bne skp
    20
    21 34D4			MOD	mva #{jsr} _mod
    22
    23 					lda :STACKORIGIN+STACKWIDTH*3,x		; divisor sign
    24 					spl
    25 					jsr negCARD
    26
    27 34D4			DIV	ldy <idivCARD
    28 					lda >idivCARD
    29
    30 34D4			skp	sty addr
    31 					sta addr+1
    32
    33 					ldy #0
    34
    35 					lda :STACKORIGIN-1+STACKWIDTH*3,x	; dividend sign
    36 					bpl @+
    37 					jsr negCARD1
    38 					iny
    39
    40 34D4			@	lda :STACKORIGIN+STACKWIDTH*3,x		; divisor sign
    41 					bpl @+
    42 					jsr negCARD
    43 					iny
    44
    45 34D4			@	tya
    46 					and #1
    47 					pha
    48
    49 					jsr $ffff				; idiv ecx
    50 34D4			addr	equ *-2
    51 					jsr movaBX_EAX
    52
    53 34D4			_mod	bit movZTMP_aBX				; mod
    54 					mva #{bit} _mod
    55
    56 					pla
    57 					seq
    58 					jmp negCARD1
    59
    60 					rts
    61 				.endp
  1248
  1249 34D4				icl '6502\cpu6502_byte.asm'		; mul / div -> BYTE
Source: cpu6502_byte.asm
     1
     2 				/*
     3 					fmulu_8
     4 					imulCL
     5 					imulBYTE
     6 					idivBYTE
     7 					idiv_AL_CL
     8 				*/
     8
     9
    10 				; Description: Unsigned 8-bit multiplication with unsigned 16-bit result.
    11 				;
    12 				; Input: 8-bit unsigned value in T1
    13 				;	 8-bit unsigned value in T2
    14 				;	 Carry=0: Re-use T1 from previous multiplication (faster)
    15 				;	 Carry=1: Set T1 (slower)
    16 				;
    17 				; Output: 16-bit unsigned value in PRODUCT
    18 				;
    19 				; Clobbered: PRODUCT, X, A, C
    20 				;
    21 				; Allocation setup: T1,T2 and PRODUCT preferably on Zero-page.
    22 				;		    square1_lo, square1_hi, square2_lo, square2_hi must be
    23 				;		    page aligned. Each table are 512 bytes. Total 2kb.
    24 				;
    25 				; Table generation: I:0..511
    26 				;		    square1_lo = <((I*I)/4)
    27 				;		    square1_hi = >((I*I)/4)
    28 				;		    square2_lo = <(((I-255)*(I-255))/4)
    29 				;		    square2_hi = >(((I-255)*(I-255))/4)
    30 34D4			.proc fmulu_8
    31
    32 = 0082			t1	= eax
    33 = 008A			t2	= ecx
    34
    35 = 0082			product	= eax
    36
    37 					txa:tay
    38 				;		bcc :+
    39 						    lda T1
    40 						    sta sm1+1
    41 						    sta sm3+1
    42 						    eor #$ff
    43 						    sta sm2+1
    44 						    sta sm4+1
    45
    46 						ldx T2
    47 						sec
    48 34D4			sm1:		lda square1_lo,x
    49 34D4			sm2:		sbc square2_lo,x
    50 						sta PRODUCT+0
    51 34D4			sm3:		lda square1_hi,x
    52 34D4			sm4:		sbc square2_hi,x
    53
    54 						sta PRODUCT+1
    55
    56 					tya:tax
    57 						rts
    58 				.endp
    59
    60
    61 				/*
    62
    63 				 8 bit multiply and divide routines.
    64 				 Three 8 bit locations
    65 				 ACC, AUX and EXT must be set up,
    66 				 preferably on zero page.
    67
    68 				 MULTIPLY ROUTINE
    69
    70 				 EAX*ECX -> EAX (low,hi) 16 bit result
    71
    72 				*/
    72
    73
    74 34D4			.proc	imulCL
    75
    76 34D4 A9 00			lda #$00
    77
    78 34D6 A0 09			LDY #$09
    79 34D8 18				CLC
    80 34D9 6A			LOOP	ROR @
    81 34DA 66 82			ROR eax
    82 34DC 90 03			BCC MUL2
    83 34DE 18				CLC		;DEC AUX above to remove CLC
    84 34DF 65 8A			ADC ecx
    85 34E1 88			MUL2	DEY
    86 34E2 D0 F5			BNE LOOP
    87
    88 34E4 85 83			STA eax+1
    89
    90 34E6 60				RTS
    91 				.endp
    92
    93
    94 34E7			.proc	imulBYTE
    95
    96 34E7 B5 98 85 8A			mva :STACKORIGIN,x ecx
    97 34EB B5 97 85 82			mva :STACKORIGIN-1,x eax
    98
    99 34EF A9 00			lda #$00
   100
   101 34F1 85 84			sta eax+2
   102 34F3 85 85			sta eax+3
   103
   104 					.ifdef fmulinit
   105 					jmp fmulu_8
   106 					els
   107 34F5 4C D4 34			jmp imulCL
   108 					eif
   109
   110 				.endp
   111
   112
   113 				.define	jsr_imodBYTE jsr idivBYTE
   114
   115 34F8			.proc	idivBYTE
   116
   117 					mva :STACKORIGIN,x ecx
   118 					mva :STACKORIGIN-1,x eax
   119
   120 					jmp idivAL_CL
   121 				.endp
   122
   123
   124 				; DIVIDE ROUTINE (8 BIT)
   125 				; AL/CL -> ACC, remainder in ZTMP
   126
   127 34F8			.proc idivAL_CL
   128
   129 				;	mva :STACKORIGIN,x cl
   130 				;	mva :STACKORIGIN-1,x al
   131
   132 					lda #$00
   133
   134 					sta eax+1
   135 					sta eax+2
   136 					sta eax+3
   137
   138 					STA ztmp+1
   139 					STA ztmp+2
   140 					STA ztmp+3
   141
   142 					LDY #$08
   143 34F8			LOOP	ASL AL
   144 					ROL @
   145 					CMP CL
   146 					BCC DIV2
   147 					SBC CL
   148 					INC AL
   149 34F8			DIV2
   150 					DEY
   151 					BNE LOOP
   152
   153 					STA ZTMP
   154
   155 					rts
   156 				.endp
   157
  1250 34F8				icl '6502\cpu6502_word.asm'		; mul / div -> WORD
Source: cpu6502_word.asm
     1
     2 				/*
     3 					fmulu_16
     4 					imulCX
     5 					imulWORD
     6 					idivWORD
     7 					idivAX_CX
     8 				*/
     8
     9
    10 				; Description: Unsigned 16-bit multiplication with unsigned 32-bit result.
    11 				;
    12 				; Input: 16-bit unsigned value in T1
    13 				;	 16-bit unsigned value in T2
    14 				;	 Carry=0: Re-use T1 from previous multiplication (faster)
    15 				;	 Carry=1: Set T1 (slower)
    16 				;
    17 				; Output: 32-bit unsigned value in PRODUCT
    18 				;
    19 				; Clobbered: PRODUCT, X, A, C
    20 				;
    21 				; Allocation setup: T1,T2 and PRODUCT preferably on Zero-page.
    22 				;		    square1_lo, square1_hi, square2_lo, square2_hi must be
    23 				;		    page aligned. Each table are 512 bytes. Total 2kb.
    24 				;
    25 				; Table generation: I:0..511
    26 				;		    square1_lo = <((I*I)/4)
    27 				;		    square1_hi = >((I*I)/4)
    28 				;		    square2_lo = <(((I-255)*(I-255))/4)
    29 				;		    square2_hi = >(((I-255)*(I-255))/4)
    30 				//.proc multiply_16bit_unsigned
    31 						; <T1 * <T2 = AAaa
    32 						; <T1 * >T2 = BBbb
    33 						; >T1 * <T2 = CCcc
    34 						; >T1 * >T2 = DDdd
    35 						;
    36 						;	AAaa
    37 						;     BBbb
    38 						;     CCcc
    39 						; + DDdd
    40 						; ----------
    41 						;   PRODUCT!
    42
    43 						; Setup T1 if changed
    44 34F8			.proc	fmulu_16
    45
    46 = 0082			t1	= eax
    47 = 008A			t2	= ecx
    48
    49 = 0082			product	= eax
    50
    51 					txa:pha
    52 				;		bcc @+
    53 						    lda T1+0
    54 						    sta sm1a+1
    55 						    sta sm3a+1
    56 						    sta sm5a+1
    57 						    sta sm7a+1
    58 						    eor #$ff
    59 						    sta sm2a+1
    60 						    sta sm4a+1
    61 						    sta sm6a+1
    62 						    sta sm8a+1
    63 						    lda T1+1
    64 						    sta sm1b+1
    65 						    sta sm3b+1
    66 						    sta sm5b+1
    67 						    sta sm7b+1
    68 						    eor #$ff
    69 						    sta sm2b+1
    70 						    sta sm4b+1
    71 						    sta sm6b+1
    72 						    sta sm8b+1
    73 				;@
    74 						; Perform <T1 * <T2 = AAaa
    75 						ldx T2+0
    76 						sec
    77 34F8			sm1a:		lda square1_lo,x
    78 34F8			sm2a:		sbc square2_lo,x
    79 						sta PRODUCT+0
    80 34F8			sm3a:		lda square1_hi,x
    81 34F8			sm4a:		sbc square2_hi,x
    82 						;sta _AA+1
    83 						tay
    84
    85 						; Perform >T1_hi * <T2 = CCcc
    86 						sec
    87 34F8			sm1b:		lda square1_lo,x
    88 34F8			sm2b:		sbc square2_lo,x
    89 						sta _cc+1
    90 34F8			sm3b:		lda square1_hi,x
    91 34F8			sm4b:		sbc square2_hi,x
    92 						sta _CC_+1
    93
    94 						; Perform <T1 * >T2 = BBbb
    95 						ldx T2+1
    96 						sec
    97 34F8			sm5a:		lda square1_lo,x
    98 34F8			sm6a:		sbc square2_lo,x
    99 						sta _bb+1
   100 34F8			sm7a:		lda square1_hi,x
   101 34F8			sm8a:		sbc square2_hi,x
   102 						sta _BB_+1
   103
   104 						; Perform >T1 * >T2 = DDdd
   105 						sec
   106 34F8			sm5b:		lda square1_lo,x
   107 34F8			sm6b:		sbc square2_lo,x
   108 						sta _dd+1
   109 34F8			sm7b:		lda square1_hi,x
   110 34F8			sm8b:		sbc square2_hi,x
   111 				;		sta PRODUCT+3
   112 						tax
   113
   114 						; Add the separate multiplications together
   115 						clc
   116 				;_AA:		lda #0
   117 						tya
   118 34F8			_bb:		adc #0
   119 				;		sta PRODUCT+1
   120 						tay
   121 34F8			_BB_:		lda #0
   122 34F8			_CC_:		adc #0
   123 						sta PRODUCT+2
   124 						bcc @+
   125 				;		    inc PRODUCT+3
   126 						inx
   127 						    clc
   128 34F8			@
   129 						tya
   130 34F8			_cc:		adc #0
   131 				;		adc PRODUCT+1
   132 						sta PRODUCT+1
   133 34F8			_dd:		lda #0
   134 						adc PRODUCT+2
   135 						sta PRODUCT+2
   136 						scc
   137 				;		    inc PRODUCT+3
   138 						inx
   139
   140 					stx PRODUCT+3
   141
   142 					pla:tax
   143
   144 					rts
   145 				.endp
   146
   147
   148 				/*
   149
   150 				 16 bit multiply and divide routines.
   151 				 Three 16 bit (two-byte) locations
   152 				 ACC, AUX and EXT must be set up,
   153 				 preferably on zero page.
   154
   155 				 MULTIPLY ROUTINE
   156
   157 				 EAX*ECX -> EAX (low,hi) 32 bit result
   158
   159 				*/
   159
   160
   161 34F8			.proc	imulCX
   162
   163 34F8 A9 00			lda #$00
   164 34FA 85 85			sta eax+3
   165
   166 34FC A0 11			LDY #$11			; A = 0 !
   167 34FE 18				CLC
   168 34FF 66 85		LOOP	ROR eax+3
   169 3501 6A				ROR @
   170 3502 66 83			ROR eax+1
   171 3504 66 82			ROR eax
   172 3506 90 0B			BCC MUL2
   173 3508 18				CLC
   174 3509 65 8A			ADC ecx
   175 350B 48				PHA
   176 350C A5 8B			LDA ecx+1
   177 350E 65 85			ADC eax+3
   178 3510 85 85			STA eax+3
   179 3512 68				PLA
   180 3513 88			MUL2	DEY
   181 3514 D0 E9			BNE LOOP
   182
   183 3516 85 84			STA eax+2
   184
   185 3518 60				rts
   186 				.endp
   187
   188
   189 3519			.proc	imulWORD
   190
   191 3519 B5 98 85 8A			mva :STACKORIGIN,x ecx
   192 351D B5 A8 85 8B			mva :STACKORIGIN+STACKWIDTH,x ecx+1
   193
   194 3521 B5 97 85 82			mva :STACKORIGIN-1,x eax
   195 3525 B5 A7 85 83			mva :STACKORIGIN-1+STACKWIDTH,x eax+1
   196
   197 					.ifdef fmulinit
   198 					jmp fmulu_16
   199 					els
   200 3529 4C F8 34			jmp imulCX
   201 					eif
   202 				.endp
   203
   204
   205 				.define	jsr_imodWORD jsr idivWORD
   206
   207 352C			.proc	idivWORD
   208
   209 					mva :STACKORIGIN,x ecx
   210 					mva :STACKORIGIN+STACKWIDTH,x ecx+1
   211
   212 					mva :STACKORIGIN-1,x eax
   213 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
   214
   215 					jmp idivAX_CX
   216 				.endp
   217
   218
   219 				; DIVIDE ROUTINE (16 BIT)
   220 				; AX/CX -> ACC, remainder in ZTMP
   221
   222 352C			.proc	idivAX_CX
   223
   224 				;	jsr iniEAX_ECX_WORD
   225 352C			main
   226 					LDA #0
   227 					STA ztmp+1
   228 					STA ztmp+2
   229 					STA ztmp+3
   230
   231 					sta eax+2
   232 					sta eax+3
   233
   234 					.ifdef fmulinit
   235 					.rept 16
   236 					ASL ax
   237 					ROL ax+1
   238 					ROL @
   239 					ROL ztmp+1
   240 					tay
   241 					CMP cx
   242 					LDA ztmp+1
   243 					SBC cx+1
   244 					BCC @+
   245 					STA ztmp+1
   246 					tya
   247 					SBC cx
   248 					tay
   249 					INC ax
   250 				@	tya
   251 					.endr
   252
   253 					els
   254 					LDY #$10
   255
   256 352C			LOOP	ASL ax
   257 					ROL ax+1
   258 					ROL @
   259 					ROL ztmp+1
   260 					sta edx
   261 					CMP cx
   262 					LDA ztmp+1
   263 					SBC cx+1
   264 					BCC DIV2
   265 					STA ztmp+1
   266 					lda edx
   267 					SBC cx
   268 					sta edx
   269 					INC ax
   270 352C			DIV2	lda edx
   271 					DEY
   272 					BNE LOOP
   273 					eif
   274
   275 					STA ztmp
   276
   277 					rts
   278 				.endp
   279
  1251 352C				icl '6502\cpu6502_cardinal.asm'		; mul / div -> CARDINAL
Source: cpu6502_cardinal.asm
     1
     2 				/*
     3 					imulECX
     4 					imulCARD
     5 					idivCARD
     6 					idivEAX_ECX
     7 				*/
     7
     8
     9 				; *** MUL32: 32-bit multiply
    10 				; EAX * ECX -> ZTMP8-ZTMP11
    11 352C			.proc	imulECX
    12
    13 352C A9 00			lda #0
    14 352E 85 94			sta ZTMP10
    15 3530 85 93			sta ZTMP9
    16 3532 85 92			sta ZTMP8
    17
    18 3534 A0 20			ldy #32
    19 3536 46 94		MUL320	lsr ZTMP10
    20 3538 66 93			ror ZTMP9
    21 353A 66 92			ror ZTMP8
    22 353C 6A				ror @
    23 353D 66 85			ror eax+3
    24 353F 66 84			ror eax+2
    25 3541 66 83			ror eax+1
    26 3543 66 82			ror eax
    27 3545 90 17			bcc MUL321
    28 3547 18				clc
    29 3548 65 8A			adc ecx
    30 354A 48				pha
    31 354B A5 8B			lda ecx+1
    32 354D 65 92			adc ZTMP8
    33 354F 85 92			sta ZTMP8
    34 3551 A5 8C			lda ecx+2
    35 3553 65 93			adc ZTMP9
    36 3555 85 93			sta ZTMP9
    37 3557 A5 8D			lda ecx+3
    38 3559 65 94			adc ZTMP10
    39 355B 85 94			sta ZTMP10
    40 355D 68				pla
    41 355E 88			MUL321	dey
    42 355F 10 D5		       	bpl MUL320
    43
    44 3561 60				rts
    45 				.endp
    46
    47
    48 3562			.proc	imulCARD
    49
    50 3562 20 B3 34			jsr iniEAX_ECX_CARD
    51
    52 3565 4C 2C 35			jmp imulECX
    53 				.endp
    54
    55
    56 				.define	jsr_imodCARD jsr idivCARD
    57
    58 3568			.proc	idivCARD
    59
    60 					jsr iniEAX_ECX_CARD
    61
    62 					jmp idivEAX_ECX.CARD
    63 				.endp
    64
    65
    66 				; *** UDIV32: 32-bit unsigned division
    67 				; input: dividend at ZTMP0-ZTMP3
    68 				;        divisor at ZTMP4-ZTMP7
    69 				; output: result at ZTMP0-ZTMP3
    70 				;         remainder at ZTMP8-ZTMP11
    71 				; X,Y preserved
    72
    73 3568			.proc	idivEAX_ECX
    74
    75 3568			REAL	mva :STACKORIGIN-1+STACKWIDTH*2,x :STACKORIGIN-1+STACKWIDTH*3,x
    76 					mva :STACKORIGIN-1+STACKWIDTH,x :STACKORIGIN-1+STACKWIDTH*2,x
    77 					mva :STACKORIGIN-1,x :STACKORIGIN-1+STACKWIDTH,x
    78 					mva #$00 :STACKORIGIN-1,x
    79
    80 3568			CARD	;jsr iniEAX_ECX_CARD
    81
    82 3568			MAIN	LDA #0
    83 					STA ZTMP8
    84 					STA ZTMP9
    85 					STA ZTMP10
    86 					STA ZTMP11
    87
    88 					LDY #32
    89 3568			UDIV320	ASL eax
    90 					ROL eax+1
    91 					ROL eax+2
    92 					ROL eax+3
    93 					ROL ZTMP8
    94 					ROL ZTMP9
    95 					ROL ZTMP10
    96 					ROL ZTMP11
    97 							;do a subtraction
    98 					LDA ZTMP8
    99 					CMP ecx
   100 					LDA ZTMP9
   101 					SBC ecx+1
   102 					LDA ZTMP10
   103 					SBC ecx+2
   104 					LDA ZTMP11
   105 					SBC ecx+3
   106 					BCC UDIV321
   107 				 			;overflow, do the subtraction again, this time store the result
   108 					STA ecx+3	;we have the high byte already
   109 					LDA ZTMP8
   110 					SBC ecx		;byte 0
   111 					STA ZTMP8
   112 					LDA ZTMP9
   113 					SBC ecx+1
   114 					STA ZTMP9	;byte 1
   115 					LDA ZTMP10
   116 					SBC ecx+2
   117 					STA ZTMP10	;byte 2
   118 					INC eax		;set result bit
   119
   120 3568			UDIV321	DEY
   121 					BNE UDIV320
   122
   123 					rts
   124 				.endp
   125
  1252
  1253 3568				icl '6502\cpu6502_shortreal.asm'	; mul / div -> SHORTREAL	Q8.8
Source: cpu6502_shortreal.asm
     1 				; SHORTREAL	fixed-point Q8.8, 16bit
     2 				; https://en.wikipedia.org/wiki/Q_(number_format)
     3
     4 				/*
     5 					mulSHORTREAL
     6 					divSHORTREAL
     7 				*/
     7
     8
     9
    10 3568			.proc	mulSHORTREAL
    11
    12 					jsr imulWORD
    13
    14 					mva #0 eax+3
    15 					mva eax+1 eax
    16 					mva eax+2 eax+1
    17
    18 					ldy eax+3
    19
    20 					lda :STACKORIGIN-1+STACKWIDTH,x	; t1
    21 					bpl @+
    22 					sec
    23 					lda eax+1
    24 					sbc :STACKORIGIN,x
    25 					sta eax+1
    26 					tya
    27 					sbc :STACKORIGIN+STACKWIDTH,x
    28 					tay
    29 3568			@
    30 					lda :STACKORIGIN+STACKWIDTH,x	; t2
    31 					bpl @+
    32 					sec
    33 					lda eax+1
    34 					sbc :STACKORIGIN-1,x
    35 					sta eax+1
    36 					tya
    37 					sbc :STACKORIGIN-1+STACKWIDTH,x
    38 					tay
    39 3568			@
    40 					sty eax+2
    41
    42 					jmp movaBX_EAX
    43 				.endp
    44
    45
    46
    47 3568			.proc	divSHORTREAL
    48 					jsr iniEAX_ECX_WORD
    49
    50 					mva eax+1 eax+2
    51 					mva eax eax+1
    52 					lda #0
    53 					sta eax
    54 					sta eax+3
    55 					sta ecx+3
    56
    57 					jmp idivEAX_ECX.main
    58 				.endp
  1254 3568				icl '6502\cpu6502_real.asm'		; mul / div -> REAL		Q24.8
Source: cpu6502_real.asm
     1 				; REAL	fixed-point Q24.8, 32bit
     2 				; https://en.wikipedia.org/wiki/Q_(number_format)
     3
     4 				/*
     5 					mulREAL
     6 					divREAL
     7 				*/
     7
     8
     9
    10 3568			.proc	mulREAl
    11
    12 				;	jsr iniEAX_ECX_CARD
    13
    14 					mva :STACKORIGIN,x ecx0
    15 					mva :STACKORIGIN+STACKWIDTH,x ecx1
    16 					mva :STACKORIGIN+STACKWIDTH*2,x ecx2
    17 					mva :STACKORIGIN+STACKWIDTH*3,x ecx3
    18
    19 					mva :STACKORIGIN-1,x eax
    20 					mva :STACKORIGIN-1+STACKWIDTH,x eax+1
    21 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+2
    22 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+3
    23
    24 				;	jsr imul64				; imul ecx 64 bit
    25
    26 					lda #$00
    27 					sta edx		;Clear upper half of
    28 					sta edx+1	;product
    29 					sta edx+2
    30 					sta edx+3
    31
    32 					sta ztmp8
    33 					sta ztmp9
    34 					sta ztmp10
    35 					sta ztmp11
    36
    37 					ldy #$20	;Set binary count to 32
    38 3568			SHIFT_R	lsr eax+3	;Shift multiplyer right
    39 					ror eax+2
    40 					ror eax+1
    41 					ror eax
    42 					bcc ROTATE_R	;Go rotate right if c = 0
    43 					lda edx		;Get upper half of product
    44 					clc		;and add multiplicand to
    45 					adc #0		;it
    46 3568			ecx0	equ *-1
    47 					sta edx
    48 					lda edx+1
    49 					adc #0
    50 3568			ecx1	equ *-1
    51 					sta edx+1
    52 					lda edx+2
    53 					adc #0
    54 3568			ecx2	equ *-1
    55 					sta edx+2
    56 					lda edx+3
    57 					adc #0
    58 3568			ecx3	equ *-1
    59 3568			ROTATE_R  ror @		;Rotate partial product
    60 				        sta edx+3	;right
    61 				        ror edx+2
    62 				        ror edx+1
    63 				        ror edx
    64 				        ror ztmp11
    65 				        ror ztmp10
    66 				        ror ztmp9
    67 				        ror ztmp8
    68 				        dey		;Decrement bit count and
    69 				        bne SHIFT_R	;loop until 32 bits are
    70
    71 				;	mva ztmp8 eax
    72 					mva ztmp9 eax
    73 					mva ztmp10 eax+1
    74 					mva ztmp11 eax+2
    75
    76
    77 				;	mva eax+1 eax
    78 				;	mva eax+2 eax+1
    79 				;	mva eax+3 eax+2
    80
    81 					ldy edx
    82
    83 					lda :STACKORIGIN-1+STACKWIDTH*3,x	; t1
    84 					bpl @+
    85 					sec
    86 					tya
    87 					sbc :STACKORIGIN,x
    88 					tay
    89 3568			@
    90 					lda :STACKORIGIN+STACKWIDTH*3,x		; t2
    91 					bpl @+
    92 					sec
    93 					tya
    94 					sbc :STACKORIGIN-1,x
    95 					tay
    96 3568			@
    97 					sty eax+3
    98
    99 					jmp movaBX_EAX
   100 				.endp
   101
   102
   103 				/*
   104 				;32 bit multiply with 64 bit product
   105
   106 				.proc	imul64
   107
   108 					lda #$00
   109 					sta edx		;Clear upper half of
   110 					sta edx+1	;product
   111 					sta edx+2
   112 					sta edx+3
   113
   114 					sta ztmp8
   115 					sta ztmp9
   116 					sta ztmp10
   117 					sta ztmp11
   118
   119 					ldy #$20	;Set binary count to 32
   120 				SHIFT_R	lsr eax+3	;Shift multiplyer right
   121 					ror eax+2
   122 					ror eax+1
   123 					ror eax
   124 					bcc ROTATE_R	;Go rotate right if c = 0
   125 					lda edx		;Get upper half of product
   126 					clc		;and add multiplicand to
   127 					adc ecx		;it
   128 					sta edx
   129 					lda edx+1
   130 					adc ecx+1
   131 					sta edx+1
   132 					lda edx+2
   133 					adc ecx+2
   134 					sta edx+2
   135 					lda edx+3
   136 					adc ecx+3
   137 				ROTATE_R  ror @		;Rotate partial product
   138 				        sta edx+3	;right
   139 				        ror edx+2
   140 				        ror edx+1
   141 				        ror edx
   142 				        ror ztmp11
   143 				        ror ztmp10
   144 				        ror ztmp9
   145 				        ror ztmp8
   146 				        dey		;Decrement bit count and
   147 				        bne SHIFT_R	;loop until 32 bits are
   148
   149 					mva ztmp8 eax
   150 					mva ztmp9 eax+1
   151 					mva ztmp10 eax+2
   152 					mva ztmp11 eax+3
   153
   154 					rts
   155 				.endp
   156 				*/
   156
   157
   158 				; 64bit / 32bit = 32bit
   159 				; eax = eax + edx
   160
   161 3568			.proc	divREAL
   162
   163 					mva :STACKORIGIN,x ecx0
   164 					sta ecx0_
   165 					mva :STACKORIGIN+STACKWIDTH,x ecx1
   166 					sta ecx1_
   167 					mva :STACKORIGIN+STACKWIDTH*2,x ecx2
   168 					sta ecx2_
   169 					mva :STACKORIGIN+STACKWIDTH*3,x ecx3
   170
   171 					mva :STACKORIGIN-1+STACKWIDTH*3,x eax+4
   172 					mva :STACKORIGIN-1+STACKWIDTH*2,x eax+3
   173 					mva :STACKORIGIN-1+STACKWIDTH,x eax+2
   174 					mva :STACKORIGIN-1,x eax+1
   175
   176 					lda #$00
   177 					sta eax
   178 					sta eax+5
   179 					sta eax+6
   180 					sta eax+7
   181
   182 					STA ZTMP8
   183 					STA ZTMP9
   184 					STA ZTMP10
   185 					STA ZTMP11
   186
   187 					LDY #64
   188 3568			UDIV320	ASL eax
   189 					ROL eax+1
   190 					ROL eax+2
   191 					ROL eax+3
   192 					ROL eax+4
   193 					ROL eax+5
   194 					ROL eax+6
   195 					ROL eax+7
   196
   197 					ROL ZTMP8
   198 					ROL ZTMP9
   199 					ROL ZTMP10
   200 					ROL ZTMP11
   201 							;do a subtraction
   202 					LDA ZTMP8
   203 					CMP #0
   204 3568			ecx0	equ *-1
   205 					LDA ZTMP9
   206 					SBC #0
   207 3568			ecx1	equ *-1
   208 					LDA ZTMP10
   209 					SBC #0
   210 3568			ecx2	equ *-1
   211 					LDA ZTMP11
   212 					SBC #0
   213 3568			ecx3	equ *-1
   214 					BCC UDIV321
   215 				 			;overflow, do the subtraction again, this time store the result
   216 					STA ecx3	;we have the high byte already
   217 					LDA ZTMP8
   218 					SBC #0		;byte 0
   219 3568			ecx0_	equ *-1
   220 					STA ZTMP8
   221 					LDA ZTMP9
   222 					SBC #0
   223 3568			ecx1_	equ *-1
   224 					STA ZTMP9	;byte 1
   225 					LDA ZTMP10
   226 					SBC #0
   227 3568			ecx2_	equ *-1
   228 					STA ZTMP10	;byte 2
   229
   230 					INC eax		;set result bit
   231
   232 3568			UDIV321	DEY
   233 					BNE UDIV320
   234
   235 					rts
   236 				.endp
   237
   238
   239 				/*
   240 				.proc	divREAL
   241
   242 					jsr iniEAX_ECX_CARD
   243
   244 					mva eax+3 eax+4
   245 					mva eax+2 eax+3
   246 					mva eax+1 eax+2
   247 					mva eax eax+1
   248
   249 					lda #$00
   250 					sta eax
   251 					sta eax+5
   252 					sta eax+6
   253 					sta eax+7
   254
   255 					STA ZTMP8
   256 					STA ZTMP9
   257 					STA ZTMP10
   258 					STA ZTMP11
   259
   260 					LDY #64
   261 				UDIV320	ASL eax
   262 					ROL eax+1
   263 					ROL eax+2
   264 					ROL eax+3
   265 					ROL eax+4
   266 					ROL eax+5
   267 					ROL eax+6
   268 					ROL eax+7
   269
   270 					ROL ZTMP8
   271 					ROL ZTMP9
   272 					ROL ZTMP10
   273 					ROL ZTMP11
   274 							;do a subtraction
   275 					LDA ZTMP8
   276 					CMP ecx
   277 					LDA ZTMP9
   278 					SBC ecx+1
   279 					LDA ZTMP10
   280 					SBC ecx+2
   281 					LDA ZTMP11
   282 					SBC ecx+3
   283 					BCC UDIV321
   284 				 			;overflow, do the subtraction again, this time store the result
   285 					STA ecx+3	;we have the high byte already
   286 					LDA ZTMP8
   287 					SBC ecx		;byte 0
   288 					STA ZTMP8
   289 					LDA ZTMP9
   290 					SBC ecx+1
   291 					STA ZTMP9	;byte 1
   292 					LDA ZTMP10
   293 					SBC ecx+2
   294 					STA ZTMP10	;byte 2
   295
   296 					INC eax		;set result bit
   297
   298 				UDIV321	DEY
   299 					BNE UDIV320
   300
   301 					rts
   302 				.endp
   303 				*/
   303
  1255 3568				icl '6502\cpu6502_single.asm'		; mul / div -> SINGLE		IEEE-754
Source: cpu6502_single.asm
     1 				; JAVA IEEE-32 (IEEE-754)
     2 				; David Schmenk
     3 				; https://sourceforge.net/projects/vm02/
     4 				; http://vm02.cvs.sourceforge.net/viewvc/vm02/vm02/src/
     5
     6 				/*
     7 					org eax
     8
     9 				FP1MAN0	.ds 1
    10 				FP1MAN1	.ds 1
    11 				FP1MAN2	.ds 1
    12 				FP1MAN3	.ds 1
    13
    14 					org ztmp8
    15
    16 				FP1SGN	.ds 1
    17 				FP1EXP	.ds 1
    18
    19 					org edx
    20
    21 				FP2MAN0	.ds 1
    22 				FP2MAN1	.ds 1
    23 				FP2MAN2	.ds 1
    24 				FP2MAN3	.ds 1
    25
    26 					org ztmp10
    27
    28 				FP2SGN	.ds 1
    29 				FP2EXP	.ds 1
    30
    31 					org ecx
    32
    33 				FPMAN0	.ds 1
    34 				FPMAN1	.ds 1
    35 				FPMAN2	.ds 1
    36 				FPMAN3	.ds 1
    37
    38 					org bp2
    39
    40 				FPSGN	.ds 1
    41 				FPEXP	.ds 1
    42
    43 				*/
    43
    44
    45 = 008F			@rx	= bp+1
    46
    47 = 000A			MIN_EXPONENT	= 10
    48 = 00FF			MAX_EXPONENT	= 255
    49
    50
    51 3568			.proc	NEGINT
    52
    53 					LDA	#$00
    54 					SEC
    55
    56 3568			enter	SBC	FPMAN0
    57 					STA	FPMAN0
    58 					LDA	#$00
    59 					SBC	FPMAN1
    60 					STA	FPMAN1
    61 					LDA	#$00
    62 					SBC	FPMAN2
    63 					STA	FPMAN2
    64 					LDA	#$00
    65 					SBC	FPMAN3
    66 					STA	FPMAN3
    67 					RTS
    68 				.endp
    69
    70
    71 3568			.proc	FFRAC
    72 					inx
    73 					lda :STACKORIGIN-1,x
    74 					sta :STACKORIGIN,x
    75
    76 					lda :STACKORIGIN-1+STACKWIDTH,x
    77 					sta :STACKORIGIN+STACKWIDTH,x
    78
    79 					lda :STACKORIGIN-1+STACKWIDTH*2,x
    80 					sta :STACKORIGIN+STACKWIDTH*2,x
    81
    82 					lda :STACKORIGIN-1+STACKWIDTH*3,x
    83 					eor #$80
    84 					sta :STACKORIGIN+STACKWIDTH*3,x
    85
    86 					dex
    87
    88 					jsr F2I
    89 					jsr I2F
    90
    91 					lda :STACKORIGIN+STACKWIDTH*3,x
    92 					eor #$80
    93 					sta :STACKORIGIN+STACKWIDTH*3,x
    94
    95 					inx
    96
    97 					jsr FSUB
    98
    99 					dex
   100
   101 					rts
   102 				.endp
   103
   104
   105 3568			.proc	FROUND
   106 				;	LDA	#$00
   107 				;	STA	FP2SGN
   108
   109 					lda :STACKORIGIN,x
   110 					STA	FP2MAN0
   111 					lda :STACKORIGIN+STACKWIDTH,x
   112 					STA	FP2MAN1
   113 					lda :STACKORIGIN+STACKWIDTH*2,x
   114 					CMP	#$80		; SET CARRY FROM MSB
   115 					ORA	#$80		; SET HIDDEN BIT
   116 					STA	FP2MAN2
   117 					lda :STACKORIGIN+STACKWIDTH*3,x
   118 				;	EOR	FP2SGN		; TOGGLE SIGN FOR FSUB
   119 					ROL
   120 					STA	FP2EXP
   121 					LDA	#$00
   122 					STA	FPSGN
   123 					BCC	@+
   124 					SBC	FP2MAN0
   125 					STA	FP2MAN0
   126 					LDA	#$00
   127 					SBC	FP2MAN1
   128 					STA	FP2MAN1
   129 					LDA	#$00
   130 					SBC	FP2MAN2
   131 					STA	FP2MAN2
   132 					LDA	#$FF
   133 3568			@	STA	FP2MAN3
   134 					lda #$00
   135 					STA	FP1MAN0
   136 					STA	FP1MAN1
   137 					CMP	#$80		; SET CARRY FROM MSB
   138 					ORA	#$80		; SET HIDDEN BIT
   139 					STA	FP1MAN2
   140
   141 					lda :STACKORIGIN+STACKWIDTH*3,x
   142 					and #$80
   143 					ora #$3f		; 0.5 / -0.5
   144
   145 					inx
   146
   147 					jsr FSUB.enter
   148
   149 					dex
   150
   151 					rts
   152 				.endp
   153
   154
   155 3568			.proc	FSUB
   156 					LDA	#$80		; TOGGLE SIGN
   157 					BNE	@+
   158 3568			FADD:	LDA	#$00
   159 3568			@	STA	FP2SGN
   160 				;	stx @rx
   161
   162 					lda :STACKORIGIN,x
   163 					STA	FP2MAN0
   164 					lda :STACKORIGIN+STACKWIDTH,x
   165 					STA	FP2MAN1
   166 					lda :STACKORIGIN+STACKWIDTH*2,x
   167 					CMP	#$80		; SET CARRY FROM MSB
   168 					ORA	#$80		; SET HIDDEN BIT
   169 					STA	FP2MAN2
   170 					lda :STACKORIGIN+STACKWIDTH*3,x
   171 					EOR	FP2SGN		; TOGGLE SIGN FOR FSUB
   172 					ROL
   173 					STA	FP2EXP
   174 					LDA	#$00
   175 					STA	FPSGN
   176 					BCC	@+
   177 					SBC	FP2MAN0
   178 					STA	FP2MAN0
   179 					LDA	#$00
   180 					SBC	FP2MAN1
   181 					STA	FP2MAN1
   182 					LDA	#$00
   183 					SBC	FP2MAN2
   184 					STA	FP2MAN2
   185 					LDA	#$FF
   186 3568			@	STA	FP2MAN3
   187 					lda :STACKORIGIN-1,x
   188 					STA	FP1MAN0
   189 					lda :STACKORIGIN-1+STACKWIDTH,x
   190 					STA	FP1MAN1
   191 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   192 					CMP	#$80		; SET CARRY FROM MSB
   193 					ORA	#$80		; SET HIDDEN BIT
   194 					STA	FP1MAN2
   195 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   196 3568			enter	ROL
   197 					STA	FP1EXP
   198 					LDA	#$00
   199 					BCC	@+
   200 					SBC	FP1MAN0
   201 					STA	FP1MAN0
   202 					LDA	#$00
   203 					SBC	FP1MAN1
   204 					STA	FP1MAN1
   205 					LDA	#$00
   206 					SBC	FP1MAN2
   207 					STA	FP1MAN2
   208 					LDA	#$FF
   209 3568			@	STA	FP1MAN3
   210 					LDA	FP1EXP		; CALCULATE WHICH MANTISSA TO SHIFT
   211 					STA	FPEXP
   212 					SEC
   213 					SBC	FP2EXP
   214 					BEQ	FADDMAN
   215 					BCS	@+
   216 					EOR	#$FF
   217 					TAY
   218 					INY
   219 					LDA	FP2EXP
   220 					STA	FPEXP
   221 					LDA	FP1MAN3
   222 					CPY	#24		; KEEP SHIFT RANGE VALID
   223 					BCC	FP1SHFT
   224 					LDA	#$00
   225 					STA	FP1MAN3
   226 					STA	FP1MAN2
   227 					STA	FP1MAN1
   228 					STA	FP1MAN0
   229 					BEQ	FADDMAN
   230 3568			FP1SHFT:	CMP	#$80	; SHIFT FP1 DOWN
   231 					ROR
   232 					ROR	FP1MAN2
   233 					ROR	FP1MAN1
   234 					ROR	FP1MAN0
   235 					DEY
   236 					BNE	FP1SHFT
   237 					STA	FP1MAN3
   238 					JMP	FADDMAN
   239
   240 3568			@	TAY
   241 					LDA	FP2MAN3
   242 					CPY	#24		; KEEP SHIFT RANGE VALID
   243 					BCC	FP2SHFT
   244 					LDA	#$00
   245 					STA	FP2MAN3
   246 					STA	FP2MAN2
   247 					STA	FP2MAN1
   248 					STA	FP2MAN0
   249 					BEQ	FADDMAN
   250 3568			FP2SHFT:	CMP	#$80	; SHIFT FP2 DOWN
   251 					ROR
   252 					ROR	FP2MAN2
   253 					ROR	FP2MAN1
   254 					ROR	FP2MAN0
   255 					DEY
   256 					BNE	FP2SHFT
   257 					STA	FP2MAN3
   258 3568			FADDMAN:	LDA	FP1MAN0
   259 					CLC
   260 					ADC	FP2MAN0
   261 					STA	FPMAN0
   262 					LDA	FP1MAN1
   263 					ADC	FP2MAN1
   264 					STA	FPMAN1
   265 					LDA	FP1MAN2
   266 					ADC	FP2MAN2
   267 					STA	FPMAN2
   268 					LDA	FP1MAN3
   269 					ADC	FP2MAN3
   270 					STA	FPMAN3
   271 					BPL	FPNORM
   272
   273 					LDA	#$80
   274 					STA	FPSGN
   275
   276 					JSR	NEGINT
   277
   278 					jmp FPNORM
   279 				.endp
   280
   281
   282 3568			.proc	FPNORM
   283 					BEQ	FPNORMLEFT	; NORMALIZE FP, A = FPMANT3
   284 3568			FPNORMRIGHT:	INC	FPEXP
   285 					LSR
   286 					STA	FPMAN3
   287 					ROR	FPMAN2
   288 					ROR	FPMAN1
   289 					LDA	FPMAN0
   290 					ROR
   291 					ADC	#$00
   292 					STA	FPMAN0
   293 					LDA	FPMAN1
   294 					ADC	#$00
   295 					STA	FPMAN1
   296 					LDA	FPMAN2
   297 					ADC	#$00
   298 					STA	FPMAN2
   299 					LDA	FPMAN3
   300 					ADC	#$00
   301 					BNE	FPNORMRIGHT
   302 					LDA	FPEXP
   303 					ASL	FPMAN2
   304 					LSR
   305 					ORA	FPSGN
   306
   307 				;	ldx @rx
   308 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   309 					LDA	FPMAN2
   310 					ROR
   311 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   312
   313 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   314 					asl @
   315 					tay
   316 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   317 					spl
   318 					iny
   319 					cpy #MIN_EXPONENT	; to small 6.018531E-36
   320 					bcc zero
   321 					cpy #MAX_EXPONENT
   322 					beq zero		; number is infinity (if the mantissa is zero) or a NaN (if the mantissa is non-zero)
   323
   324 					LDA	FPMAN1
   325 					sta :STACKORIGIN-1+STACKWIDTH,x
   326 					LDA	FPMAN0
   327 					sta :STACKORIGIN-1,x
   328 					rts
   329
   330 3568			FPNORMLEFT:	LDA	FPMAN2
   331 					BNE	FPNORMLEFT1
   332 					LDA	FPMAN1
   333 					BNE	FPNORMLEFT8
   334 					LDA	FPMAN0
   335 					BNE	FPNORMLEFT16
   336
   337 				;	ldx @rx			; RESULT IS ZERO
   338 3568			zero	lda #0
   339
   340 					sta :STACKORIGIN-1,x
   341 					sta :STACKORIGIN-1+STACKWIDTH,x
   342 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   343 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   344 					rts
   345
   346 3568			FPNORMLEFT16:	TAY
   347 					LDA	FPEXP
   348 					SEC
   349 					SBC	#$10
   350 					STA	FPEXP
   351 					LDA	#$00
   352 					STA	FPMAN1
   353 					STA	FPMAN0
   354 					TYA
   355 					BNE	FPNORMLEFT1
   356 3568			FPNORMLEFT8:	TAY
   357 					LDA	FPMAN0
   358 					STA	FPMAN1
   359 					LDA	FPEXP
   360 					SEC
   361 					SBC	#$08
   362 					STA	FPEXP
   363 					LDA	#$00
   364 					STA	FPMAN0
   365 					TYA
   366 3568			FPNORMLEFT1:	BMI	FPNORMDONE
   367 3568			@	DEC	FPEXP
   368 					ASL	FPMAN0
   369 					ROL	FPMAN1
   370 					ROL
   371 					BPL	@-
   372 3568			FPNORMDONE:	ASL
   373 					TAY
   374 					LDA	FPEXP
   375 					LSR
   376 					ORA	FPSGN
   377
   378 				;	ldx @rx
   379 					sta :STACKORIGIN-1+STACKWIDTH*3,x
   380 					TYA
   381 					ROR
   382 					sta :STACKORIGIN-1+STACKWIDTH*2,x
   383
   384 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   385 					asl @
   386 					tay
   387 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   388 					spl
   389 					iny
   390 					cpy #MIN_EXPONENT	; to small 6.018531E-36
   391 					bcc zero
   392 					cpy #MAX_EXPONENT
   393 					beq zero		; number is infinity (if the mantissa is zero) or a NaN (if the mantissa is non-zero)
   394
   395 					LDA	FPMAN1
   396 					sta :STACKORIGIN-1+STACKWIDTH,x
   397 					LDA	FPMAN0
   398 					sta :STACKORIGIN-1,x
   399
   400 					rts
   401 				.endp
   402
   403
   404 3568			.proc	FMUL
   405
   406 					stx @rx
   407
   408 					lda :STACKORIGIN,x
   409 					STA	FP2MAN0
   410 					lda :STACKORIGIN+STACKWIDTH,x
   411 					STA	FP2MAN1
   412 					lda :STACKORIGIN+STACKWIDTH*2,x
   413 					CMP	#$80		; SET CARRY FROM MSB
   414 					ORA	#$80		; SET HIDDEN BIT
   415 					STA	FP2MAN2
   416 				 	lda :STACKORIGIN+STACKWIDTH*3,x
   417 					ROL
   418 					STA	FP2EXP
   419 					BNE	@+
   420
   421 				; MUL BY ZERO, RESULT ZERO
   422 				;	LDA	#$00
   423 3568			ZERO:	STA :STACKORIGIN-1,x
   424 					STA :STACKORIGIN-1+STACKWIDTH,x
   425 					STA :STACKORIGIN-1+STACKWIDTH*2,x
   426 					STA :STACKORIGIN-1+STACKWIDTH*3,x
   427 					rts
   428
   429 3568			@	LDA	#$00
   430 					ROR
   431 					STA	FPSGN
   432 					lda :STACKORIGIN-1,x
   433 					STA	FP1MAN0
   434 					lda :STACKORIGIN-1+STACKWIDTH,x
   435 					STA	FP1MAN1
   436 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   437 					CMP	#$80		; SET CARRY FROM MSB
   438 					ORA	#$80		; SET HIDDEN BIT
   439 					STA	FP1MAN2
   440 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   441 					ROL
   442 					STA	FP1EXP
   443 					BEQ	ZERO		; MUL BY ZERO, RESULT ZERO
   444
   445 					LDA	#$00
   446 					ROR
   447 					EOR	FPSGN
   448 					STA	FPSGN
   449 					LDA	FP1EXP
   450 					CLC			; ADD EXPONENTS
   451 					ADC	FP2EXP
   452 					SEC			; SUBTRACT BIAS
   453 					SBC	#$7F
   454 					STA	FPEXP
   455 					LDX	#$00
   456 					STX	FPMAN0
   457 					STX	FPMAN1
   458 					STX	FPMAN2
   459 					STX	FPMAN3
   460 					STX	TMP
   461 3568			FMULNEXTBYTE:	LDA	FP1MAN0,X
   462 					BNE	@+
   463 					LDX	FPMAN1		; SHORT CIRCUIT BYTE OF ZERO BITS
   464 					STX	FPMAN0
   465 					LDX	FPMAN2
   466 					STX	FPMAN1
   467 					LDX	FPMAN3
   468 					STX	FPMAN2
   469 					STA	FPMAN3
   470 					INC	TMP
   471 					LDX	TMP
   472 					CPX	#$03
   473 					BNE	FMULNEXTBYTE
   474
   475 					ldx @rx
   476 					LDA	FPMAN3
   477 					JMP	FPNORM
   478
   479 3568			@	EOR	#$FF
   480 					LDX	#$08
   481 3568			FMULTSTBITS:	LSR	FPMAN3
   482 					ROR	FPMAN2
   483 					ROR	FPMAN1
   484 					ROR	FPMAN0
   485 					LSR
   486 					BCS	FMULNEXTTST
   487 					TAY
   488 					LDA	FP2MAN0
   489 					ADC	FPMAN0
   490 					STA	FPMAN0
   491 					LDA	FP2MAN1
   492 					ADC	FPMAN1
   493 					STA	FPMAN1
   494 					LDA	FP2MAN2
   495 					ADC	FPMAN2
   496 					STA	FPMAN2
   497 					LDA	#$00
   498 					ADC	FPMAN3
   499 					STA	FPMAN3
   500 					TYA
   501 3568			FMULNEXTTST:	DEX
   502 					BNE	FMULTSTBITS
   503 					INC	TMP
   504 					LDX	TMP
   505 					CPX	#$03
   506 					BNE	FMULNEXTBYTE
   507
   508 					ldx @rx
   509 					LDA	FPMAN3
   510 					JMP	FPNORM
   511 				.endp
   512
   513
   514 3568			.proc	FDIV
   515
   516 					stx @rx
   517
   518 					lda :STACKORIGIN,x
   519 					STA	FP2MAN0
   520 					lda :STACKORIGIN+STACKWIDTH,x
   521 					STA	FP2MAN1
   522 					lda :STACKORIGIN+STACKWIDTH*2,x
   523 					CMP	#$80		; SET CARRY FROM MSB
   524 					ORA	#$80		; SET HIDDEN BIT
   525 					STA	FP2MAN2
   526 					lda :STACKORIGIN+STACKWIDTH*3,x
   527 					ROL
   528 					STA	FP2EXP
   529 					BNE	@+
   530
   531 				;	LDA	#$00
   532 3568			ZERO:	STA :STACKORIGIN-1,x
   533 					STA :STACKORIGIN-1+STACKWIDTH,x
   534 					STA :STACKORIGIN-1+STACKWIDTH*2,x
   535 					STA :STACKORIGIN-1+STACKWIDTH*3,x
   536 					rts
   537 				;	LDA	#23		; DIVIDE BY ZERO, ERROR
   538 				;	JMP	SYSTHROW
   539
   540 3568			@	LDA	#$00
   541 					ROR
   542 					STA	FPSGN
   543 					lda :STACKORIGIN-1,x
   544 					STA	FP1MAN0
   545 					lda :STACKORIGIN-1+STACKWIDTH,x
   546 					STA	FP1MAN1
   547 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   548 					CMP	#$80		; SET CARRY FROM MSB
   549 					ORA	#$80		; SET HIDDEN BIT
   550 					STA	FP1MAN2
   551 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   552 					ROL
   553 					STA	FP1EXP
   554 					BEQ	ZERO		; DIVIDE ZERO, RESULT ZERO
   555
   556 					LDA	#$00
   557 					STA	FP1MAN3
   558 					ROR
   559 					EOR	FPSGN
   560 					STA	FPSGN
   561 					LDA	FP1EXP
   562 					SEC			; SUBTRACT EXPONENTS
   563 					SBC	FP2EXP
   564 					CLC
   565 					ADC	#$7F		; ADD BACK BIAS
   566 					STA	FPEXP
   567
   568 					LDX	#24		; #BITS
   569 3568			FDIVLOOP:	LDA	FP1MAN0
   570 					SEC
   571 					SBC	FP2MAN0
   572 					STA	TMP
   573 					LDA	FP1MAN1
   574 					SBC	FP2MAN1
   575 					STA	TMP+1
   576 					LDA	FP1MAN2
   577 					SBC	FP2MAN2
   578 					TAY
   579 					LDA	FP1MAN3
   580 					SBC	#$00
   581 					BCC	FDIVNEXTBIT
   582 					STA	FP1MAN3
   583 					STY	FP1MAN2
   584 					LDA	TMP+1
   585 					STA	FP1MAN1
   586 					LDA	TMP
   587 					STA	FP1MAN0
   588 3568			FDIVNEXTBIT:	ROL	FPMAN0
   589 					ROL	FPMAN1
   590 					ROL	FPMAN2
   591 					ASL	FP1MAN0
   592 					ROL	FP1MAN1
   593 					ROL	FP1MAN2
   594 					ROL	FP1MAN3
   595 					DEX
   596 					BNE	FDIVLOOP
   597
   598 					ldx @rx
   599 					LDA	#$00
   600 					JMP	FPNORM
   601 				.endp
   602
   603
   604 3568			.proc	FCMPL
   605 3568			FCMPG:
   606 					CLV
   607
   608 					LDA	:STACKORIGIN+STACKWIDTH*3,X	; COMPARE SIGNS
   609 					AND	#$80
   610 					STA	FP2SGN
   611 					LDA	:STACKORIGIN-1+STACKWIDTH*3,X
   612 					AND	#$80
   613 					CMP	FP2SGN
   614 					BCC	FCMPGTSGN
   615 					BEQ	@+
   616 					BCS	FCMPLTSGN
   617 3568			@	LDA	:STACKORIGIN-1+STACKWIDTH*3,X	; COMPARE AS MAGNITUDE
   618 					CMP	:STACKORIGIN+STACKWIDTH*3,X
   619 					BCC	FCMPLT
   620 					BEQ	@+
   621 					BCS	FCMPGT
   622 3568			@	LDA	:STACKORIGIN-1+STACKWIDTH*2,X
   623 					CMP	:STACKORIGIN+STACKWIDTH*2,X
   624 					BCC	FCMPLT
   625 					BEQ	@+
   626 					BCS	FCMPGT
   627 3568			@	LDA	:STACKORIGIN-1+STACKWIDTH,X
   628 					CMP	:STACKORIGIN+STACKWIDTH,X
   629 					BCC	FCMPLT
   630 					BEQ	@+
   631 					BCS	FCMPGT
   632 3568			@	LDA	:STACKORIGIN-1,X
   633 					CMP	:STACKORIGIN,X
   634 					BCC	FCMPLT
   635 					BEQ	FCMPEQ
   636 					BCS	FCMPGT
   637 3568			FCMPEQ:	LDA #0			; EQUAL
   638 					RTS
   639
   640 3568			FCMPGT:	LDA	FP2SGN		; FLIP RESULT IF NEGATIVE #S
   641 					BMI	FCMPLTSGN
   642 3568			FCMPGTSGN:	LDA	#$01	; GREATER THAN
   643 					RTS
   644
   645 3568			FCMPLT:	LDA	FP2SGN		; FLIP RESULT IF NEGATIVE #S
   646 					BMI	FCMPGTSGN
   647 3568			FCMPLTSGN:	LDA	#$FF	; LESS THAN
   648 					RTS
   649 				.endp
   650
   651
   652 3568			.proc	F2I
   653
   654 					lda :STACKORIGIN,x
   655 					STA	FPMAN0
   656 					lda :STACKORIGIN+STACKWIDTH,x
   657 					STA	FPMAN1
   658 					lda :STACKORIGIN+STACKWIDTH*2,x
   659 					CMP	#$80		; SET CARRY FROM MSB
   660 					ORA	#$80		; SET HIDDEN BIT
   661 					STA	FPMAN2
   662 					lda :STACKORIGIN+STACKWIDTH*3,x
   663 					ROL	@
   664 					STA	FPEXP
   665 					LDA	#$00
   666 					ROR	@
   667 					STA	FPSGN
   668 					LDA	FPEXP		; CHECK FOR LESS THAN ONE
   669 					SEC
   670 					SBC	#$7F
   671 					BCS	@+
   672
   673 3568			ZERO:	LDA	#$00		; RETURN ZERO
   674 					STA :STACKORIGIN,x
   675 					STA :STACKORIGIN+STACKWIDTH,x
   676 					STA :STACKORIGIN+STACKWIDTH*2,x
   677 					STA :STACKORIGIN+STACKWIDTH*3,x
   678 					rts
   679
   680 3568			@	CMP	#23
   681 					BCS	F2ISHL
   682 					STA	FPEXP
   683 					LDA	#23
   684 					SEC
   685 					SBC	FPEXP
   686 					TAY			; SHIFT MANTISSA RIGHT
   687 					LDA	FPMAN2
   688 3568			F2ISHR:	LSR	@
   689 					ROR	FPMAN1
   690 					ROR	FPMAN0
   691 					DEY
   692 					BNE	F2ISHR
   693 					STA	FPMAN2
   694 					STY	FPMAN3
   695 3568			F2ICHKNEG:	LDA	FPSGN
   696 					BPL	@+		; CHECK FOR NEGATIVE
   697 					ASL	@		; LDA #$00; SEC
   698
   699 					JSR	NEGINT.enter
   700
   701 3568			@	LDA	FPMAN3
   702 					STA :STACKORIGIN+STACKWIDTH*3,x
   703 					LDA	FPMAN2
   704 					STA :STACKORIGIN+STACKWIDTH*2,x
   705 					LDA	FPMAN1
   706 					STA :STACKORIGIN+STACKWIDTH,x
   707 					LDA	FPMAN0
   708 					STA :STACKORIGIN,x
   709 					rts
   710
   711 3568			F2ISHL:	CMP	#32
   712 					BCC	@+
   713 					LDA	#$FF		; OVERFLOW, STORE MAXINT
   714 					STA	FPMAN0
   715 					STA	FPMAN1
   716 					STA	FPMAN2
   717 					LSR	@
   718 					STA	FPMAN3
   719 					BNE	F2ICHKNEG
   720 3568			@	SEC
   721 					SBC	#23
   722 					BNE	@+
   723 					STA	FPMAN3
   724 					BEQ	F2ICHKNEG
   725 3568			@	TAY			; SHIFT MANTISSA LEFT
   726 					LDA	#$00
   727 3568			@	ASL	FPMAN0
   728 					ROL	FPMAN1
   729 					ROL	FPMAN2
   730 					ROL	@
   731 					DEY
   732 					BNE	@-
   733 					STA	FPMAN3
   734 					BEQ	F2ICHKNEG
   735 				.endp
   736
   737
   738 3568			.proc	I2F
   739
   740 					lda :STACKORIGIN,x
   741 					STA	FPMAN0
   742 					lda :STACKORIGIN+STACKWIDTH,x
   743 					STA	FPMAN1
   744 					lda :STACKORIGIN+STACKWIDTH*2,x
   745 					STA	FPMAN2
   746 					lda :STACKORIGIN+STACKWIDTH*3,x
   747 					STA	FPMAN3
   748 					AND	#$80
   749 					STA	FPSGN
   750 					BPL	@+
   751 				;	LDX	#FPMAN0
   752 					JSR	NEGINT
   753 3568			@	LDA	#$7F+23
   754 					STA	FPEXP
   755
   756 					inx			; ten zabieg zapisze pod :STACKORIGIN,x
   757 								; zamiast :STACKORIGIN-1,x
   758 					LDA	FPMAN3
   759 					JSR	FPNORM
   760
   761 					dex
   762 					rts
   763 				.endp
   764
   765
   766 3568			.proc	I2F_m
   767
   768 					lda :STACKORIGIN-1,x
   769 					STA	FPMAN0
   770 					lda :STACKORIGIN-1+STACKWIDTH,x
   771 					STA	FPMAN1
   772 					lda :STACKORIGIN-1+STACKWIDTH*2,x
   773 					STA	FPMAN2
   774 					lda :STACKORIGIN-1+STACKWIDTH*3,x
   775
   776 					STA	FPMAN3
   777 					AND	#$80
   778 					STA	FPSGN
   779 					BPL	@+
   780 				;	LDX	#FPMAN0
   781 					JSR	NEGINT
   782 3568			@	LDA	#$7F+23
   783 					STA	FPEXP
   784
   785 					LDA	FPMAN3
   786 					JMP	FPNORM
   787 				.endp
  1256
  1257
  1258 3568			.proc	@printCHAR
  1259 					ldy :STACKORIGIN,x
  1260 					jmp @print
  1261 				.endp
  1262
  1263
  1264 3568			.proc	@printEOL
  1265 					ldy #eol
  1266 					jmp @print
  1267 				.endp
  1268
  1269
  1270 3568			.proc	@print (.byte y) .reg
  1271 					txa:pha
  1272
  1273 					tya
  1274 					jsr @putchar
  1275
  1276 					pla:tax
  1277 					rts
  1278 				.endp
  1279
  1280
  1281 3568			.proc	@printPCHAR (.word ya) .reg
  1282
  1283 					beq empty
  1284
  1285 					sta ztmp
  1286 					sty ztmp+1
  1287
  1288 					stx @sp
  1289
  1290 					lda #0
  1291 					sta loop+1
  1292
  1293 3568			loop	ldy #0
  1294 					lda (ztmp),y
  1295 					beq stop
  1296
  1297 					inc loop+1
  1298 					beq stop
  1299
  1300 					jsr @putchar
  1301
  1302 					jmp loop
  1303
  1304 3568			stop	ldx #0
  1305 3568			@sp	equ *-1
  1306
  1307 3568			empty	rts
  1308 				.endp
  1309
  1310
  1311 3568			.proc	@printSTRING (.word ya) .reg
  1312
  1313 					beq empty
  1314
  1315 					sta ztmp
  1316 					sty ztmp+1
  1317
  1318 					stx @sp
  1319
  1320 					ldy #0
  1321 					sty loop+1
  1322 					lda (ztmp),y
  1323 					sta ln
  1324
  1325 					inw ztmp
  1326
  1327 3568			loop	ldy #0
  1328 					lda (ztmp),y
  1329 				;	beq stop
  1330
  1331 					cpy #0
  1332 3568			ln	equ *-1
  1333 					beq stop
  1334
  1335 					inc loop+1
  1336
  1337 					jsr @putchar
  1338
  1339 					jmp loop
  1340
  1341 3568			stop	ldx #0
  1342 3568			@sp	equ *-1
  1343
  1344 3568			empty	rts
  1345 				.endp
  1346
  1347
  1348 3568			.proc	@printBOOLEAN
  1349 					lda :STACKORIGIN,x
  1350 					beq _0
  1351
  1352 3568			_1	lda <_true
  1353 					ldy >_true
  1354 					jmp @printSTRING
  1355
  1356 3568			_0	lda <_false
  1357 					ldy >_false
  1358 					jmp @printSTRING
  1359
  1360 3568			_true	dta 4,c'TRUE'
  1361 3568			_false	dta 5,c'FALSE'
  1362 				.endp
  1363
  1364
  1365 3568			.proc	mov_BYTE_DX
  1366 					mva :STACKORIGIN,x dx
  1367 					mva #$00 dx+1
  1368 					sta dx+2
  1369 					sta dx+3
  1370
  1371 					rts
  1372 				.endp
  1373
  1374 3568			.proc	mov_WORD_DX
  1375 					mva :STACKORIGIN,x dx
  1376 					mva :STACKORIGIN+STACKWIDTH,x dx+1
  1377 					mva #$00 dx+2
  1378 					sta dx+3
  1379
  1380 					rts
  1381 				.endp
  1382
  1383 3568			.proc	mov_CARD_DX
  1384 					mva :STACKORIGIN,x dx
  1385 					mva :STACKORIGIN+STACKWIDTH,x dx+1
  1386 					mva :STACKORIGIN+STACKWIDTH*2,x dx+2
  1387 					mva :STACKORIGIN+STACKWIDTH*3,x dx+3
  1388
  1389 					rts
  1390 				.endp
  1391
  1392
  1393 3568			.proc	@printMINUS
  1394 					ldy #'-'
  1395 					jsr @printVALUE.pout
  1396
  1397 					jmp negCARD
  1398 				.endp
  1399
  1400
  1401 3568			.proc	@printSHORTREAL
  1402 					jsr @expandToCARD.SMALL
  1403 					jmp @printREAL
  1404 				.endp
  1405
  1406
  1407 3568			.proc	@FTOA
  1408
  1409 = 0086			i	= edx
  1410 = 008A			fra	= ecx
  1411 = 0082			hlp	= eax
  1412
  1413 = 0092			exp	= ztmp
  1414 = 0093			b	= ztmp+1
  1415 = 0094			sht	= ztmp+2
  1416
  1417 = 0440			bit	= @buf+64
  1418
  1419 					stx @sp
  1420
  1421 					mva :STACKORIGIN,x I
  1422 					sta :STACKORIGIN+9
  1423 					mva :STACKORIGIN+STACKWIDTH,x I+1
  1424 					sta :STACKORIGIN+STACKWIDTH+9
  1425 					mva :STACKORIGIN+STACKWIDTH*2,x I+2
  1426 					sta :STACKORIGIN+STACKWIDTH*2+9
  1427 					mva :STACKORIGIN+STACKWIDTH*3,x I+3
  1428 					sta :STACKORIGIN+STACKWIDTH*3+9	; Sign
  1429
  1430 					bpl skp
  1431
  1432 					ldy #'-'
  1433 					jsr @printVALUE.pout
  1434
  1435 3568			skp
  1436 				; optimize OK (test_3.pas), line = 32
  1437
  1438 					lda :STACKORIGIN+STACKWIDTH*3+9
  1439 					asl :STACKORIGIN+9
  1440 					rol :STACKORIGIN+STACKWIDTH+9
  1441 					rol :STACKORIGIN+STACKWIDTH*2+9
  1442 					rol @
  1443 					sta EXP				; Exponent
  1444
  1445 				; optimize OK (test_3.pas), line = 33
  1446
  1447 					lda I
  1448 					sta FRA
  1449 					lda I+1
  1450 					sta FRA+1
  1451 					lda I+2
  1452 					sta FRA+2
  1453 					lda I+3
  1454 					sta FRA+3
  1455 					asl FRA
  1456 					rol FRA+1
  1457 					rol FRA+2
  1458 					rol FRA+3
  1459
  1460 				; optimize OK (test_3.pas), line = 35
  1461
  1462 					lda EXP
  1463 					sub #$7F
  1464 					sta SHT
  1465
  1466 				; optimize OK (test_3.pas), line = 37
  1467
  1468 					ldx #$3f
  1469 					lda #0
  1470 					sta:rpl bit,x-
  1471
  1472 				; For
  1473
  1474 				; optimize OK (test_3.pas), line = 39
  1475
  1476 				;	sta B
  1477 					tax
  1478
  1479 				; optimize OK (test_3.pas), line = 39
  1480
  1481 3568			l_01D4
  1482 				;	lda B
  1483 				;	cmp #$17
  1484 					cpx #$17
  1485 					bcc *+7
  1486 					beq *+5
  1487
  1488 				; ForToDoProlog
  1489 					jmp l_01EE
  1490
  1491 				; optimize OK (test_3.pas), line = 40
  1492
  1493 				;	lda #$20
  1494 				;	add B
  1495 				;	tax
  1496
  1497 					lda FRA+2
  1498 					sta BIT+$20,x
  1499
  1500 				; optimize OK (test_3.pas), line = 41
  1501
  1502 					asl FRA
  1503 					rol FRA+1
  1504 					rol FRA+2
  1505 					rol FRA+3
  1506
  1507 				; ForToDoEpilog
  1508 3568			c_01D4
  1509 				;	inc B
  1510 					inx
  1511
  1512 					seq
  1513
  1514 				; WhileDoEpilog
  1515 					jmp l_01D4
  1516 3568			l_01EE
  1517 3568			b_01D4
  1518
  1519 				; optimize OK (test_3.pas), line = 44
  1520
  1521 					mva #$80 BIT+$1f
  1522
  1523 				; optimize OK (test_3.pas), line = 46
  1524
  1525 					mva #$00 I
  1526 					sta I+1
  1527 					sta I+2
  1528 					sta I+3
  1529
  1530 				; optimize OK (test_3.pas), line = 47
  1531
  1532 					sta FRA+1
  1533 					sta FRA+2
  1534 					sta FRA+3
  1535
  1536 					mva #$01 FRA
  1537
  1538 				; For
  1539
  1540 				; optimize OK (test_3.pas), line = 49
  1541
  1542 					lda SHT
  1543 					add #$1F
  1544 					sta B
  1545
  1546 				; optimize OK (test_3.pas), line = 49
  1547
  1548 					tay
  1549
  1550 3568			l_035B
  1551 				;	lda B
  1552 				;	cmp #$00
  1553 				;	bcs *+5
  1554
  1555 				; ForToDoProlog
  1556 				;	jmp l_0375
  1557
  1558 				; optimize OK (test_3.pas), line = 50
  1559
  1560 				;	ldy B
  1561 					lda BIT,y
  1562 					bpl l_03D7
  1563
  1564 				; optimize OK (test_3.pas), line = 50
  1565
  1566 					lda I				; Mantissa
  1567 					add FRA
  1568 					sta I
  1569 					lda I+1
  1570 					adc FRA+1
  1571 					sta I+1
  1572 					lda I+2
  1573 					adc FRA+2
  1574 					sta I+2
  1575 					lda I+3
  1576 					adc FRA+3
  1577 					sta I+3
  1578
  1579 				; IfThenEpilog
  1580 3568			l_03D7
  1581
  1582 				; optimize OK (test_3.pas), line = 52
  1583
  1584 					asl FRA
  1585 					rol FRA+1
  1586 					rol FRA+2
  1587 					rol FRA+3
  1588
  1589 				; ForToDoEpilog
  1590 3568			c_035B
  1591 				;	dec B
  1592 					dey
  1593
  1594 				;	lda B
  1595 				;	cmp #$ff
  1596 					cpy #$ff
  1597 					seq
  1598
  1599 				; WhileDoEpilog
  1600 					jmp l_035B
  1601 3568			l_0375
  1602 3568			b_035B
  1603
  1604 				; optimize OK (test_3.pas), line = 55
  1605
  1606 					mva #$00 FRA
  1607 					sta FRA+1
  1608 					sta FRA+2
  1609 					sta FRA+3
  1610
  1611 				; optimize OK (test_3.pas), line = 56
  1612
  1613 					sta EXP
  1614
  1615 					sta hlp
  1616 					sta hlp+1
  1617
  1618 					lda #$80
  1619 					sta hlp+2
  1620 				; For
  1621
  1622 				; optimize OK (test_3.pas), line = 58
  1623
  1624 					lda SHT
  1625 					add #$20
  1626 				;	sta B
  1627
  1628 					tay
  1629
  1630 				; optimize OK (test_3.pas), line = 58
  1631
  1632 					add #23
  1633 					sta FORTMP_1273
  1634 				; To
  1635 3568			l_0508
  1636
  1637 				; ForToDoCondition
  1638
  1639 				; optimize OK (test_3.pas), line = 58
  1640
  1641 				;	lda B
  1642 				;	cmp #0
  1643 					cpy #0
  1644 3568			FORTMP_1273	equ *-1
  1645 					bcc *+7
  1646 					beq *+5
  1647
  1648 				; ForToDoProlog
  1649 					jmp l_0534
  1650
  1651 				; optimize OK (test_3.pas), line = 59
  1652
  1653 				;	ldy B
  1654 					lda BIT,y
  1655 					bpl l_0596
  1656
  1657 				; optimize OK (test_3.pas), line = 59
  1658
  1659 					lda FRA
  1660 					add hlp
  1661 					sta FRA
  1662 					lda FRA+1
  1663 					adc hlp+1
  1664 					sta FRA+1
  1665 					lda FRA+2
  1666 					adc hlp+2
  1667 					sta FRA+2
  1668
  1669 				; IfThenEpilog
  1670 3568			l_0596
  1671
  1672 					lsr hlp+2
  1673 					ror hlp+1
  1674 					ror hlp
  1675
  1676 				; ForToDoEpilog
  1677 3568			c_0508
  1678 				;	inc B						; inc ptr byte [CounterAddress]
  1679 					iny
  1680
  1681 					seq
  1682
  1683 				; WhileDoEpilog
  1684 					jmp l_0508
  1685 3568			l_0534
  1686 3568			b_0508
  1687 3568				:3 mva fra+# fracpart+#
  1688
  1689 					mva #6 @float.afterpoint	; wymagana liczba miejsc po przecinku
  1690 					@float #500000
  1691
  1692 					ldx #0
  1693 3568			@sp	equ *-1
  1694
  1695 					rts
  1696 				.endp
  1697
  1698
  1699 3568			.proc	@printREAL
  1700
  1701 					stx @sp
  1702
  1703 					lda :STACKORIGIN+STACKWIDTH*3,x
  1704 					spl
  1705 					jsr @printMINUS
  1706
  1707 					jsr mov_CARD_DX
  1708
  1709 					mva dx+1 intpart		; intpart := uvalue shr 8
  1710 					mva dx+2 intpart+1
  1711 					mva dx+3 intpart+2
  1712 					mva #$00 intpart+3
  1713
  1714 					sta dx+3			; fracpart := uvalue and $FF (dx)
  1715 					sta dx+2
  1716 					sta dx+1
  1717
  1718 					sta fracpart
  1719 					sta fracpart+1
  1720
  1721 					lda dx
  1722 					sta fracpart+2
  1723
  1724 3568				:4 mva intpart+# dx+#		; integer part
  1725
  1726 					mva #4 @float.afterpoint		; wymagana liczba miejsc po przecinku
  1727 					@float #5000
  1728
  1729 					ldx #0
  1730 3568			@sp	equ *-1
  1731 					rts
  1732
  1733 3568 00 00 00 00		intpart		.dword
  1734
  1735 				.endp
  1736
  1737
  1738 356C			.proc	@float (.long axy) .reg
  1739
  1740 					sty cx
  1741 					stx cx+1
  1742 					sta cx+2
  1743
  1744 					lda @printVALUE.pout		; print integer part
  1745 					pha
  1746 					jsr @printVALUE
  1747 					pla
  1748 					sta @printVALUE.pout
  1749
  1750 					lda #0
  1751 					sta dx
  1752 					sta dx+1
  1753 					sta dx+2
  1754 					sta dx+3
  1755
  1756 356C			loop	lda fracpart+2
  1757 					bpl skp
  1758
  1759 					clc
  1760 				;	lda cx
  1761 				;	spl
  1762 				;	sec
  1763
  1764 					lda dx
  1765 					adc cx
  1766 					sta dx
  1767 					lda dx+1
  1768 					adc cx+1
  1769 					sta dx+1
  1770 					lda dx+2
  1771 					adc cx+2
  1772 					sta dx+2
  1773 				;	lda dx+3
  1774 				;	adc #0
  1775 				;	sta dx+3
  1776
  1777 356C			skp	lsr cx+2
  1778 					ror cx+1
  1779 					ror cx
  1780
  1781 					asl fracpart
  1782 					rol fracpart+1
  1783 					rol fracpart+2
  1784
  1785 					lda cx
  1786 					ora cx+1
  1787 					ora cx+2
  1788
  1789 					bne loop
  1790
  1791 					ldy #'.'
  1792 					jsr @printVALUE.pout
  1793
  1794 356C				:4 mva dx+# fracpart+#
  1795
  1796 					lda @printVALUE.pout
  1797 					pha
  1798
  1799 					lda #{rts}
  1800 					sta @printVALUE.pout
  1801 					jsr @printVALUE			; floating part length
  1802
  1803 					sta cnt
  1804
  1805 					pla
  1806 					sta @printVALUE.pout
  1807
  1808 356C			lp	lda #0
  1809 356C			cnt	equ *-1
  1810 					cmp #4				; N miejsc po przecinku
  1811 356C			afterpoint equ *-1
  1812 					bcs ok
  1813
  1814 					ldy #'0'
  1815 					jsr @printVALUE.pout
  1816
  1817 					inc cnt
  1818 					bne lp
  1819
  1820 356C			ok	:4 mva fracpart+# dx+#
  1821 					jmp @printVALUE			; print floating part
  1822
  1823 				.endp
  1824
  1825
  1826 356C			.proc	@printSHORTINT
  1827
  1828 					lda :STACKORIGIN,x
  1829 					spl
  1830 					jsr @printMINUS
  1831
  1832 					jmp @printBYTE
  1833 				.endp
  1834
  1835
  1836 356C			.proc	@printSMALLINT
  1837
  1838 					lda :STACKORIGIN+STACKWIDTH,x
  1839 					spl
  1840 					jsr @printMINUS
  1841
  1842 					jmp @printWORD
  1843 				.endp
  1844
  1845
  1846 356C			.proc	@printINT
  1847
  1848 					lda :STACKORIGIN+STACKWIDTH*3,x
  1849 					spl
  1850 					jsr @printMINUS
  1851
  1852 					jmp @printCARD
  1853 				.endp
  1854
  1855
  1856 356C			.proc	@printCARD
  1857 					jsr mov_CARD_DX
  1858 					jmp @printVALUE
  1859 				.endp
  1860
  1861
  1862 356C			.proc	@printWORD
  1863 					jsr mov_WORD_DX
  1864 					jmp @printVALUE
  1865 				.endp
  1866
  1867
  1868 356C			.proc	@printBYTE
  1869 					jsr mov_BYTE_DX
  1870 					jmp @printVALUE
  1871 				.endp
  1872
  1873
  1874 356C			.proc	@printVALUE
  1875
  1876 					lda dx+3
  1877 					bne _32bit
  1878
  1879 					lda dx+2
  1880 					bne _24bit
  1881
  1882 					lda dx+1
  1883 					bne _16bit
  1884
  1885 356C			_8bit	lda #3
  1886 					bne l3
  1887
  1888 356C			_16bit	lda #5
  1889 					bne l3
  1890
  1891 356C			_24bit	lda #8
  1892 					bne l3
  1893
  1894 					; prints a 32 bit value to the screen (Graham)
  1895
  1896 356C			_32bit	lda #10
  1897
  1898 356C			l3	sta limit
  1899
  1900 					stx @sp
  1901
  1902 					ldx #0
  1903 					stx cnt
  1904
  1905 356C			lp	jsr div10
  1906
  1907 					sta tmp,x
  1908 					inx
  1909 					cpx #10
  1910 356C			limit	equ *-1
  1911 					bne lp
  1912
  1913 					;ldx #9
  1914 					dex
  1915
  1916 356C			l1	lda tmp,x
  1917 					bne l2
  1918 					dex		; skip leading zeros
  1919 					bne l1
  1920
  1921 356C			l2	lda tmp,x
  1922 					ora #$30
  1923 					tay
  1924
  1925 					jsr pout
  1926 					inc cnt
  1927
  1928 					dex
  1929 					bpl l2
  1930
  1931 					mva #{jmp*} pout
  1932
  1933 					lda #0
  1934 356C			cnt	equ *-1
  1935
  1936 					ldx #0
  1937 356C			@sp	equ *-1
  1938 					rts
  1939
  1940 356C			pout	jmp @print
  1941
  1942 					sty @buf+1
  1943 356C			pbuf	equ *-2
  1944 					inc pbuf
  1945
  1946 					rts
  1947
  1948 356C			tmp	.byte 0,0,0,0,0,0,0,0,0,0
  1949
  1950 				.endp
  1951
  1952
  1953 				; divides a 32 bit value by 10
  1954 				; remainder is returned in akku
  1955
  1956 356C			.proc	div10
  1957 				        ldy #32		; 32 bits
  1958 				        lda #0
  1959 				        clc
  1960 356C			l4      rol @
  1961 				        cmp #10
  1962 				        bcc skip
  1963 				        sbc #10
  1964 356C			skip    rol dx
  1965 				        rol dx+1
  1966 				        rol dx+2
  1967 				        rol dx+3
  1968 				        dey
  1969 				        bpl l4
  1970
  1971 					rts
  1972 				.endp
  1973
  1974
  1975 356C			.proc	@hexStr
  1976
  1977 = 0086			Value	= edx
  1978 = 008A			Digits	= ecx
  1979
  1980 					ldx Digits
  1981 					cpx #32
  1982 					scc
  1983 					ldx #32
  1984
  1985 					stx Digits
  1986
  1987 					lda Value
  1988 					jsr hex
  1989 					lda Value+1
  1990 					jsr hex
  1991 					lda Value+2
  1992 					jsr hex
  1993 					lda Value+3
  1994 					jsr hex
  1995
  1996 					lda Digits
  1997 					sta @buf
  1998 					rts
  1999
  2000 356C			hex	pha
  2001 					and #$f
  2002 					jsr put
  2003 					pla
  2004 356C				:4 lsr @
  2005 356C			put	tay
  2006 					lda thex,y
  2007 					sta @buf,x
  2008 					dex
  2009 					rts
  2010
  2011 356C			thex	dta c'0123456789ABCDEF'
  2012 				.endp
  2013
  2014
  2015 356C			.proc	@ValueToStr (.word ya) .reg
  2016
  2017 					sta adr
  2018 					sty adr+1
  2019
  2020 					mva #{bit*} @printVALUE.pout
  2021 					mva <@buf+1 @printVALUE.pbuf
  2022
  2023 					jsr $ffff
  2024 356C			adr	equ *-2
  2025
  2026 					ldy @printVALUE.pbuf
  2027 					dey
  2028 					sty @buf
  2029
  2030 					rts
  2031 				.endp
  2032
  2033
  2034 				;	ecx	isSign
  2035 				;	edx	Result
  2036
  2037 356C			.proc	@StrToInt (.word ya) .reg
  2038
  2039 					sta bp2
  2040 					sty bp2+1
  2041
  2042 					ldy #0
  2043 					sty MAIN.SYSTEM.IOResult
  2044 					sty edx
  2045 					sty edx+1
  2046 					sty edx+2
  2047 					sty edx+3
  2048
  2049 					lda (bp2),y
  2050 					beq stop
  2051 					sta len
  2052
  2053 					inw bp2
  2054
  2055 					lda (bp2),y
  2056 					cmp #'-'
  2057 					sne
  2058 					iny
  2059
  2060 					sty ecx
  2061
  2062 356C			l1	lda (bp2),y
  2063
  2064 					CLC
  2065 					ADC #$FF-'9'	; make m = $FF
  2066 					ADC #'9'-'0'+1	; carry set if in range n to m
  2067 					bcs ok
  2068
  2069 					lda #106	; Invalid numeric format
  2070 					sta MAIN.SYSTEM.IOResult
  2071
  2072 					rts		; reg Y contains the index of the character in S which prevented the conversion
  2073
  2074 356C			ok	jsr fmul10
  2075
  2076 					lda (bp2),y
  2077 					sub #$30
  2078 					sta ztmp
  2079
  2080 					lda #$00
  2081 					sta ztmp+1
  2082 					sta ztmp+2
  2083 					sta ztmp+3
  2084
  2085 					jsr fmul10.add32bit
  2086
  2087 					iny
  2088 					cpy #0
  2089 356C			len	equ *-1
  2090 					bne l1
  2091
  2092 					lda ecx
  2093 					beq stop
  2094
  2095 					jsr negEDX
  2096
  2097 356C			stop	ldy #0		; reg Y = 0 conversion successful
  2098 					rts
  2099 				.endp
  2100
  2101
  2102 356C			.proc	negEDX
  2103 					lda #$00	; minus
  2104 					sub edx
  2105 					sta edx
  2106
  2107 					lda #$00
  2108 					sbc edx+1
  2109 					sta edx+1
  2110
  2111 					lda #$00
  2112 					sbc edx+2
  2113 					sta edx+2
  2114
  2115 					lda #$00
  2116 					sbc edx+3
  2117 					sta edx+3
  2118
  2119 					rts
  2120 				.endp
  2121
  2122
  2123 356C			.proc	fmul10
  2124 					asl edx		;multiply by 2
  2125 					rol edx+1	;temp store in ZTMP
  2126 					rol edx+2
  2127 					rol edx+3
  2128
  2129 					lda edx
  2130 					sta ztmp
  2131 					lda edx+1
  2132 					sta ztmp+1
  2133 					lda edx+2
  2134 					sta ztmp+2
  2135 					lda edx+3
  2136 					sta ztmp+3
  2137
  2138 					asl edx
  2139 					rol edx+1
  2140 					rol edx+2
  2141 					rol edx+3
  2142
  2143 					asl edx
  2144 					rol edx+1
  2145 					rol edx+2
  2146 					rol edx+3
  2147
  2148 356C			add32bit
  2149 					lda edx
  2150 					add ztmp
  2151 					sta edx
  2152 					lda edx+1
  2153 					adc ztmp+1
  2154 					sta edx+1
  2155 					lda edx+2
  2156 					adc ztmp+2
  2157 					sta edx+2
  2158 					lda edx+3
  2159 					adc ztmp+3
  2160 					sta edx+3
  2161
  2162 					rts
  2163 				.endp
  2164
  2165
  2166 356C			.proc	@trunc
  2167
  2168 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2169 					spl
  2170 					jsr negCARD
  2171
  2172 					mva :STACKORIGIN+STACKWIDTH,x :STACKORIGIN,x
  2173 					mva :STACKORIGIN+STACKWIDTH*2,x :STACKORIGIN+STACKWIDTH,x
  2174 					mva :STACKORIGIN+STACKWIDTH*3,x :STACKORIGIN+STACKWIDTH*2,x
  2175 					mva #$00 :STACKORIGIN+STACKWIDTH*3,x
  2176
  2177 					tya
  2178 					spl
  2179 					jsr negCARD
  2180
  2181 					rts
  2182 				.endp
  2183
  2184
  2185 356C			.proc	@round
  2186
  2187 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2188 					spl
  2189 					jsr negCARD
  2190
  2191 					lda :STACKORIGIN,x
  2192 				//	add #$80
  2193 					cmp #$80
  2194 					lda :STACKORIGIN+STACKWIDTH,x
  2195 					adc #0
  2196 					sta :STACKORIGIN,x
  2197 					lda :STACKORIGIN+STACKWIDTH*2,x
  2198 					adc #0
  2199 					sta :STACKORIGIN+STACKWIDTH,x
  2200 					lda :STACKORIGIN+STACKWIDTH*3,x
  2201 					adc #0
  2202 					sta :STACKORIGIN+STACKWIDTH*2,x
  2203
  2204 					mva #$00 :STACKORIGIN+STACKWIDTH*3,x
  2205
  2206 					tya
  2207 					spl
  2208 					jsr negCARD
  2209
  2210 					rts
  2211 				.endp
  2212
  2213
  2214 356C			.proc	@frac
  2215
  2216 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2217 					spl
  2218 					jsr negCARD
  2219
  2220 					lda #$00
  2221 					sta :STACKORIGIN+STACKWIDTH,x
  2222 					sta :STACKORIGIN+STACKWIDTH*2,x
  2223 					sta :STACKORIGIN+STACKWIDTH*3,x
  2224
  2225 					tya
  2226 					spl
  2227 					jsr negCARD
  2228
  2229 					rts
  2230 				.endp
  2231
  2232
  2233 356C			.proc	@int
  2234
  2235 					ldy :STACKORIGIN+STACKWIDTH*3,x
  2236 					spl
  2237 					jsr negCARD
  2238
  2239 					lda #$00
  2240 					sta :STACKORIGIN,x
  2241
  2242 					tya
  2243 					spl
  2244 					jsr negCARD
  2245
  2246 					rts
  2247 				.endp
  2248
  2249
  2250 				;----------------------------;
  2251 				; Biblioteka procedur        ;
  2252 				; graficznych                ;
  2253 				;----------------------------;
  2254 				; Autorzy:                   ;
  2255 				;  Slawomir 'SERO' Ritter,   ;
  2256 				;  Jakub Cebula,             ;
  2257 				;  Winfried Hofacker         ;
  2258 				;----------------------------;
  2259 				; Wersja:1.1 DATA:09.01.2008 ;
  2260 				;----------------------------;
  2261
  2262 = 0003			@open	= $03		; Otworz kanal
  2263 = 000C			@close	= $0c		; Zamknij kanal
  2264
  2265 = 0007			@IDget	= $07		; Narysuj punkt
  2266 = 0009			@IDput	= $09		; Narysuj punkt
  2267 = 0011			@IDdraw	= $11		; Narysuj linie
  2268 = 0012			@IDfill	= $12		; Wypelnij obszar
  2269
  2270
  2271 				;------------------------;
  2272 				;Wy:.Y-numer bledu (1-OK);
  2273 				;   f(N)=1-wystapil blad ;
  2274 				;------------------------;
  2275 356C			.proc	@COMMAND
  2276
  2277 					ldx	#$00
  2278 356C			scrchn	equ *-1
  2279
  2280 					sta	iocom,x
  2281
  2282 					lda	#$00
  2283 356C			colscr	equ *-1
  2284 					sta	atachr
  2285
  2286 					jmp	ciov
  2287 				.endp
  2288
  2289 				;------------------------;
  2290 				; Ustaw tryb ekranu      ;
  2291 				;------------------------;
  2292 				;We:.X-numer kanalu      ;
  2293 				;      (normalnie 0)     ;
  2294 				;   .Y-numer trybu (O.S.);
  2295 				;   .A-Ustawiony bit nr :;
  2296 				;     5-Nie kasowanie    ;
  2297 				;       pamieci ekranu   ;
  2298 				;     4-Obecnosc okna    ;
  2299 				;       tekstowego       ;
  2300 				;     2-Odczyt z ekranu  ;
  2301 				;------------------------;
  2302 				;Wy:SCRCHN-numer kanalu  ;
  2303 				;  .Y-numer bledu (1-OK) ;
  2304 				;   f(N)=1 wystapil blad ;
  2305 				;------------------------;
  2306 356C			@GRAPHICS .proc (.byte x,y,a) .reg
  2307
  2308 					sta	byte1
  2309 					sty	byte2
  2310
  2311 					stx	@COMMAND.scrchn
  2312
  2313 					lda	#@close
  2314 					jsr	xcio
  2315
  2316 					lda	#0		; =opcje
  2317 356C			byte1	equ	*-1
  2318 					ora	#8		; +zapis na ekranie
  2319 					sta	ioaux1,x
  2320
  2321 					lda	#0
  2322 356C			byte2	equ	*-1
  2323 					sta	ioaux2,x	;=nr.trybu
  2324
  2325 					mwa	#sname	ioadr,x
  2326
  2327 					lda	#@open
  2328
  2329 356C			xcio	sta iocom,x
  2330 					jmp ciov
  2331
  2332 356C			sname	dta c'S:',$9b
  2333
  2334 					.endp
  2335
  2336
  2337 356C			.proc	@ata2int
  2338 				        asl
  2339 				        php
  2340 				        cmp #2*$60
  2341 				        bcs @+
  2342 				        sbc #2*$20-1
  2343 				        bcs @+
  2344 				        adc #2*$60
  2345 356C			@       plp
  2346 				        ror
  2347 					rts
  2348 				.endp
  2349
  2350
  2351 				/*
  2352 				  PUT CHAR
  2353
  2354 				  Procedura wyprowadza znak na ekran na pozycji X/Y kursora okreslonej przez zmienne odpowiednio
  2355 				  COLCRS ($55-$56) i ROWCRS ($54). Zaklada sie, ze obowiazuja przy tym domyslne ustawienia OS-u,
  2356 				  to jest ekran jest w trybie Graphics 0, a kanal IOCB 0 jest otwarty dla edytora ekranowego.
  2357
  2358 				  Wyprowadzenie znaku polega na zaladowaniu jego kodu ATASCII do akumulatora i wykonaniu rozkazu
  2359 				  JSR PUTCHR.
  2360 				*/
  2360
  2361
  2362 356C			.proc	@putchar (.byte a) .reg
  2363
  2364 356C			vbxe	bit *
  2365
  2366 					ldx #$00
  2367 					.ifdef MAIN.CRT.TextAttr
  2368 					ora MAIN.CRT.TextAttr
  2369 					.endif
  2370 					tay
  2371 					lda icputb+1,x
  2372 					pha
  2373 					lda icputb,x
  2374 					pha
  2375 					tya
  2376
  2377 					rts
  2378
  2379 				.endp
  2380
  2381
  2382 				/*
  2383 				  GETLINE
  2384
  2385 				  Program czeka, az uzytkownik wpisze ciag znakw z klawiatury i nacisnie klawisz RETURN.
  2386 				  Znaki podczas wpisywania sa wyswietlane na ekranie, dzialaja tez normalne znaki kontrolne
  2387 				  (odczyt jest robiony z edytora ekranowego).
  2388
  2389 				  Wywolanie funkcji polega na zaladowaniu adresu, pod jaki maja byc wpisane znaki,
  2390 				  do rejestrw A/Y (mlodszy/starszy) i wykonaniu rozkazu JSR GETLINE.
  2391
  2392 				*/
  2392
  2393
  2394 356C			.proc	@GetLine
  2395
  2396 					stx @sp
  2397
  2398 					ldx #0
  2399
  2400 					stx MAIN.SYSTEM.EoLn
  2401
  2402 					mwa	#@buf+1	icbufa,x
  2403
  2404 					mwa	#$ff	icbufl,x	; maks. wielkosc tekstu
  2405
  2406 					mva	#$05	iccmd,x
  2407
  2408 					jsr	ciov
  2409
  2410 					dew icbufl
  2411 					mva icbufl @buf			; length
  2412
  2413 					ldx @buf+1
  2414 					cpx #EOL
  2415 					bne skp
  2416
  2417 					ldx #TRUE
  2418 					stx MAIN.SYSTEM.EoLn
  2419 356C			skp
  2420 					ldx #0
  2421 356C			@sp	equ *-1
  2422
  2423 					rts
  2424 				.endp
  2425
  2426
  2427 356C			.proc	@GetKey
  2428
  2429 356C			getk	lda kbcodes	; odczytaj kbcodes
  2430 					cmp #255		; czy jest znak?
  2431 					beq getk	; nie: czekaj
  2432 					ldy #255		; daj zna, e klawisz
  2433 					sty kbcodes	; zosta odebrany
  2434 					tay		; kod klawisza jako indeks
  2435 					lda (keydef),y	; do tablicy w ROM-ie
  2436
  2437 					rts
  2438 				.endp
  2439
  2440
  2441 356C			.proc	@moveSTRING (.word ya) .reg
  2442
  2443 					sta @move.dst
  2444 					sty @move.dst+1
  2445
  2446 					mva :STACKORIGIN,x @move.src
  2447 					mva :STACKORIGIN+STACKWIDTH,x @move.src+1
  2448
  2449 					ldy #$00
  2450 					lda (@move.src),y
  2451 					add #1
  2452 					sta @move.cnt
  2453 					scc
  2454 					iny
  2455 					sty @move.cnt+1
  2456
  2457 					jmp @move
  2458 				.endp
  2459
  2460
  2461 356C			.proc	@moveSTRING_1 (.word ya) .reg
  2462
  2463 					sta @move.dst
  2464 					sty @move.dst+1
  2465
  2466 					mva :STACKORIGIN,x @move.src
  2467 					mva :STACKORIGIN+STACKWIDTH,x @move.src+1
  2468
  2469 					ldy #$00
  2470 					lda (@move.src),y
  2471 				;	add #1
  2472 					sta @move.cnt
  2473 					sty @move.cnt+1
  2474
  2475 					inw @move.src
  2476
  2477 					jmp @move
  2478 				.endp
  2479
  2480
  2481 				; Ullrich von Bassewitz, 2003-08-20
  2482 				; Performance increase (about 20%) by
  2483 				; Christian Krueger, 2009-09-13
  2484
  2485 356C			.proc	@moveu		; assert Y = 0
  2486
  2487 = 0086			ptr1	= edx
  2488 = 008A			ptr2	= ecx
  2489 = 0082			ptr3	= eax
  2490
  2491 356C 8E 95 35			stx @sp
  2492
  2493 356F A0 00			ldy	#0
  2494
  2495 3571 A6 83			ldx     ptr3+1		; Get high byte of n
  2496 3573 F0 13			beq     L2		; Jump if zero
  2497
  2498 				L1:     .rept 2		; Unroll this a bit to make it faster...
  2499 					LDA     (PTR1),Y	
  2500 					STA     (PTR2),Y
  2501 					INY
  2502 					.ENDR
  2502 					.endr
Source: REPT
  2499 3575 B1 86			LDA     (PTR1),Y	
  2499 3577 91 8A			STA     (PTR2),Y
  2499 3579 C8				INY
  2499 357A B1 86			LDA     (PTR1),Y	
  2499 357C 91 8A			STA     (PTR2),Y
  2499 357E C8				INY
Source: cpu6502.asm
  2503
  2504 357F D0 F4			bne     L1
  2505 3581 E6 87			inc     ptr1+1
  2506 3583 E6 8B			inc     ptr2+1
  2507 3585 CA				dex			; Next 256 byte block
  2508 3586 D0 ED			bne	L1		; Repeat if any
  2509
  2510 					; the following section could be 10% faster if we were able to copy
  2511 					; back to front - unfortunately we are forced to copy strict from
  2512 					; low to high since this function is also used for
  2513 					; memmove and blocks could be overlapping!
  2514 					; {
  2515 3588			L2:				; assert Y = 0
  2516 3588 A6 82			ldx     ptr3		; Get the low byte of n
  2517 358A F0 08			beq     done		; something to copy
  2518
  2519 358C B1 86		L3:     lda     (ptr1),Y	; copy a byte
  2520 358E 91 8A			sta     (ptr2),Y
  2521 3590 C8				iny
  2522 3591 CA				dex
  2523 3592 D0 F8			bne     L3
  2524
  2525 					; }
  2526
  2527 3594 A2 00		done	ldx #0
  2528 = 3595			@sp	equ *-1
  2529 3596 60				rts
  2530 				.endp
  2531
  2532
  2533 3597			@move	.proc (.word ptr1, ptr2, ptr3) .var
  2534
  2535 = 0086			ptr1	= edx
  2536 = 008A			ptr2	= ecx
  2537 = 0082			ptr3	= eax
  2538
  2539 = 0086			src	= ptr1
  2540 = 008A			dst	= ptr2
  2541 = 0082			cnt	= ptr3
  2542
  2543 3597 A5 8B C5 87 D0 04 + 	cpw ptr2 ptr1
  2544 35A1 B0 03			scs
  2545 35A3 4C 6C 35			jmp @moveu
  2546
  2547 35A6 8E EA 35			stx @sp
  2548
  2549 				; Copy downwards. Adjust the pointers to the end of the memory regions.
  2550
  2551 35A9 A5 87			lda     ptr1+1
  2552 35AB 18 65 83			add     ptr3+1
  2553 35AE 85 87			sta     ptr1+1
  2554
  2555 35B0 A5 8B			lda     ptr2+1
  2556 35B2 18 65 83			add     ptr3+1
  2557 35B5 85 8B			sta     ptr2+1
  2558
  2559 				; handle fractions of a page size first
  2560
  2561 35B7 A4 82			ldy     ptr3		; count, low byte
  2562 35B9 D0 06			bne     @entry		; something to copy?
  2563 35BB F0 0B			beq     PageSizeCopy	; here like bra...
  2564
  2565 35BD			@copyByte:
  2566 35BD B1 86			lda     (ptr1),y
  2567 35BF 91 8A			sta     (ptr2),y
  2568 35C1			@entry:
  2569 35C1 88				dey
  2570 35C2 D0 F9			bne     @copyByte
  2571 35C4 B1 86			lda     (ptr1),y	; copy remaining byte
  2572 35C6 91 8A			sta     (ptr2),y
  2573
  2574 35C8			PageSizeCopy:			; assert Y = 0
  2575 35C8 A6 83			ldx     ptr3+1		; number of pages
  2576 35CA F0 1D			beq     done		; none? -> done
  2577
  2578 35CC			@initBase:
  2579 35CC C6 87			dec     ptr1+1		; adjust base...
  2580 35CE C6 8B			dec     ptr2+1
  2581 35D0 88				dey			; in entry case: 0 -> FF
  2582 35D1 B1 86			lda     (ptr1),y	; need to copy this 'intro byte'
  2583 35D3 91 8A			sta     (ptr2),y	; to 'land' later on Y=0! (as a result of the '.repeat'-block!)
  2584 35D5 88				dey			; FF ->FE
  2585 35D6			@copyBytes:
  2586 					.rept 2		; Unroll this a bit to make it faster...
  2587 					LDA     (PTR1),Y
  2588 					STA     (PTR2),Y
  2589 					DEY
  2590 					.ENDR
  2590 					.endr
Source: REPT
  2587 35D6 B1 86			LDA     (PTR1),Y
  2587 35D8 91 8A			STA     (PTR2),Y
  2587 35DA 88				DEY
  2587 35DB B1 86			LDA     (PTR1),Y
  2587 35DD 91 8A			STA     (PTR2),Y
  2587 35DF 88				DEY
Source: cpu6502.asm
  2591 35E0			@copyEntry:			; in entry case: 0 -> FF
  2592 35E0 D0 F4			bne     @copyBytes
  2593 35E2 B1 86			lda     (ptr1),y	; Y = 0, copy last byte
  2594 35E4 91 8A			sta     (ptr2),y
  2595 35E6 CA				dex			; one page to copy less
  2596 35E7 D0 E3			bne     @initBase	; still a page to copy?
  2597
  2598 35E9 A2 00		done	ldx #0
  2599 = 35EA			@sp	equ *-1
  2600 35EB 60				rts
  2601 				.endp
  2602
  2603
  2604 				; Ullrich von Bassewitz, 29.05.1998
  2605 				; Performance increase (about 20%) by
  2606 				; Christian Krueger, 12.09.2009, slightly improved 12.01.2011
  2607
  2608 35EC			.proc	@fill (.word ptr1, ptr3 .byte ptr2) .var
  2609
  2610 = 0086			ptr1 = edx
  2611 = 008A			ptr3 = ecx
  2612 = 0082			ptr2 = eax
  2613
  2614 35EC 8A 48			txa:pha
  2615
  2616 35EE A6 82			ldx ptr2
  2617
  2618 35F0 A0 00			ldy #0
  2619
  2620 35F2 46 8B		        lsr	ptr3+1          ; divide number of
  2621 35F4 66 8A		        ror	ptr3            ; bytes by two to increase
  2622 35F6 90 09		        bcc	evenCount       ; speed (ptr3 = ptr3/2)
  2623 35F8			oddCount:
  2624 								; y is still 0 here
  2625 35F8 8A			        txa			; restore fill value
  2626 35F9 91 86		        sta	(ptr1),y	; save value and increase
  2627 35FB E6 86		        inc	ptr1		; dest. pointer
  2628 35FD D0 02		        bne	evenCount
  2629 35FF E6 87		        inc	ptr1+1
  2630 3601			evenCount:
  2631 3601 A5 86			lda	ptr1		; build second pointer section
  2632 3603 18				clc
  2633 3604 65 8A			adc	ptr3		; ptr2 = ptr1 + (length/2) <- ptr3
  2634 3606 85 82			sta     ptr2
  2635 3608 A5 87			lda     ptr1+1
  2636 360A 65 8B			adc     ptr3+1
  2637 360C 85 83			sta     ptr2+1
  2638
  2639 360E 8A			        txa			; restore fill value
  2640 360F A6 8B		        ldx	ptr3+1		; Get high byte of n
  2641 3611 F0 13		        beq	L2		; Jump if zero
  2642
  2643 				; Set 256/512 byte blocks
  2644 								; y is still 0 here
  2645 				L1:	.rept 2		; Unroll this a bit to make it faster
  2646 					STA	(PTR1),Y	
  2647 					STA	(PTR2),Y	
  2648 					INY
  2649 					.ENDR
  2649 					.endr
Source: REPT
  2646 3613 91 86			STA	(PTR1),Y	
  2646 3615 91 82			STA	(PTR2),Y	
  2646 3617 C8				INY
  2646 3618 91 86			STA	(PTR1),Y	
  2646 361A 91 82			STA	(PTR2),Y	
  2646 361C C8				INY
Source: cpu6502.asm
  2650 361D D0 F4		        bne	L1
  2651 361F E6 87		        inc	ptr1+1
  2652 3621 E6 83		        inc	ptr2+1
  2653 3623 CA			        dex                     ; Next 256 byte block
  2654 3624 D0 ED		        bne	L1              ; Repeat if any
  2655
  2656 				; Set the remaining bytes if any
  2657
  2658 3626 A4 8A		L2:	ldy	ptr3            ; Get the low byte of n
  2659 3628 F0 07			beq	leave           ; something to set? No -> leave
  2660
  2661 362A 88			L3:	dey
  2662 362B 91 86			sta	(ptr1),y	; set bytes in low
  2663 362D 91 82			sta	(ptr2),y	; and high section
  2664 362F D0 F9			bne     L3		; flags still up to date from dey!
  2665
  2666 3631 68 AA		leave	pla:tax
  2667 3633 60				rts			; return
  2668 				.endp
  2669
  2670
  2671 				/*
  2672 				 add strings
  2673 				 result -> @buf
  2674 				*/
  2674
  2675 3634			.proc	@addString(.word ya) .reg
  2676
  2677 					sta ztmp
  2678 					sty ztmp+1
  2679
  2680 					stx @sp
  2681
  2682 					ldx @buf
  2683 					inx
  2684 					beq stop
  2685
  2686 					ldy #0
  2687 					lda (ztmp),y
  2688 					sta ile
  2689 					beq stop
  2690
  2691 					iny
  2692
  2693 3634			load	lda (ztmp),y
  2694 					sta @buf,x
  2695
  2696 					iny
  2697 					inx
  2698 					beq stop
  2699 					dec ile
  2700 					bne load
  2701
  2702 3634			stop	dex
  2703 					stx @buf
  2704
  2705 					ldx #0
  2706 3634			@sp	equ *-1
  2707 					rts
  2708
  2709 3634			ile	brk
  2710 				.endp
  2711
  2712
  2713 				/* ----------------------------------------------------------------------- */
  2714
  2715
  2716 3634			.proc	@AllocMem(.word ztmp .word ztmp+2) .var
  2717
  2718 					jsr swap
  2719
  2720 					adw spoint ztmp+2
  2721
  2722 					rts
  2723
  2724 3634			swap	txa:pha
  2725
  2726 					mwa spoint bp2
  2727
  2728 					ldx #0
  2729 					ldy #0
  2730
  2731 3634			loop	cpy ztmp+2
  2732 					bne @+
  2733 					cpx ztmp+3
  2734 					beq stop
  2735
  2736 3634			@	lda (bp2),y
  2737 					pha
  2738
  2739 					lda (ztmp),y
  2740 					sta (bp2),y
  2741
  2742 					pla
  2743 					sta (ztmp),y
  2744
  2745 					iny
  2746 					bne loop
  2747
  2748 					inc ztmp+1
  2749 					inc bp2+1
  2750 					inx
  2751
  2752 					jmp loop
  2753
  2754 3634			stop	pla:tax
  2755
  2756 					rts
  2757
  2758 3634			spoint	dta a(PROGRAMSTACK)
  2759 				.endp
  2760
  2761
  2762 3634			.proc	@FreeMem(.word ztmp .word ztmp+2) .var
  2763
  2764 					sbw @AllocMem.spoint ztmp+2
  2765
  2766 					jmp @AllocMem.swap
  2767 				.endp
  2768
  2769
  2770 				/* ----------------------------------------------------------------------- */
  2771
  2772
  2773 3634			.proc	@vbxe_detect
  2774
  2775 					ldy #.sizeof(detect)-1
  2776 					mva:rpl copy,y detect,y-
  2777
  2778 					jmp detect
  2779
  2780 3634			copy
  2781 0400				.local	detect,@buf
  2782 				;
  2783 				; 2009 by KMK/DLT
  2784 				;
  2785 					lda #0
  2786 					sta fxptr
  2787
  2788 				        lda #$d6
  2789 				        sta fxptr+1
  2790 				        ldy #FX_MEMB
  2791 				        jsr ?clr
  2792
  2793 				        jsr ?try
  2794 				        bcc ok
  2795
  2796 				        inc fxptr+1
  2797
  2798 					jsr ?try
  2799 					bcc ok
  2800
  2801 					lda #0
  2802 					sta fxptr+1
  2803 					rts
  2804
  2805 0400			?try    ldx $4000
  2806 				        jsr ?chk
  2807 				        bcc ?ret
  2808 				        inx
  2809 				        stx $4000
  2810 				        jsr ?chk
  2811 				        dec $4000
  2812 0400			?ret    rts
  2813
  2814 0400			ok	ldy	#VBXE_MINOR		; get core minor version
  2815 					lda	(fxptr),y
  2816 					rts
  2817
  2818 0400			?chk    lda #$80
  2819 				        jsr _vbxe_write
  2820 				        cpx $4000
  2821 				        bne ?fnd
  2822 				        sec
  2823 0400			        .byte $24
  2824 0400			?fnd    clc
  2825 0400			?clr    lda #$00
  2826 0400			_vbxe_write
  2827 				        sta (fxptr),y
  2828 				        rts
  2829
  2830 				/*
  2831 					lda	#0
  2832 					ldx	#0xd6
  2833 					sta	0xd640			; make sure it isn't coincidence
  2834 					lda	0xd640
  2835 					cmp	#0x10			; do we have major version here?
  2836 					beq	VBXE_Detected		; if so, then VBXE is detected
  2837 					lda	#0
  2838 					inx
  2839 					sta	0xd740			; no such luck, try other location
  2840 					lda	0xd740
  2841 					cmp	#0x10
  2842 					beq	VBXE_Detected
  2843 					ldx 	#0  			; not here, so not present or FX core version too low
  2844 					stx	fxptr+1
  2845 					stx	fxptr
  2846
  2847 					sec
  2848 					rts
  2849
  2850 				VBXE_Detected
  2851 					stx	fxptr+1
  2852 					lda	#0
  2853 					sta	fxptr
  2854
  2855 					ldy	#VBXE_MINOR		; get core minor version
  2856 					lda	(fxptr),y
  2857
  2858 					clc
  2859 					rts	 			; x - page of vbxe
  2860 				*/
  2860
  2861
  2862 					.endl
  2863
  2864 				.endp
  2865
  2866
  2867 3634			.proc	@setxdl(.byte a) .reg
  2868
  2869 					asl @
  2870 					sta idx
  2871
  2872 					fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000
  2873
  2874 					ldy #0
  2875 3634			idx	equ *-1
  2876
  2877 					lda MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc
  2878 					and msk,y
  2879 					ora val,y
  2880 					sta MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc
  2881
  2882 					lda MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc+1
  2883 					and msk+1,y
  2884 					ora val+1,y
  2885 					sta MAIN.SYSTEM.VBXE_WINDOW+s@xdl.xdlc+1
  2886
  2887 					fxs FX_MEMS #0
  2888 					rts
  2889
  2890 3634			msk	.array [6] .word
  2891 					[e@xdl.mapon]  = [XDLC_MAPON|XDLC_MAPOFF]^$FFFF
  2892 					[e@xdl.mapoff] = [XDLC_MAPON|XDLC_MAPOFF]^$FFFF
  2893 					[e@xdl.ovron]  = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2894 					[e@xdl.ovroff] = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2895 					[e@xdl.hr]     = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2896 					[e@xdl.lr]     = [XDLC_GMON|XDLC_OVOFF|XDLC_LR|XDLC_HR]^$FFFF
  2897 					.enda
  2898
  2899 3634			val	.array [6] .word
  2900 					[e@xdl.mapon]  = XDLC_MAPON
  2901 					[e@xdl.mapoff] = XDLC_MAPOFF
  2902 					[e@xdl.ovron]  = XDLC_GMON
  2903 					[e@xdl.ovroff] = XDLC_OVOFF
  2904 					[e@xdl.hr]     = XDLC_GMON|XDLC_HR
  2905 					[e@xdl.lr]     = XDLC_GMON|XDLC_LR
  2906 					.enda
  2907
  2908 				.endp
  2909
  2910
  2911 3634			.proc	@vbxe_init
  2912
  2913 					fxs FX_MEMC #%1000+>MAIN.SYSTEM.VBXE_WINDOW	; $b000..$bfff (4K window), cpu on, antic off
  2914 					fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000	; enable VBXE BANK #0
  2915
  2916 					ldx #.sizeof(s@xdl)-1
  2917 					mva:rpl xdlist,x MAIN.SYSTEM.VBXE_XDLADR+MAIN.SYSTEM.VBXE_WINDOW,x-
  2918
  2919 					jsr cmapini		; init color map
  2920
  2921 					fxsa FX_P1		; A = 0
  2922 					fxsa FX_P2
  2923 					fxsa FX_P3
  2924
  2925 					fxsa FX_IRQ_CONTROL
  2926 					fxsa FX_BLITTER_START
  2927
  2928 					fxsa FX_XDL_ADR0	; XDLIST PROGRAM ADDRES (VBXE_XDLADR = $0000) = bank #0
  2929 					fxsa FX_XDL_ADR1
  2930 					fxsa FX_XDL_ADR2
  2931
  2932 					sta colpf0s
  2933
  2934 					fxs FX_P0 #$ff
  2935
  2936 					mwa #@vbxe_cmap @putchar.vbxe+1
  2937 					mva #{jsr*} @putchar.vbxe
  2938
  2939 					fxs FX_VIDEO_CONTROL #VC_XDL_ENABLED|VC_XCOLOR	;|VC_NO_TRANS
  2940
  2941 					rts
  2942
  2943 3634			cmapini	lda colpf1s
  2944 					and #$0f
  2945 					sta colpf1s
  2946
  2947 					lda #$80+MAIN.SYSTEM.VBXE_MAPADR/$1000
  2948 					sta ztmp
  2949
  2950 					mva #4 ztmp+1
  2951
  2952 3634			loop	fxs FX_MEMS ztmp
  2953
  2954 					lda >MAIN.SYSTEM.VBXE_WINDOW
  2955 					sta bp+1
  2956
  2957 					ldx #16
  2958 					ldy #0
  2959
  2960 3634			lop	mva #$00	(bp),y+
  2961 					mva colpf1s	(bp),y+
  2962 					mva colpf2s	(bp),y+
  2963 					mva #%00010000	(bp),y+		; overlay palette #1
  2964 					bne lop
  2965
  2966 					inc bp+1
  2967 					dex
  2968 					bne lop
  2969
  2970 					inc ztmp
  2971
  2972 					dec ztmp+1
  2973 					bne loop
  2974
  2975 					fxs FX_MEMS #$00		; disable VBXE BANK
  2976 					rts
  2977
  2978 				xdlist	dta s@xdl [0] (XDLC_RPTL, 24-1,\
  2979 					XDLC_END|XDLC_RPTL|XDLC_MAPON|XDLC_MAPADR|XDLC_OVADR|XDLC_MAPPAR|XDLC_OVATT,\	;|XDLC_GMON,\
  2980 					192-1, MAIN.SYSTEM.VBXE_OVRADR, 320,\
  2981 					MAIN.SYSTEM.VBXE_MAPADR, $100,\
  2982 					0, 0, 7, 7, %00010001, $ff)
  2982 3634			XDLIST	DTA S@XDL [0] (XDLC_RPTL, 24-1,	XDLC_END|XDLC_RPTL|XDLC_MAPON|XDLC_MAPADR|XDLC_OVADR|XDLC_MAPPAR|XDLC_OVATT,	192-1, MAIN.SYSTEM.VBXE_OVRADR, 320,	MAIN.SYSTEM.VBXE_MAPADR, $100,	0, 0, 7, 7, %00010001, $ff)
  2983 				.endp
  2984
  2985
  2986 3634			.proc	@vbxe_cmap
  2987
  2988 					pha
  2989
  2990 					cmp #eol
  2991 					beq stop
  2992
  2993 					cmp #$7d		; clrscr
  2994 					bne skp
  2995
  2996 					jsr @vbxe_init.cmapini
  2997 					jmp stop
  2998
  2999 3634			skp	lda rowcrs
  3000 					pha
  3001 3634				:4 lsr @
  3002 					add #$80+MAIN.SYSTEM.VBXE_MAPADR/$1000
  3003 					fxsa FX_MEMS
  3004
  3005 					pla
  3006 					and #$0f
  3007 					add >MAIN.SYSTEM.VBXE_WINDOW
  3008 					sta bp+1
  3009
  3010 					lda colcrs
  3011 					asl @
  3012 					asl @
  3013 					tay
  3014 					mva colpf0s (bp),y
  3015 					iny
  3016 					mva colpf1s (bp),y
  3017 					iny
  3018 					mva colpf2s (bp),y
  3019
  3020 					fxs FX_MEMS #$00
  3021
  3022 3634			stop	pla
  3023
  3024 					rts
  3025 				.endp
  3026
  3027
  3028 				/* ----------------------------------------------------------------------- */
  3029
  3030
  3031 				/*
  3032 				.proc	@cmdline (.byte a) .reg
  3033
  3034 					stx @sp
  3035
  3036 					sta idpar
  3037
  3038 					lda #0
  3039 					sta parno
  3040
  3041 					lda boot?		; sprawdzamy, czy DOS w ogole jest w pamieci
  3042 					lsr
  3043 					bcc _no_command_line
  3044
  3045 					lda dosvec+1		; a jesli tak, czy DOSVEC nie wskazuje ROM-u
  3046 					cmp #$c0
  3047 					bcs _no_command_line
  3048
  3049 					ldy #$03
  3050 					lda (dosvec),y
  3051 					cmp #{jmp}
  3052 					bne _no_command_line
  3053
  3054 					ldy #$0a		; COMTAB+$0A (BUFOFF)
  3055 					lda (dosvec),y
  3056 					sta lbuf
  3057 					iny
  3058 					lda (dosvec),y
  3059 					sta hbuf
  3060
  3061 					adw dosvec #3 zcr
  3062
  3063 				loop	lda #0
  3064 					sta @buf
  3065
  3066 					jsr $ffff
  3067 				zcr	equ *-2
  3068 					beq stop
  3069
  3070 					lda idpar
  3071 					bne skp
  3072
  3073 					ldy #33			; ParamStr(0)
  3074 				_par0	lda (dosvec),y
  3075 					sta @buf-33+1,y
  3076 					iny
  3077 					cpy #36
  3078 					bne _par0
  3079
  3080 					lda #3
  3081 					sta @buf
  3082 					bne stop
  3083
  3084 				skp	ldy #36
  3085 				_cp	lda (dosvec),y
  3086 					sta @buf-36+1,y
  3087 					iny
  3088 					cmp #$9b
  3089 					bne _cp
  3090
  3091 					tya
  3092 					sub #37
  3093 					sta @buf
  3094
  3095 					inc parno
  3096 					lda #0
  3097 				parno	equ *-1
  3098 					cmp #0
  3099 				idpar	equ *-1
  3100
  3101 					bne loop
  3102
  3103 				stop	ldy #$0a		; przywracamy poprzednia wartosc BUFOFF
  3104 					lda #0
  3105 				lbuf	equ *-1
  3106 					sta (dosvec),y
  3107 					iny
  3108 					lda #0
  3109 				hbuf	equ *-1
  3110 					sta (dosvec),y
  3111
  3112 				_no_command_line		; przeskok tutaj oznacza brak dostepnosci wiersza polecen
  3113
  3114 					lda parno
  3115
  3116 					ldx #0
  3117 				@sp	equ *-1
  3118 					rts
  3119 				.endp
  3120 				*/
  3120
  3121
  3122
  3123 3634			.proc	@CmdLine (.byte a) .reg
  3124
  3125 					stx @sp
  3126
  3127 					sta idpar
  3128
  3129 					lda #0
  3130 					sta parno
  3131 					sta loop+1
  3132
  3133 					lda	#{jsr*}
  3134 					sta	res
  3135
  3136 				; Get filename from SpartaDOS...
  3137 3634			get_param
  3138 					lda boot?		; sprawdzamy, czy DOS w ogole jest w pamieci
  3139 					lsr
  3140 					bcc no_sparta
  3141
  3142 					lda dosvec+1		; a jesli tak, czy DOSVEC nie wskazuje ROM-u
  3143 					cmp #$c0
  3144 					bcs no_sparta
  3145
  3146 					ldy #$03
  3147 					lda (dosvec),y
  3148 					cmp #{jmp}
  3149 					bne no_sparta
  3150
  3151 					ldy #$0a		; COMTAB+$0A (BUFOFF)
  3152 					lda (dosvec),y
  3153 					sta lbuf
  3154 					iny
  3155 					lda (dosvec),y
  3156 					sta hbuf
  3157
  3158 					adw dosvec #33 tmp
  3159
  3160 					ldy #0
  3161 3634			fnm	lda (tmp),y
  3162 					iny
  3163 					cmp #$9b
  3164 					bne fnm
  3165
  3166 					tya			; remove .COM
  3167 					sub #5
  3168 					tay
  3169 					lda #0
  3170 					sta (tmp),y
  3171 					tay
  3172
  3173 					lda	#3
  3174 					sta	loop+1
  3175 					add	dosvec
  3176 					sta	get_adr
  3177 					lda	#0
  3178 					adc	dosvec+1
  3179 					sta	get_adr+1
  3180
  3181 					jmp	_ok
  3182
  3183 3634			no_sparta
  3184 					mwa #next get_adr
  3185
  3186 					lda	#{bit*}
  3187 					sta	res
  3188
  3189 				; ... or channel #0
  3190 					lda	MAIN.IOCB@COPY+2	; command
  3191 					cmp	#5			; read line
  3192 					bne	_no_command_line
  3193 					lda	MAIN.IOCB@COPY+3	; status
  3194 					bmi	_no_command_line
  3195 				; don't assume the line is EOL-terminated
  3196 				; DOS II+/D overwrites the EOL with ".COM"
  3197 				; that's why we rely on the length
  3198 					lda	MAIN.IOCB@COPY+9	; length hi
  3199 					bne	_no_command_line
  3200 					ldx	MAIN.IOCB@COPY+8	; length lo
  3201 					beq	_no_command_line
  3202 					inx:inx
  3203 					stx	arg_len
  3204 				; give access to three bytes before the input buffer
  3205 				; in DOS II+/D the device prompt ("D1:") is there
  3206 					lda	MAIN.IOCB@COPY+4
  3207 					sub	#3
  3208 					sta	tmp
  3209 					lda	MAIN.IOCB@COPY+5
  3210 					sbc	#0
  3211 					sta	tmp+1
  3212
  3213 					lda	#0
  3214 					ldy	#0
  3215 3634			arg_len	equ *-1
  3216 					sta	(tmp),y
  3217
  3218
  3219 3634			loop	ldy	#0
  3220
  3221 3634			_ok	ldx	#0
  3222
  3223 3634			lprea	lda	(tmp),y
  3224 					sta	@buf+1,x
  3225
  3226 					beq	stop
  3227
  3228 					cmp	#$9b
  3229 					beq	stop
  3230 					cmp	#' '
  3231 					beq	stop
  3232
  3233 					iny
  3234 					inx
  3235 					cpx #32
  3236 					bne lprea
  3237
  3238 3634			stop	lda #0
  3239 3634			parno	equ *-1
  3240 					cmp #0
  3241 3634			idpar	equ *-1
  3242 					beq found
  3243
  3244 					jsr $ffff		; sty loop+1
  3245 3634			get_adr	equ *-2
  3246 					beq found
  3247
  3248 					inc parno
  3249 					bne loop
  3250
  3251 3634			found	lda #0	;+$9b
  3252 					sta @buf+1,x
  3253 					stx @buf
  3254
  3255 3634			res	jsr sdxres
  3256
  3257 3634			_no_command_line		; przeskok tutaj oznacza brak dostepnosci wiersza polecen
  3258
  3259 					lda parno
  3260
  3261 					ldx #0
  3262 3634			@sp	equ *-1
  3263 					rts
  3264
  3265
  3266 3634			sdxres	ldy #$0a		; przywracamy poprzednia wartosc BUFOFF
  3267 					lda #0
  3268 3634			lbuf	equ *-1
  3269 					sta (dosvec),y
  3270 					iny
  3271 					lda #0
  3272 3634			hbuf	equ *-1
  3273 					sta (dosvec),y
  3274 					rts
  3275
  3276
  3277 3634			_next	iny
  3278 3634			next	lda (tmp),y
  3279 					beq _eol
  3280 					cmp #' '
  3281 					beq _next
  3282
  3283 					cmp #$9b
  3284 					beq _eol
  3285
  3286 					sty loop+1
  3287 					rts
  3288
  3289 3634			_eol	lda #0
  3290 					rts
  3291
  3292 				.endp
  3293
  3294
  3295 				/* ----------------------------------------------------------------------- */
  3296
  3297 				/*
  3298 				.proc	@rstsnd
  3299 					lda #0
  3300 					sta $d208
  3301 					sta $d218
  3302
  3303 					ldy #3
  3304 					sty $d20f
  3305 					sty $d21f
  3306 					rts
  3307 				.endp
  3308 				*/
  3308
  3309
  3310 				;	ert (*>$3fff) .and (*<$8000)
  3311
  3312
  3313 				/* ----------------------------------------------------------------------- */
  3314
  3315
  3316 3634			.proc	@xmsBank
  3317
  3318 = 0082			ptr3 = eax			; position	(4)
  3319
  3320 					mva ptr3+3 ztmp+1	; position shr 14
  3321 					mva ptr3+2 ztmp
  3322 					lda ptr3+1
  3323
  3324 					.rept 6
  3325 					LSR ZTMP+1
  3326 					ROR ZTMP
  3327 					ROR @
  3328 					.ENDR
  3328 					.endr
Source: REPT
  3325 					LSR ZTMP+1
  3325 					ROR ZTMP
  3325 					ROR @
  3325 					LSR ZTMP+1
  3325 					ROR ZTMP
  3325 					ROR @
  3325 					LSR ZTMP+1
  3325 					ROR ZTMP
  3325 					ROR @
  3325 					LSR ZTMP+1
  3325 					ROR ZTMP
  3325 					ROR @
  3325 					LSR ZTMP+1
  3325 					ROR ZTMP
  3325 					ROR @
  3325 					LSR ZTMP+1
  3325 					ROR ZTMP
  3325 					ROR @
Source: cpu6502.asm
  3329
  3330 					tax			; index to bank
  3331
  3332 					lda portb
  3333 					and #1
  3334 					ora main.misc.adr.banks,x
  3335 					sta portb
  3336
  3337 					lda ptr3 		; offset
  3338 					sta ztmp
  3339 					lda ptr3+1
  3340 					and #$3f
  3341 					ora #$40
  3342 					sta ztmp+1
  3343
  3344 					rts
  3345 				.endp
  3346
  3347
  3348 3634			.proc	@xmsReadBuf (.word ptr1, ptr2) .var
  3349
  3350 = 0086			ptr1 = dx	; buffer	(2)
  3351
  3352 = 008A			ptr2 = cx	; count		(2)
  3353 = 008C			pos = cx+2	; position	(2) pointer
  3354
  3355 = 0082			ptr3 = eax	; position	(4)
  3356
  3357 					txa:pha
  3358
  3359 					ldy #0
  3360 					lda (pos),y
  3361 					sta ptr3
  3362 					iny
  3363 					lda (pos),y
  3364 					sta ptr3+1
  3365 					iny
  3366 					lda (pos),y
  3367 					sta ptr3+2
  3368 					iny
  3369 					lda (pos),y
  3370 					sta ptr3+3
  3371
  3372 					lda ptr2+1
  3373 					beq lp2
  3374
  3375 3634			lp1	jsr @xmsBank
  3376
  3377 					lda ztmp+1
  3378 					cmp #$7f
  3379 					bne skp
  3380 					lda ztmp
  3381 					beq skp
  3382
  3383 					lda #0
  3384 					jsr nextBank
  3385 					jmp skp2
  3386
  3387 3634			skp	ldy #0
  3388 					mva:rne (ztmp),y @buf,y+
  3389
  3390 3634			skp2	lda portb
  3391 					and #1
  3392 					ora #$fe
  3393 					sta portb
  3394
  3395 					ldy #0
  3396 					mva:rne @buf,y (dx),y+
  3397
  3398 					inc dx+1	// inc(dx, $100)
  3399
  3400 					inl ptr3+1	// inc(position, $100)
  3401
  3402 					dec ptr2+1
  3403 					bne lp1
  3404
  3405 3634			lp2	jsr @xmsBank
  3406
  3407 					lda ztmp+1		; zakonczenie kopiowania
  3408 					cmp #$7f		; jesli przekraczamy granice banku $7FFF
  3409 					bne skp_
  3410
  3411 					lda ztmp
  3412 					add ptr2
  3413 					bcc skp_
  3414
  3415 					lda ptr2		; to realizuj wyjatek NEXTBANK, kopiuj PTR2 bajtow
  3416 					jsr nextBank
  3417 					jmp skp3
  3418
  3419 3634			skp_	ldy #0
  3420 3634			mv	lda (ztmp),y
  3421 					sta @buf,y
  3422 					iny
  3423 					cpy ptr2
  3424 					bne mv
  3425
  3426 3634			skp3	lda portb
  3427 					and #1
  3428 					ora #$fe
  3429 					sta portb
  3430
  3431 					ldy #0
  3432 3634			lp3	lda @buf,y
  3433 					sta (dx),y
  3434 					iny
  3435 					cpy ptr2
  3436 					bne lp3
  3437
  3438 					jmp @xmsUpdatePosition
  3439
  3440 3634			.local	nextBank
  3441
  3442 					sta max
  3443
  3444 					mwa ztmp src
  3445
  3446 					ldy #0
  3447 3634			mv0	lda $ffff,y
  3448 3634			src	equ *-2
  3449 					sta @buf,y
  3450 					iny
  3451 					inc ztmp
  3452 					bne mv0
  3453
  3454 					lda portb
  3455 					and #1
  3456 					ora main.misc.adr.banks+1,x
  3457 					sta portb
  3458
  3459 					ldx #0
  3460 3634			mv1	cpy #0
  3461 3634			max	equ *-1
  3462 					beq stp
  3463 					lda $4000,x
  3464 					sta @buf,y
  3465 					inx
  3466 					iny
  3467 					bne mv1
  3468 3634			stp	rts
  3469 				.endl
  3470
  3471 				.endp
  3472
  3473
  3474 3634			.proc	@xmsWriteBuf (.word ptr1, ptr2) .var
  3475
  3476 = 0086			ptr1 = dx	; buffer	(2)
  3477
  3478 = 008A			ptr2 = cx	; count		(2)
  3479 = 008C			pos = cx+2	; position	(2) pointer
  3480
  3481 = 0082			ptr3 = eax	; position	(4)
  3482
  3483 					txa:pha
  3484
  3485 					ldy #0			; przepisz POSITION spod wskaznika
  3486 					lda (pos),y
  3487 					sta ptr3
  3488 					iny
  3489 					lda (pos),y
  3490 					sta ptr3+1
  3491 					iny
  3492 					lda (pos),y
  3493 					sta ptr3+2
  3494 					iny
  3495 					lda (pos),y
  3496 					sta ptr3+3
  3497
  3498 3634			lp1	lda portb		; wylacz dodatkowe banki
  3499 					and #1
  3500 					ora #$fe
  3501 					sta portb
  3502
  3503 					ldy #0			; przepisz 256b z BUFFER do @BUF
  3504 					mva:rne (dx),y @buf,y+
  3505
  3506 					jsr @xmsBank		; wlacz dodatkowy bank
  3507
  3508 					lda ptr2+1
  3509 					beq lp2
  3510
  3511 					lda ztmp+1		; jesli przekraczamy granice banku $7FFF
  3512 					cmp #$7f
  3513 					bne skp
  3514 					lda ztmp
  3515 					beq skp
  3516
  3517 					lda #0			; to realizuj wyjatek NEXTBANK, kopiuj 256b
  3518 					jsr nextBank
  3519 					jmp skp2
  3520
  3521 3634			skp	mva:rne @buf,y (ztmp),y+
  3522
  3523 3634			skp2	inc dx+1		// inc(dx, $100)
  3524
  3525 					inl ptr3+1		// inc(position, $100)
  3526
  3527 					dec ptr2+1
  3528 					bne lp1
  3529
  3530 3634			lp2	lda ztmp+1		; zakonczenie kopiowania
  3531 					cmp #$7f		; jesli przekraczamy granice banku $7FFF
  3532 					bne skp_
  3533
  3534 					lda ztmp
  3535 					add ptr2
  3536 					bcc skp_
  3537
  3538 					lda ptr2		; to realizuj wyjatek NEXTBANK, kopiuj PTR2 bajtow
  3539 					jsr nextBank
  3540 					jmp quit
  3541
  3542 3634			skp_	ldy #0
  3543 3634			lp3	lda @buf,y
  3544 					sta (ztmp),y
  3545
  3546 					iny
  3547 					cpy ptr2
  3548 					bne lp3
  3549
  3550 3634			quit	lda portb
  3551 					and #1
  3552 					ora #$fe
  3553 					sta portb
  3554
  3555 					jmp @xmsUpdatePosition
  3556
  3557 3634			.local	nextBank
  3558
  3559 					sta max
  3560
  3561 					mwa ztmp dst
  3562
  3563 					ldy #0
  3564 3634			mv0	lda @buf,y
  3565 					sta $ffff,y
  3566 3634			dst	equ *-2
  3567 					iny
  3568 					inc ztmp
  3569 					bne mv0
  3570
  3571 					lda portb
  3572 					and #1
  3573 					ora main.misc.adr.banks+1,x
  3574 					sta portb
  3575
  3576 					ldx #0
  3577 3634			mv1	cpy #0
  3578 3634			max	equ *-1
  3579 					beq stp
  3580 					lda @buf,y
  3581 					sta $4000,x
  3582 					inx
  3583 					iny
  3584 					bne mv1
  3585 3634			stp	rts
  3586 				.endl
  3587
  3588 				.endp
  3589
  3590
  3591 3634			.proc	@xmsAddPosition
  3592
  3593 3634				.use @xmsReadBuf
  3594
  3595 					add ptr3
  3596 					sta ptr3
  3597 					lda #$00
  3598 					adc ptr3+1
  3599 					sta ptr3+1
  3600 					lda #$00
  3601 					adc ptr3+2
  3602 					sta ptr3+2
  3603 					lda #$00
  3604 					adc ptr3+3
  3605 					sta ptr3+3
  3606
  3607 					rts
  3608 				.endp
  3609
  3610
  3611 3634			.proc	@xmsUpdatePosition
  3612
  3613 3634				.use @xmsReadBuf
  3614
  3615 					tya
  3616 					jsr @xmsAddPosition
  3617
  3618 					ldy #0
  3619 					lda ptr3
  3620 					sta (pos),y
  3621 					iny
  3622 					lda ptr3+1
  3623 					sta (pos),y
  3624 					iny
  3625 					lda ptr3+2
  3626 					sta (pos),y
  3627 					iny
  3628 					lda ptr3+3
  3629 					sta (pos),y
  3630
  3631 					pla:tax
  3632 					rts
  3633 				.endp
  3634
  3635
  3636 				/* ----------------------------------------------------------------------- */
  3637
  3638
  3639 3634			.proc	@ClrScr
  3640
  3641 					ldx #$00
  3642 					lda #$0c
  3643 					jsr xcio
  3644
  3645 					mwa #ename ioadr,x
  3646
  3647 					mva #$0c ioaux1,x
  3648 					mva #$00 ioaux2,x
  3649
  3650 					lda #$03
  3651
  3652 3634			xcio	sta iocom,x
  3653 					jmp ciov
  3654
  3655 3634			ename	.byte 'E:',$9b
  3656
  3657 				.endp
  3658
  3659
  3660 				/* ----------------------------------------------------------------------- */
  3661
  3662
  3663 					opt l+
  4217
  4218 				; -----------------------------------------------------------
  4219
  4220 				.macro UNITINITIALIZATION
  4221 				
  4222 					.ifdef MAIN.SYSTEM.@UnitInit
  4223 					jsr MAIN.SYSTEM.@UnitInit
  4224 					eif
  4225 				
  4226 					.ifdef MAIN.ATARI.@UnitInit
  4227 					jsr MAIN.ATARI.@UnitInit
  4228 					eif
  4229 				
  4230 					.ifdef MAIN.CRT.@UnitInit
  4231 					jsr MAIN.CRT.@UnitInit
  4232 					eif
  4233 				
  4234 					.ifdef MAIN.B_PMG.@UnitInit
  4235 					jsr MAIN.B_PMG.@UnitInit
  4236 					eif
  4237 				
  4238 					.ifdef MAIN.JOYSTICK.@UnitInit
  4239 					jsr MAIN.JOYSTICK.@UnitInit
  4240 					eif
  4241 				.endm
  4242
  4243 					ift .SIZEOF(MAIN.SYSTEM) > 0
  4244 					.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
  4244 				SYSTEM: $2210..$22D9
  4245 					eif
  4246
  4247 					ift .SIZEOF(MAIN.ATARI) > 0
  4248 					.print 'ATARI: ',MAIN.ATARI,'..',MAIN.ATARI+.SIZEOF(MAIN.ATARI)-1
  4249 					eif
  4250
  4251 					ift .SIZEOF(MAIN.CRT) > 0
  4252 					.print 'CRT: ',MAIN.CRT,'..',MAIN.CRT+.SIZEOF(MAIN.CRT)-1
  4253 					eif
  4254
  4255 					ift .SIZEOF(MAIN.B_PMG) > 0
  4256 					.print 'B_PMG: ',MAIN.B_PMG,'..',MAIN.B_PMG+.SIZEOF(MAIN.B_PMG)-1
  4256 				B_PMG: $22DA..$2373
  4257 					eif
  4258
  4259 					ift .SIZEOF(MAIN.JOYSTICK) > 0
  4260 					.print 'JOYSTICK: ',MAIN.JOYSTICK,'..',MAIN.JOYSTICK+.SIZEOF(MAIN.JOYSTICK)-1
  4260 				JOYSTICK: $2374..$237B
  4261 					eif
  4262
  4263 					.print 'CODE: ',CODEORIGIN,'..',*-1
  4263 				CODE: $2000..$3633
  4264
  4265 3634			DATAORIGIN
  4266
  4267 3634 28 00 18 00 2D 0C + .by  $28 $00 $18 $00 $2D $0C $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
  4268 364C 00 00 00 03 40 41 + .by  $00 $00 $00 $03 $40 $41 $42 $43  $44 $45 $45 $45 $5C $5D $5E $5F  $5D $5E $5F $5D $5D $5C $5C $5C
  4269 3664 5D 5E 5D 5C 00 5C + .by  $5D $5E $5D $5C $00 $5C $5D $5C  $46 $47 $48 $49 $4A $4B $4C $4D  $01 $04 $0C $30 $01 $01 $05 $05
  4270 367C 01 01 12 09 03 00 + .by  $01 $01 $12 $09 $03 $00 $0F
  4271
  4272 = 004F			VARINITSIZE	= *-DATAORIGIN
  4273 = 0098			VARDATASIZE	= 152
  4274
  4275 = 36CC			PROGRAMSTACK	= DATAORIGIN+VARDATASIZE
  4276
  4277 					.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK
  4277 				DATA: $3634..$36CC
  4278
  4279 02E0-02E1> E4 21			run START
  4280
  4281 				; -----------------------------------------------------------
  4282
  4283 				.macro	STATICDATA
  4284 				.by  $0E $17 $08 $1E $14 $16 $12 $08  $0C $00 $11 $05 $07 $02 $80 $88  $98 $00 $24 $32 $70 $A0 $A3 $C3
  4285 				.by  $81 $80 $00 $00 $00 $00 $0F $16  $08 $1E $14 $16 $12 $08 $0C $00  $10 $00 $04 $04 $0C $18 $18 $18
  4286 				.by  $04 $04 $04 $2C $2C $08 $00 $40  $60 $30 $0E $17 $08 $1E $14 $16  $12 $08 $0C $11 $29 $21 $60 $64
  4287 				.by  $40 $40 $58 $08 $04 $04 $4E $94  $95 $83 $81 $00 $00 $00 $00 $00  $0F $16 $08 $1E $14 $16 $12 $08
  4288 				.by  $0C $00 $10 $00 $00 $00 $08 $08  $08 $18 $0C $04 $14 $34 $30 $20  $48 $70 $60 $30 $0E $17 $08 $1E
  4289 				.by  $14 $16 $12 $08 $0C $04 $08 $10  $00 $00 $20 $60 $58 $08 $00 $28  $28 $40 $C0 $E0 $60 $40 $40 $40
  4290 				.by  $00 $00 $00 $00 $00 $00 $18 $2C  $16 $3A $2C $38 $28 $10 $40 $80  $30 $10 $90 $E0 $70 $00 $48 $68
  4291 				.by  $20 $00 $60 $60 $40 $40 $00 $08  $16 $06 $0A $0E $0E $04 $00 $18  $39 $39 $78 $78 $58 $90 $80 $18
  4292 				.by  $1C $0E $0E $42 $40 $00 $00 $00  $00 $00 $00 $00 $00 $08 $16 $06  $0A $0E $0E $04 $00 $18 $18 $38
  4293 				.by  $38 $38 $14 $08 $08 $00 $18 $18  $18 $18 $18 $30 $30 $20 $00 $00  $00 $08 $16 $06 $0A $0E $0E $04
  4294 				.by  $00 $09 $19 $1C $1F $1A $18 $58  $40 $10 $18 $18 $30 $72 $72 $20  $00 $00 $00 $00 $00 $00 $00 $08
  4295 				.by  $16 $06 $0A $0E $0E $04 $00 $18  $18 $38 $38 $38 $30 $18 $18 $00  $10 $18 $0C $0C $0C $18 $30 $00
  4296 				.by  $00 $00 $00 $08 $16 $06 $0A $0E  $0E $04 $00 $08 $1C $1C $3C $3C  $1C $58 $40 $10 $18 $18 $18 $30
  4297 				.by  $30 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $10 $28 $0C  $14 $1C $18 $60 $E0 $E0 $D0 $F0
  4298 				.by  $60 $00 $00 $70 $38 $18 $18 $30  $10 $00 $00 $00 $7E $02 $02 $02  $02 $02 $02 $22 $22 $32 $3E $02
  4299 				.by  $24 $3C $24 $24 $24 $24 $24 $24  $34 $34 $24 $3C $1C $10 $10 $10  $10 $10 $10 $10 $10 $10 $10 $14
  4300 				.by  $20 $3C $24 $24 $24 $24 $24 $24  $24 $2C $24 $3C $7E $7E $42 $42  $42 $42 $42 $62 $62 $72 $7E $7E
  4301 				.by  $1E $04 $04 $04 $04 $04 $04 $04  $04 $04 $1C $06 $18 $18 $18 $18  $18 $18 $18 $18 $18 $18 $18 $18
  4302 				.by  $3C $20 $20 $20 $20 $20 $20 $20  $20 $20 $38 $20 $00 $20 $1D $20  $3A $20 $57 $20 $74 $20 $91 $20
  4303 				.by  $AE $20 $CB $20 $E8 $20 $05 $21  $22 $21 $3F $21 $5C $21 $68 $21  $74 $21 $80 $21 $8C $21 $98 $21
  4304 				.by  $A4 $21 $B0 $21
  4305 				.endm
  4306
  4307 					end
